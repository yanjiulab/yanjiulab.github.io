---
title: algorithm
date: 2019-10-07 19:56:32
comments: false
mathjax: true
---
{% include_code Merge.java algo/sort/Merge.java %}
{% centerquote %}
Algorithms + Data Structures = Programs
-- Niklaus Wirth

Bad programmers worry about the code. Good programmers worry about data structures and their relationships.
-- Torvalds Linus
{% endcenterquote %}

# 数据结构

## 数据类型 (Data Type)
[数据类型](https://en.wikipedia.org/wiki/Data_type)可以分为以下几种。

### 原始数据类型 (Primitive Data Type)
编程语言提供若干[原始数据类型](https://en.wikipedia.org/wiki/Primitive_data_type)，以作为程序以及专用化复合类型的创建基础。典型的原始数据类型包含各种**整数**、**浮点数**以及**布尔类型**。

{% note info %}
有些高级语言将 String 字符串视为内建数据类型 (Built-in type)，这是因为字符串使用的过于广泛，但字符串不属于原始数据类型。
{% endnote %}

### 复合数据类型 (Composite Types)
复合数据类型通常由原始数据类型以一定的方式组织而成，从而提供更便利的表达方式。每种编程语言提供的复合数据类型不尽相同，通常包括：
- Array：数组（广泛提供）
- String：字符串（广泛提供）
- Struct：结构体（例如 C）
- Union：联合体（例如 C）
- Object：对象（面向对象语言）
- Enumerate：枚举体（广泛提供）

### 其他类型 (Other Types)
除此之外，还有几种特别重要的类型，几乎在任何编程语言都有实现。
- Pointer：指针类型
- Reference：引用类型
- Function：函数类型

## 抽象数据类型 (Abstract Data Type)
抽象数据类型 (Abstract Data Type, ADT) 是计算机科学中具有类似行为的特定类别的数据结构的数学模型，简单的理解就是一种对于数据结构的抽象表示，因此也被称为抽象数据结构，其理论性较强，对于程序员而言，**ADT 可以看作是一种接口与实现分离**的表示，ADT 定义了某一类数据类型应该具有的特性和方法，却不关心其具体的实现，有助于程序员从宏观的角度来思考数据结构的组织。

从形式上讲，ADT 可以定义为“**一类对象，其逻辑行为由一组值和一组操作定义**”，这可以方便的通过支持类 (Class) 的编程语言实现。某些抽象数据类型在程序设计中相当普遍且实用，因此常常出现在编程语言的原生类型或标准库中。更多的信息可以查看 {% button https://en.wikipedia.org/wiki/Abstract_data_type, Abstract data type, home fa-fw fa-lg %}。

名称|特征|实现
---|---|---
List|列表的元素顺序排列|动态数组、链表
Set|集合包含不重复的元素|哈希表、树
Multiset|包含重复的元素的集合|
Map|由键唯一的键值对组成的集合|哈希表、树、链表
Multimap|由键不唯一的键值对组成的集合|
Graph|若干节点和链接组成的无规则图|邻接矩阵、链表的链表
Tree|若干节点和链接组成的层次结构|树
Stack|栈中元素先入后出|动态数组、链表
Queue|队列中元素先进先出|动态数组、链表
Priority queue|优先队列中元素有优先级区别|堆
Double-ended queue|两端都可以进出的队列|动态数组、双链表
Double-ended priority queue|两端都可以进出的优先队列|双端堆

我们可以看到，虽然抽象数据类型定义了一些接口的特征，但其后支撑的数据结构（实现部分）更加重要，其中主要包括：
- 动态数组
- **链表**
- **树**
- **哈希表**

而其中最复杂多变的就是树。

## 数据结构 (Data Structure)
数据结构 (Data Structure) 是抽象数据类型 (ADT) 的基础。抽象数据类型**定义**了数据类型的**逻辑形式**，而数据结构**实现**了数据类型的**物理形式**。

不同的数据结构适用于不同的应用，其中有一些是针对特殊任务而高度定制的。合理的数据结构不仅可以提高数据组织和使用的效率，还是设计高效算法的基础。

**数据结构的实现基于计算机可以在内存中存取数据**这一事实，计算机使用指针 (pointer) 来表示内存中的地址，而这个指针本身作为一个位字符串，也可以存储在内存中从而被程序使用。因此，数据结构可以被简单的分为两类：
- 数组 (array) 和 记录/结构体 (record, struct, structure) 这种数据结构**基于计算数据项的地址**，该类数据结构存储数据本身。
- 链接数据结构**基于存储数据项的地址**，该类数据结构不存储数据本身，而存储数据项的地址。

> Thus, the array and record data structures are based on computing the addresses of data items with arithmetic operations, while the linked data structures are based on storing addresses of data items within the structure itself.

数据结构的实现需要编写用于创建和管理该结构实例的方法，而一个数据结构的效率间接地被这些方法的性能而决定，这性能包括时间复杂度和空间复杂度。

以下是常用数据结构的列表 {% button https://en.wikipedia.org/wiki/List_of_data_structures, List of data structures, home fa-fw fa-lg %}

其中比较重要的将在其他博文详述：
- [Trees](/2020/01/21/algo-tree/)
- [Hash table](/2020/02/17/algo-hash-table/)

# 算法分析 (Analysis)
我们首先给出算法分析的一些基本概念，其次明确算法分析的符号表示，最后掌握一般算法分析的方式。

## 基本概念 
### 关心对象  
算法分析的结果意味着**预测算法需要的资源**。涉及到的资源有内存，通信带宽或计算机硬件，但是**通常最关心计算时间**。

### 技术模型  
我们假定使用 RAM 模型，在 RAM 模型中，**程序一条条执行**，没有并发操作。同时，不试图对当代计算机中常见的内存层次建模，也就是说，**不考虑高速缓存和虚拟内存**，但对于真实计算机运行的程序，这种影响有时是巨大的。对于这种问题，需要特殊考虑。

### 输入规模与运行时间
一般来说，算法的运行时间与输入规模同时增长。可以将“运行时间”看作是“输入规模”的一个函数。

**输入规模的概念依赖于具体的研究问题**。但感性上来说，输入规模度量是比较好找到的。例如在排序算法中，输入规模是待排序数组的项数，在一个输入为图的算法中，输入规模可以是图的顶点数和边数。

**一个算法在特定输入规模上的运行时间是指执行基本操作数或步数**。也就是说，我们认为执行一句 for 语句与执行一句 while 语句是相当的，只是两者语句代价不同，但也仍然只是不同的常数而已，在绝大多数情况下，我们不必考虑其中差别。

对于给定规模的输入n，我们可以将运行时间表示为 $T(n)$，即 n 的函数，其可能是 n 的对数函数、线性函数、二次函数等。

### 情况分析
- 最坏情况运行时间：对规模为 n 的任何输入，算法的最长运行时间。
- 最好情况运行时间：对规模为 n 的某个或某些输入，算法的最短运行时间。
- 平均情况运行时间：对规模为 n 的所有输入，算法的平均运行时间。

但是通常我们仅会关注**最坏情况运行时间**，理由如下：
- 一个算法的最坏情况运行时间，给出了任何输入的运行时间的一个上界。这样就可以确保，该算法绝不需要更长时间。
- 对于某些算法，最坏情况经常出现。比如对缺失信息的检索。
- 平均情况大致与最坏情况一样差。

在某些时候，我们会关注平均情况，这涉及到一些概率分析。

### 渐进效率
一个算法的运行时间中最重要的的项决定了我们真正感兴趣的**增长量级**。而不重要的低阶项（或者说极限情况下的高阶无穷小项）往往被忽略。当输入规模足够大时，我们要研究算法的**渐进效率**。即：极限中，算法的运行时间如何随输入规模的变大而增加。

但是，在实际使用中，需要结合实际规模考虑算法的可用性。渐进效率不是唯一的考虑因素，需要结合具体问题具体分析。例如,在 [0, 100] 范围内 $T(n) = n^2$ 比 $T(n) = 10000n$ 具有更好的性能，然而前者的渐进效率很低。

## 渐进符号表示
这部分涉及一些数学知识，不再详述，可阅读 wiki 相关词条内容。

- big Theta：给出渐进紧确界。
- big Order：给出渐进上界，但通常给出一个紧缺的上界。
- big Omega：给出渐进下界。
- small order：表示一个非渐进紧确的上界。
- small omega：表示一个非渐进紧确的下界。

## 算法分析
算法分析主要取决于该算法使用的**设计准则 (Design Paradigms)**。依据不同的准则设计出来的算法分析思路往往不同，但根据相同的准则设计出来的算法分析思路往往相同。例如，求单向图最短简单路径的算法与归并排序算法的分析思路不相同，因为前者依据动态规划设计，后者依据分治法设计。又如归并排序和求解最大子数组算法看起来很不相关，但是两者分析思路一致，因为均是基于分治法设计。

基于以上思路，我们得到如下启示：
1. 明确算法分析的基本原理和表示方法。
2. 掌握算法设计准则，从宏观学习算法分析思路。也就是掌握某一类问题。
3. 在算法设计准则掌握熟练的情况下。主要思考内容就是**如何把某个问题抽象成某一类问题**和**某一个问题中的特殊的地方**。

# 算法设计准则 (Design Paradigms)
- Iteration | 迭代
- Recursion | 递归
- Recurrence | 递推
- Randomization | 随机化
- Brute Force | 穷举法
- Back Tracking  | 回溯法
- Divide and Conquer | 分治法
- Dynamic Programming | 动态规划
- Greedy Algorithm | 贪心算法


# 排序 (Sorting)
排序是一个非常常见的应用，通常我们需要对各种数据类型进行排序，甚至包括自定义数据类型。但最终基本可以归结为三种：
- 通用排序算法
- 数字排序算法
- 字符串排序算法

详情请见 {% button /2020/03/17/algo-sort/, Sorting, book fa-fw fa-lg %}

# 搜索 (Searching)
搜索可能时最常用的场景了，与排序不同，毕竟搜索的结果只有两种：找到或未找到。因此搜索算法与待搜索的数据类型关系不大，只要是能比较的对象即可，搜索主要和数据组织的方式有关。感受一下以下的场景：
- 在一个数组里搜索一个数字、一个字符串；
- 在一个链表里搜索一个数字、一个字符串；
- 在一个字符串里搜索一个字符；
- 在一个树中搜索一个节点；
- 在一个哈希表中搜索一个键对应的值；
- 在一个图中搜索一个值；
- 在一个文件中搜索感兴趣的字符串；
- 在一个文件系统中搜索感兴趣的文件；
- 在互联网上搜索你感兴趣的某个文本；
- 在互联网上搜索你感兴趣的某些图片；

当然，后几种场景已经远远超出了数据结构和算法的范围，不过我们仍然可以感受到，**搜索对应于字典/符号表这一 ADT**，任何数据结构，`value = dict.get(key)` 都是最重要的 API 应用，毕竟我们关心的东西才是有价值的东西。

以下是一些搜索的算法：
- [二分搜索 Binary Search](/2019/11/12/algo-binary-search/)



<!-- ------------------------------------------------------------

# 符号表 (Symbol Table)
符号表 (symbol table, map, associative array or dictionary) 是一种由键值对 (key-value pairs) 的集合构成的抽象数据类型。符号表又称之为映射表、关联数组或者字典，其支持的操作如下：
- 向表中增加键值对
- 从表中删除键值对
- 在表中根据键查询其关联的值

因此，在符号表的实现中，我们关心的通常是**增、删、查**的性能，其中“改”操作可以视为“增”操作的一种，即插入一个键已存在但值不同的键值对视为表的更改。
## API 
## 实现 (Implementations)
### 链表
- get() 的实现为遍历链表
- put() 的实现也为遍历链表

### 总结 (Comparison)
Underlying data structure|
---|---|---|---
Unordered linked list (sequential search)|$$
Ordered arrays (binary search)|
BST|
RedBlackBST|
Hash table|

# Dynamic Programming (DP)

- careful brute force
- subproblems + reuse

example 1：
- fibonacci 
    - naive
    - naive + memorization
- shortest path
- text justification
- black jack

# Priority Queue
优先队列 (Priority Queue) 支持两种操作：
- 删除最大元素
- 插入元素

## API

## 初级实现
可以使用**有序或者无序的数组或链表**来实现优先队列。

### 数组实现
最简单的一种方法是修改栈的实现以支持优先队列的特性。其中，insert() 方法和 push() 方法完全相同；要实现 delMax() 方法，可以**添加一段选择排序的内循环代码，将最大元素和边界元素交换然后删除它**，就和栈的 pop() 方法实现一致。

和栈相同，可以加入动态调整数组大小的方法，使得数据结构中具有适合容量的元素而又不会溢出。

另一种方法就是在 insert() 方法中添加代码，**将所有较大的元素向右边移动一格，以使得数组保持有序，就和插入排序一样**，这样最大的元素总会在数组的一边，delMax() 的操作就和栈的 pop() 操作一致。

### 链表表示
和上文类似，可以用基于链表的栈作为基础，来支持优先队列的实现。而后只需要选择修改 pop() 来找到并返回最大元素，或者修改 push() 来保证所有元素为逆序并用 pop() 来删除并返回列表的首元素（最大的元素）。

### 分析
使用无序序列是解决这个问题的惰性方法，仅在返回最大元素的时候才采取行动；使用有序序列则是解决问题的积极方法，会在插入元素时候就保持列表有序，使得后续操作更加高效。

无论采用何种方式，插入元素和删除最大元素这两个操作之一在最坏情况下时间复杂度都是线性的，而接下来的基于数据结构**堆的实现能够保证两种操作都可以更快的执行**。

数据结构|插入元素|删除最大元素
:---|:---:|:---:
无序数组|$1$|$n$|
有序数组|$n$|$1$|
堆|$\log n$|$\log n$|

## 堆实现
### 堆的定义
二叉堆能够很好的实现优先队列的基本操作。

## 堆排序
1. 从无序数组中构造最大堆
2. 找到最大的元素 `A[1]`
3. 交换 `A[1]` 和 `A[n]` (最大的元素位于数组最后)
4. discard node n from heap
5. New root may violate max heap but children are max heaps. (Go to step 2)

# 字符串





## 单词查找树 (Trie)
### R 向单词查找树
### 三向单词查找树

二叉查找树与快速排序
单词查找树与高位优先字符串排序
三向单词查找树与三向字符串快速排序


## 子字符串查找
应用场景：
- 文本编辑器和浏览器查找单词 -->


# 推荐阅读
- [Algorithms 4th Edition](https://algs4.cs.princeton.edu/home/) | [算法 (第四版)](https://book.douban.com/subject/19952400/)