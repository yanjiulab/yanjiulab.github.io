---
title: database
date: 2019-12-26 10:16:15
comments: false
mathjax: true
---
# 数据库概念

# 关系型数据库
- [SQL]()
- [MySQL]()

# 非关系型数据库

- [Redis]()
- [MongoDB]()

## MongoDB




# ---draft below-------
# 事务
## 概念
事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

![transaction](transaction.png)

## ACID
### 原子性（Atomicity）
事务被视为**不可分割的最小单元**，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用**回滚日志（Undo Log）**来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

### 隔离性（Isolation）
一个事务所做的修改在最终提交以前，对其它事务是不可见的。

### 持久性（Durability）
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生奔溃可以用**重做日志（Redo Log）**进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

### 一致性（Consistency）
一致性是指系统从一个正确的状态,迁移到另一个正确的状态，正确的状态就是当前的状态满足预定的约束，只有满足一致性，事务的执行结果才是正确的，即 **C 是目的，AID 是手段**。因此可以得出以下的关系结论：
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况。

## 自动提交
MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。



# 并发一致性问题
在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

- 丢失修改
- 读脏数据
- 不可重复读
- 幻影读

产生并发不一致性问题的主要原因是**破坏了事务的隔离性**，解决方法是通过并发控制来保证隔离性。并发控制可以通过**封锁**来实现，但是封锁操作需要用户自己控制，相当复杂。**数据库管理系统提供了事务的隔离级别**，让用户以一种更轻松的方式处理并发一致性问题。

# 封锁
## 锁粒度
MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁**。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。因此**锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高**。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此**封锁粒度越小，系统开销就越大**。在选择封锁粒度时，需要在**锁开销**和**并发程度**之间做一个权衡。

## 锁类型

# 杂
## 数据模型
关系型 。。。
## 主流数据库
关系型：
非

## SQL

## 关系模型
### 主键 
所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。

最好用 id：自增整数类型 或 GUID BIGINT NOT NULL AUTO_INCREMENT

联合主键 ：并不常用

### 外键
外键并不是通过列名实现的，而是通过定义外键约束实现的：

ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);

由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。

- 一对多：
- 多对多：通过两个一对多实现
- 一对一：
有细心的童鞋会问，既然是一对一关系，那为啥不给students表增加一个mobile列，这样就能合二为一了？

如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，contacts表就不存在对应的记录。实际上，一对一关系准确地说，是contacts表一对一对应students表。

还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。

小结：关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。
### 索引

## SQL 查询
- 基本查询：`SELECT * FROM <表名>` / 也可以只有 SELECT
- 条件查询：`SELECT * FROM <表名> WHERE <条件表达式>` / 上述NOT条件NOT class_id = 2其实等价于class_id <> 2，因此，NOT查询不是很常用。
- 投影查询：`SELECT 列1, 列2, 列3 FROM ...` / 起别名
- 结果排序：`... ORDER BY <排序表达式>`
- 结果分页：`LIMIT <M> OFFSET <N>` / LIMIT 表示最多，如果不够，没事；OFFSET 表示偏移，也就是起点，注意，从零开始编号。OFFSET超了也没事，结果为空。；OFFSET 可以不写，默认从0开始，但不写 LIMIT 不行；LIMIT M OFFSET N 可以在 MySQL 里简写为 LIMIT N M，注意先表示偏移点，再表示个数
- 聚合查询：使用函数 `COUNT` `AVG` 等
- 分组：`GROUP BY`
SELECT class_id, gender, AVG(score) points FROM students
GROUP BY class_id, gender 
ORDER BY class_id, gender, points DESC;

### ff
通过对数据库表创建索引，可以提高查询速度。

通过创建唯一索引，可以保证某一列的值具有唯一性。

数据库索引对于用户和应用程序来说都是透明的。


## References
- [Database, wikipedia](https://en.wikipedia.org/wiki/Database)
- [SQL 教程，廖雪峰](https://www.liaoxuefeng.com/wiki/001508284671805d39d23243d884b8b99f440bfae87b0f4000)
