<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yjlab.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="并发编程的一个基本问题：我们总是希望原子式 (atomic) 的执行一系列指令。但由于处理器的中断，我们总是做不到。能够直接解决这个问题的一个办法就是使用锁。程序员在源代码中加锁，放在需要保护的关键区 (critical sections) 周围，保证这些关键部分代码能够像单条原子指令一样执行。">
<meta name="keywords" content="Concurrency,Lock,Thread">
<meta property="og:type" content="article">
<meta property="og:title" content="Locks">
<meta property="og:url" content="http://yjlab.xyz/2020/07/31/os-lock/index.html">
<meta property="og:site_name" content="Yanjiu Lab">
<meta property="og:description" content="并发编程的一个基本问题：我们总是希望原子式 (atomic) 的执行一系列指令。但由于处理器的中断，我们总是做不到。能够直接解决这个问题的一个办法就是使用锁。程序员在源代码中加锁，放在需要保护的关键区 (critical sections) 周围，保证这些关键部分代码能够像单条原子指令一样执行。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-10-21T03:34:31.865Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Locks">
<meta name="twitter:description" content="并发编程的一个基本问题：我们总是希望原子式 (atomic) 的执行一系列指令。但由于处理器的中断，我们总是做不到。能够直接解决这个问题的一个办法就是使用锁。程序员在源代码中加锁，放在需要保护的关键区 (critical sections) 周围，保证这些关键部分代码能够像单条原子指令一样执行。">

<link rel="canonical" href="http://yjlab.xyz/2020/07/31/os-lock/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Locks | Yanjiu Lab</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yanjiu Lab</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learning then grokking</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fa fa-home fa-fw"></i>首页</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-book fa-fw"></i>笔记</a>

  </li>


      
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yjlab.xyz/2020/07/31/os-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yanjiu Li">
      <meta itemprop="description" content="演绎一场技术溯源的盛宴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yanjiu Lab">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Locks
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-31 14:43:12" itemprop="dateCreated datePublished" datetime="2020-07-31T14:43:12+08:00">2020-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-21 11:34:31" itemprop="dateModified" datetime="2020-10-21T11:34:31+08:00">2020-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>并发编程的一个基本问题：我们总是希望原子式 (atomic) 的执行一系列指令。但由于处理器的中断，我们总是做不到。能够直接解决这个问题的一个办法就是使用锁。程序员在源代码中加锁，放在需要保护的关键区 (critical sections) 周围，保证这些关键部分代码能够像单条原子指令一样执行。</p>
<a id="more"></a>
<h1 id="锁的基本思想"><a class="markdownIt-Anchor" href="#锁的基本思想"></a> 锁的基本思想</h1>
<p><strong>更新共享变量</strong>是一种典型的关键代码段。尽管在源代码层次看起来只有一行，但编译后却产生多条指令，这是一个读-改-写模式，在其中任意一步发生线程调度，都可能造成错误的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance = balance + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>其他的关键区还可能是：为共享的链表增加一个元素，或对共享结构的复杂更新操作。</p>
<p>锁的解决思路如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock_t</span> mutex; <span class="comment">// some globally-allocated lock ’mutex’</span></span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>锁就是一个变量，这个变量主要保存了锁在某一时刻的状态，它</p>
<ul>
<li>要么是<strong>可用的</strong>，表示没有线程持有锁，</li>
<li>要么是<strong>被占用的</strong>，表示有一个线程持有锁，并且正处于关键区。</li>
</ul>
<p>lock 和 unlock 的语义十分简单：</p>
<ul>
<li>lock() 尝试获取锁，如果没有其他线程持有该锁，则该线程获取锁，并进入关键区。</li>
<li>unlock() 由持有锁的线程调用，一旦被释放，锁就变为可用状态。</li>
</ul>
<p>锁为程序员提供了最小的调度控制，使得程序员可以获得一些控制权，通过给关键区加锁，<strong>保证关键区内代码只有一个线程活跃</strong>，因此将原本由操作系统调度的混乱状态变得可控。</p>
<h1 id="pthread-锁"><a class="markdownIt-Anchor" href="#pthread-锁"></a> Pthread 锁</h1>
<p>POSIX 库将锁称之为互斥量 (mutual exclusion, mutex)，有时也叫 Pthread 锁，被用来提供线程之间的互斥。</p>
<p>使用起来也十分简单，大致代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock); </span><br></pre></td></tr></table></figure>
<h1 id="锁的实现和性能"><a class="markdownIt-Anchor" href="#锁的实现和性能"></a> 锁的实现和性能</h1>
<p>我们已经从程序员的角度，对锁如何工作有了一定的理解。那如何实现一个锁呢？我们需要什么<strong>硬件</strong>支持？需要什么<strong>操作系统</strong>的支持？</p>
<p>在实现锁之前，我们应该首先明确目标，为了评价锁是否能工作（并工作得好），我们应该先设立一些标准。</p>
<ul>
<li>第一是锁的基本任务，即提供<strong>互斥 (mutual exclusion)</strong>。锁是否能够有效阻止多个线程进入关键区？</li>
<li>第二是<strong>公平性 (fairness)</strong>。当锁可用时，是否每一个竞争线程有公平的机会抢到锁？从线程角度看就是，是否有竞争锁的线程由于一直无法竞争到锁而饿死。</li>
<li>最后是<strong>性能 (performance)</strong>。使用锁之后增加的时间开销有多少，不同的场景有何区别？</li>
</ul>
<h1 id="基于硬件的锁"><a class="markdownIt-Anchor" href="#基于硬件的锁"></a> 基于硬件的锁</h1>
<p>在本节中，我们仅用硬件支持，看看能实现到什么程度？</p>
<h2 id="控制中断"><a class="markdownIt-Anchor" href="#控制中断"></a> 控制中断</h2>
<p>最早提供的互斥解决方案之一，就是在关键区关闭中断，这个解决方案是为单处理器系统开发的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然由于是中断导致线程的切换，那我们就解决掉中断。很好，既然解决不了问题，就解决提出问题的人。</p>
<p>假设我们运行在这样一个单处理器系统上。通过在进入临界区之前关闭中断（使用特殊的硬件指令），可以保证临界区的代码不会被中断，从而原子地执行。结束之后，我们重新打开中断（同样通过硬件指令），程序正常运行。</p>
<p>这种方法简单，但却存在许多问题，主要包括：</p>
<ol>
<li>要求我们允许所有调用线程执行特权操作（打开关闭中断），并信任这种机制不会被滥用。无条件的信任一个用户程序是一个糟糕的选择。</li>
<li>这种方案不支持多处理器。</li>
<li>关闭中断导致中断丢失，可能会导致严重的系统问题。例如磁盘或者网络刚好来了数据，请求中断怎么办？</li>
</ol>
<h2 id="自旋锁-一次失败的尝试"><a class="markdownIt-Anchor" href="#自旋锁-一次失败的尝试"></a> 自旋锁 - 一次失败的尝试</h2>
<p>首先我们实现一个锁，<strong>用一个变量标记锁是否被持有</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>) <span class="comment">// TEST the flag</span></span><br><span class="line">    ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">1</span>; <span class="comment">// now SET it!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看互斥性，很明显可以分析出，该方法不满足互斥性。如果 Thread 1 在进入 lock 之后，设置 flag 为 1 之前被中断调度，那么由于此时 flag 仍然为 0，则其他线程同样可以进入 lock。</p>
<h2 id="基于-test-and-set-的自旋锁"><a class="markdownIt-Anchor" href="#基于-test-and-set-的自旋锁"></a> 基于 Test-And-Set 的自旋锁</h2>
<p>造成上述结果的原因是 test-and-set 这个过程不是原子的！基于这种概念，一些系统提供了一种最简单的硬件支持是测试并设置指令 (test-and-set instruction)，也叫作原子交换 (atomic exchange)。在 x86 上是 xchg 原子交换指令。我们用如下的 C 代码片段来定义 test-and-set 指令做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *old_ptr; <span class="comment">// fetch old value at old_ptr</span></span><br><span class="line">    *old_ptr = <span class="keyword">new</span>; <span class="comment">// store 'new' into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>test-and-set 指令做了下述事情。它返回 old_ptr 指向的旧值，同时更新为 new 的新值。当然，关键是这些代码原子地执行。因此我们之前的锁可以变为以下内容，其实只有 lock() 部分做了一点修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 test-and-set 指令，我们已经实现了一把最简单的<strong>自旋锁 (spin lock)</strong>。竞争锁的线程在 CPU 周期内一直自旋，直到锁可用。</p>
<p><strong>自旋锁在单 CPU 的情况下需要抢占式的调度器</strong>，即不断通过时钟中断一个线程，运行其他线程。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</p>
<p>我们来分析一下这个锁：</p>
<p>首先是互斥性，由于 test-and-set 指令，不难分析，在 lock 的过程要么线程进入关键区并设置 flag 为 1，要么一直等待自旋，直到 flag 为 0。</p>
<p>下一个标准是公平性，自旋锁对于等待线程的公平性如何呢？能够保证一个等待线程会进入临界区吗？答案是<strong>自旋锁不提供任何公平性保证</strong>。实际上，自旋的线程在竞争条件下可能会永远自旋。</p>
<p>最后是性能，性能可以分为两方面考虑：</p>
<ul>
<li>在单 CPU 的情况下，性能开销相当大。假设 N 个线程有一个进入关键区，则竞争锁的 N-1 个线程都会在放弃 CPU 之前自旋一个时间片。</li>
<li>在多 CPU 上，自旋锁性能不错。假设线程 A 在 CPU 1，线程 B 在 CPU 2 竞争同一个锁。线程 A（CPU 1）占有锁时，线程 B 竞争锁就会自旋（在 CPU 2 上）。然而，临界区一般都很短，因此很快锁就可用，然后线程 B 获得锁。自旋等待其他处理器上的锁，并没有浪费很多 CPU 周期，因此效果不错。</li>
</ul>
<h2 id="基于-compare-and-swap-的自旋锁"><a class="markdownIt-Anchor" href="#基于-compare-and-swap-的自旋锁"></a> 基于 Compare-And-Swap 的自旋锁</h2>
<p>某些系统提供了另一个硬件原语，名为 CAS。以下是这条指令的 C 语言伪代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (actual == expected)</span><br><span class="line">        *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> actual;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>有了 CAS 指令，就可以实现一个锁，类似于用 TAS 那样。例如，我们只要用下面的代码替换 lock() 函数即可实现一个自旋锁，其余代码不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>CAS 比 TAS 更强大，但就实现一个简单的自旋锁方面，两者是等价的。</p>
          </div>
<h2 id="基于-ll-sc-的自旋锁"><a class="markdownIt-Anchor" href="#基于-ll-sc-的自旋锁"></a> 基于 LL-SC 的自旋锁</h2>
<p>一些平台提供了实现临界区的一对指令。例如 MIPS 架构中，链接加载（load-linked）和条件式存储（store-conditional）可以用来配合使用，实现其他并发结构。</p>
<figure class="highlight c"><figcaption><span>Load Linkd and Stroe conditional</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadLinked</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StoreConditional</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no one has updated *ptr since the LoadLinked to <span class="keyword">this</span> address) &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Load-Linked 指令和典型加载指令类似，关键区别来自 Store-Conditional 指令，只有上一次加载的地址在期间都没有更新时，才会成功，（同时更新刚才 Load-Linked 的地址的值）。成功时，Store-Conditional 返回 1，并将 ptr 指向的值更新为 value。失败时，返回 0，并且不会更新值。</p>
<p>我们可以用链接加载和条件存储指令改写我们的 lock() 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (LoadLinked(&amp;lock-&gt;flag) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin until it's zero</span></span><br><span class="line">        <span class="keyword">if</span> (StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// if set-it-to-1 was a success: all done</span></span><br><span class="line">                <span class="comment">// otherwise: try it all over again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个线程调用 lock()，执行了链接的加载指令，返回 0。在执行条件式存储之前，中断产生了，另一个线程进入 lock 的代码，也执行链接式加载指令，同样返回 0。现在，两个线程都执行了链接式加载指令，将要执行条件存储。重点是只有一个线程能够成功更新标志为 1，从而获得锁；第二个执行条件存储的线程会失败（因为另一个线程已经成功执行了条件更新），必须重新尝试获取锁。</p>
<h2 id="基于-fetch-and-add-的自旋锁"><a class="markdownIt-Anchor" href="#基于-fetch-and-add-的自旋锁"></a> 基于 Fetch-And-Add 的自旋锁</h2>
<p>最后一个硬件原语是获取并增加（fetch-and-add）指令，它能原子地返回特定地址的旧值，并且让该值自增一。获取并增加的 C 语言伪代码如下：</p>
<p>我们使用 fetch-and-add 指令可以实现一个 ticket 锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ticket;</span><br><span class="line">    <span class="keyword">int</span> turn;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>不是用一个值，这个解决方案使用了 ticket 和 turn 变量来构建锁。基本操作也很简单：如果线程希望获取锁，首先对一个 ticket 值执行一个原子的获取并相加指令。这个值作为该线程的“turn”（顺位，即 myturn）。根据全局共享的 lock-&gt;turn 变量，当某一个线程的（myturn== turn）时，则轮到这个线程进入临界区。unlock 则是增加 turn，从而下一个等待线程可以进入临界区。</p>
<p>ticket 锁的过程类似于<strong>排队</strong>，每个竞争的线程 lock() 相当于入队，而 unlock() 相当于出队。不同于之前的方法：本方法能够<strong>保证所有线程都能抢到锁</strong>。只要一个线程获得了 ticket 值，最终一定会被调度。</p>
<h2 id="总结自旋过多"><a class="markdownIt-Anchor" href="#总结自旋过多"></a> 总结：自旋过多</h2>
<p>基于硬件的锁简单（只有几行代码）而且有效，这也是任何好的系统或者代码的特点。但是某些场景下，这些解决方案会效率低下。</p>
<p>如何让锁不会不必要地自旋，浪费 CPU 时间？只有硬件支持是不够的。我们还需要操作系统支持！</p>
<h1 id="基于硬件和-os-的锁"><a class="markdownIt-Anchor" href="#基于硬件和-os-的锁"></a> 基于硬件和 OS 的锁</h1>
<p>通过基于硬件的锁，有没有发现，每一个线程无论处于获取锁或是竞争锁的状态，都在不停的运行。</p>
<p>通过操作系统的支持，我们可以给线程定义状态：</p>
<ul>
<li>运行 (Running)：线程可以执行并正在执行，该线程此时获得 CPU 时间片。</li>
<li>就绪 (Ready)：线程可以执行，但由于线程调度机制，此时并没有获取 CPU 时间片。</li>
<li>阻塞 (Blocked)：线程不可以执行，因此也不参与线程调度，需要被唤醒后才能重新参与线程调度。</li>
</ul>
<h2 id="yield-系统调用让出替代自旋"><a class="markdownIt-Anchor" href="#yield-系统调用让出替代自旋"></a> yield 系统调用：让出替代自旋</h2>
<p>硬件支持让我们有了很大的进展：我们已经实现了有效、公平（通过 ticket 锁）的锁。但是，问题仍然存在：如果临界区的线程发生上下文切换，其他线程只能一直自旋，等待被中断的（持有锁的）进程重新运行。有什么好办法？</p>
<p>第一种简单友好的方法就是，<strong>在要自旋的时候放弃 CPU 时间片</strong>。在这种方法中，我们假定操作系统提供原语 yield()，线程可以调用它主动放弃 CPU，从而让其他线程运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        yield(); <span class="comment">// give up the CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程可以处于 3 种状态之一（运行、就绪和阻塞）。yield() 系统调用能够让运行 (running) 态变为就绪 (ready) 态，从而允许其他线程运行。因此，线程让出本质上是线程<strong>取消调度 (deschedules)</strong> 了它自己。</p>
<p>考虑在单 CPU 上运行两个线程。在这个例子中，基于 yield 的方法十分有效。如果许多线程（例如 100 个）反复竞争一把锁，则竞争线程将会一直处于 run-and-yield 模式，虽然比自旋好多了，但也浪费了不少时间在上下文切换的场景上。</p>
<p>更糟的是，我们还没有考虑饿死的问题。一个线程可能一直处于让出的循环，而其他线程反复进出临界区。</p>
<h2 id="使用队列睡眠替代自旋"><a class="markdownIt-Anchor" href="#使用队列睡眠替代自旋"></a> 使用队列：睡眠替代自旋</h2>
<p>前面一些方法的真正问题是存在太多的偶然性。调度程序决定如何调度。如果调度不合理，线程或者一直自旋（第一种方法），或者立刻让出 CPU（第二种方法）。无论哪种方法，都可能造成浪费或饿死。</p>
<p>因此，我们必须显式地施加某种控制，决定锁释放时谁能抢到锁。为了做到这一点，我们需要操作系统的更多支持，并需要一个<strong>队列</strong>来保存等待锁的线程。</p>
<p>简单起见，我们利用 Solaris 提供的支持，它提供了两个调用</p>
<ul>
<li>park() 能够让调用线程睡眠</li>
<li>unpark(threadID) 则会唤醒 threadID 标识的线程</li>
</ul>
<p>可以用这两个调用来实现锁，<strong>让调用者在获取不到锁时睡眠，在锁可用时被唤醒</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> guard;</span><br><span class="line">    <span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ;  <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">        m-&gt;flag = <span class="number">1</span>;  <span class="comment">// lock is acquired</span></span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">        park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ;  <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = <span class="number">0</span>;  <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(queue_remove(m-&gt;q));  <span class="comment">// hold lock (for next thread!)</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种解决方案中存在一个问题，假如在 park() 调用之前，刚好遇到该线程 park()，这时切换到另一个线程（比如持有锁的线程），如果该线程随后释放了锁。那当第一个线程重新获得时间片后，接下来又会执行一个 park()，因此可能会永远睡下去。这种问题有时称为<strong>唤醒/等待竞争 (wakeup/waiting race)</strong>。为了避免这种情况，我们需要额外的工作。</p>
<h2 id="linux-系统实现-两段锁"><a class="markdownIt-Anchor" href="#linux-系统实现-两段锁"></a> Linux 系统实现 - 两段锁</h2>
<p>例如，Linux 提供了 futex，它类似于 Solaris 的接口，但提供了更多内核功能。具体来说，每个 futex 都关联一个特定的物理内存位置，也有一个事先建好的内核队列。调用者通过 futex 调用（见下面的描述）来睡眠或者唤醒。</p>
<p>具体来说有两个调用：</p>
<ul>
<li>调用 futex_wait(address, expected) 时，如果 address 处的值等于 expected，就会让调线程睡眠。否则，调用立刻返回。</li>
<li>调用 futex_wake(address) 唤醒等待队列中的一个线程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span><span class="params">(<span class="keyword">int</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">/* Bit 31 was clear, we got the mutex (this is the fastpath) */</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_bit_test_set(mutex, <span class="number">31</span>) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    atomic_increment(mutex);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (atomic_bit_test_set(mutex, <span class="number">31</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            atomic_decrement(mutex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We have to wait now. First make sure the futex value</span></span><br><span class="line"><span class="comment">        we are monitoring is truly negative (i.e. locked). */</span></span><br><span class="line">        v = *mutex;</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        futex_wait(mutex, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_unlock</span><span class="params">(<span class="keyword">int</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Adding 0x80000000 to the counter results in 0 if and only if</span></span><br><span class="line"><span class="comment">    there are not other interested threads */</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_add_zero(mutex, <span class="number">0x80000000</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* There are other threads waiting for this mutex,</span></span><br><span class="line"><span class="comment">    wake one of them up. */</span></span><br><span class="line">    futex_wake(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码利用一个整数，同时记录锁<strong>是否被持有</strong>（整数的最高位），以及<strong>等待者的个数</strong>（整数的其余所有位）。因此，如果锁是负的，它就被持有（因为最高位被设置，该位决定了整数的符号）。这段代码的有趣之处还在于，它展示了如何优化常见的情况，即没有竞争时：只有一个线程获取和释放锁，所做的工作很少（获取锁时测试和设置的原子位运算，释放锁时原子的加法）。</p>
<p>Linux 采用的这种古老的锁方案多年来不断被采用，现在也称为<strong>两段锁 (two-phase lock)</strong>。两阶段锁意识到自旋可能很有用，尤其是在很快就要释放锁的场景。因此，两阶段锁的第一阶段会先自旋一段时间，希望它可以获取锁。但是，如果第一个自旋阶段没有获得锁，第二阶段调用者会睡眠，直到锁可用。上文的 Linux 锁就是这种锁，不过只自旋一次；更常见的方式是在循环中自旋固定的次数，然后使用 futex 睡眠。</p>
<h1 id="线程锁总结"><a class="markdownIt-Anchor" href="#线程锁总结"></a> 线程锁总结</h1>
<p>通过锁的方式可以实现关键区的原子性，评价一个锁的指标至少包括互斥性和公平性。</p>
<p>仅通过<strong>硬件原子原语</strong>的支持，我们可以实现简单的<strong>自旋锁</strong>，自旋锁在多 CPU 的情况下性能不错，但过多的自旋总是浪费宝贵的 CPU 时间片。</p>
<p>通过借助<strong>操作系统系统调用</strong>的支持，我们可以实现更有效率的锁，其中：</p>
<ul>
<li>通过 <strong>yield 系统调用</strong>可以显式让竞争线程在自旋时切换，节省 CPU 时间，但会导致频繁切换线程上下文的问题，或者线程反复让出 CPU 时间片而最终饿死自己。这种方式本质上是让线程在 running 和 ready 之间反复切换。</li>
<li>通过借助 <strong>wait/wake 函数和队列</strong>，可以让竞争线程在自旋时睡眠，并加入一个睡眠队列，通过逐个唤醒竞争线程来让竞争线程获得 CPU 时间片。这种方式本质上是让线程在 running 和 ready 状态之外还可以处于 block 状态，由于 block 线程不参与线程调度，因此节省了时间片。</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/uploads/wechatpay.png" alt="Yanjiu Li 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/uploads/alipay.jpeg" alt="Yanjiu Li 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Concurrency/" rel="tag"><i class="fa fa-tag"></i> Concurrency</a>
              <a href="/tags/Lock/" rel="tag"><i class="fa fa-tag"></i> Lock</a>
              <a href="/tags/Thread/" rel="tag"><i class="fa fa-tag"></i> Thread</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/29/tool-jmeter/" rel="prev" title="Tool-Jmeter">
      <i class="fa fa-chevron-left"></i> Tool-Jmeter
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/01/os-cv/" rel="next" title="Condition Variables">
      Condition Variables <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80MTAzMS8xNzU1Ng=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#锁的基本思想"><span class="nav-number">1.</span> <span class="nav-text"> 锁的基本思想</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pthread-锁"><span class="nav-number">2.</span> <span class="nav-text"> Pthread 锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#锁的实现和性能"><span class="nav-number">3.</span> <span class="nav-text"> 锁的实现和性能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于硬件的锁"><span class="nav-number">4.</span> <span class="nav-text"> 基于硬件的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#控制中断"><span class="nav-number">4.1.</span> <span class="nav-text"> 控制中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自旋锁-一次失败的尝试"><span class="nav-number">4.2.</span> <span class="nav-text"> 自旋锁 - 一次失败的尝试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-test-and-set-的自旋锁"><span class="nav-number">4.3.</span> <span class="nav-text"> 基于 Test-And-Set 的自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-compare-and-swap-的自旋锁"><span class="nav-number">4.4.</span> <span class="nav-text"> 基于 Compare-And-Swap 的自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-ll-sc-的自旋锁"><span class="nav-number">4.5.</span> <span class="nav-text"> 基于 LL-SC 的自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-fetch-and-add-的自旋锁"><span class="nav-number">4.6.</span> <span class="nav-text"> 基于 Fetch-And-Add 的自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结自旋过多"><span class="nav-number">4.7.</span> <span class="nav-text"> 总结：自旋过多</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于硬件和-os-的锁"><span class="nav-number">5.</span> <span class="nav-text"> 基于硬件和 OS 的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#yield-系统调用让出替代自旋"><span class="nav-number">5.1.</span> <span class="nav-text"> yield 系统调用：让出替代自旋</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用队列睡眠替代自旋"><span class="nav-number">5.2.</span> <span class="nav-text"> 使用队列：睡眠替代自旋</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-系统实现-两段锁"><span class="nav-number">5.3.</span> <span class="nav-text"> Linux 系统实现 - 两段锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程锁总结"><span class="nav-number">6.</span> <span class="nav-text"> 线程锁总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yanjiu Li"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Yanjiu Li</p>
  <div class="site-description" itemprop="description">演绎一场技术溯源的盛宴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanjiulab" title="GitHub → https://github.com/yanjiulab" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liyanjiu@outlook.com" title="E-Mail → mailto:liyanjiu@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Worth Reading
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://pages.cs.wisc.edu/~remzi/OSTEP" title="http://pages.cs.wisc.edu/~remzi/OSTEP" rel="noopener" target="_blank">OSTEP</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/" title="http://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/" rel="noopener" target="_blank">OSTEP-Chinese</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.apuebook.com/about3e.html" title="http://www.apuebook.com/about3e.html" rel="noopener" target="_blank">APUE</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mathcs.clarku.edu/~jbreecher/cs280/UNIX%20Network%20Programming(Volume1,3rd).pdf" title="https://mathcs.clarku.edu/~jbreecher/cs280/UNIX%20Network%20Programming(Volume1,3rd).pdf" rel="noopener" target="_blank">UNP</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cse.buffalo.edu/~hungngo/classes/TMA-Training/UNP/" title="https://cse.buffalo.edu/~hungngo/classes/TMA-Training/UNP/" rel="noopener" target="_blank">IUNP</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.yinwang.org/" title="http://www.yinwang.org/" rel="noopener" target="_blank">当然我在扯淡</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanjiu Li</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">206k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:07</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
