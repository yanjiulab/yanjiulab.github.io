<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yjlab.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="通过硬件和操作系统支持，正确组合可以实现锁。然而，锁并不是线程并发程序设计所需的唯一原语。具体来说，在很多情况下，线程需要检查某一条件 (condition) 满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕，这常被称为 join()。这种等待如何实现呢？">
<meta name="keywords" content="Concurrency,Lock,Thread">
<meta property="og:type" content="article">
<meta property="og:title" content="Condition Variables">
<meta property="og:url" content="http://yjlab.xyz/2020/08/01/os-cv/index.html">
<meta property="og:site_name" content="Yanjiu Lab">
<meta property="og:description" content="通过硬件和操作系统支持，正确组合可以实现锁。然而，锁并不是线程并发程序设计所需的唯一原语。具体来说，在很多情况下，线程需要检查某一条件 (condition) 满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕，这常被称为 join()。这种等待如何实现呢？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-10-21T03:34:31.849Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Condition Variables">
<meta name="twitter:description" content="通过硬件和操作系统支持，正确组合可以实现锁。然而，锁并不是线程并发程序设计所需的唯一原语。具体来说，在很多情况下，线程需要检查某一条件 (condition) 满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕，这常被称为 join()。这种等待如何实现呢？">

<link rel="canonical" href="http://yjlab.xyz/2020/08/01/os-cv/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Condition Variables | Yanjiu Lab</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yanjiu Lab</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learning then grokking</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fa fa-home fa-fw"></i>首页</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-book fa-fw"></i>笔记</a>

  </li>


      
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yjlab.xyz/2020/08/01/os-cv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Yanjiu Li">
      <meta itemprop="description" content="演绎一场技术溯源的盛宴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yanjiu Lab">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Condition Variables
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-01 20:08:50" itemprop="dateCreated datePublished" datetime="2020-08-01T20:08:50+08:00">2020-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-21 11:34:31" itemprop="dateModified" datetime="2020-10-21T11:34:31+08:00">2020-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>通过硬件和操作系统支持，正确组合可以实现锁。然而，锁并不是线程并发程序设计所需的唯一原语。具体来说，在很多情况下，线程需要检查某一条件 (condition) 满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕，这常被称为 join()。这种等待如何实现呢？<br><a id="more"></a></p>
<h1 id="为什么需要条件变量？"><a href="#为什么需要条件变量？" class="headerlink" title="为什么需要条件变量？"></a>为什么需要条件变量？</h1><p>下图是一个父线程想要等待子线程的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">    <span class="comment">// XXX how to indicate we are done?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// XXX how to wait for child?</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们期待这样的输出结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent: begin</span><br><span class="line">child</span><br><span class="line">parent: end</span><br></pre></td></tr></table></figure></p>
<p>但几乎任何时候（不是必然）你都会得到这样的输出结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent: begin</span><br><span class="line">parent: end</span><br></pre></td></tr></table></figure></p>
<p>这是因为此时<strong>父线程没有任何等待子线程执行完毕的机制</strong>，父线程结束时的 return 语句触发 exit()，所以将整个进程退出，导致子线程也退出，这就是根本没有 child 输出的原因。</p>
<p>等待另一个线程执行完毕并不是一个陌生的场景，在使用锁的场景中，竞争线程需要等待执行线程完毕才能执行，这里也是一样，我们可以在父线程上<strong>自旋等待</strong>，自旋时判断子线程是否执行完毕，当子线程执行完毕时，才继续执行父线程。</p>
<p>因此，我们可以利用一个全局变量和自旋来实现 join()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> done = <span class="number">0</span>;  <span class="comment">// always read done variable form memory instead of cpu cache</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">    done = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (done == <span class="number">0</span>)</span><br><span class="line">        ;  <span class="comment">// spin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然，这样的程序得到了我们期待的输出。</p>
<div class="note info">
            <p><strong>关键问题：如何等待一个条件？</strong><br>多线程程序中，一个线程等待某些条件是很常见的。简单的方案是自旋直到条件满足，这是极其低效的，某些情况下甚至是错误的。</p>
          </div>
<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>线程可以使用条件变量来等待一个条件变成真。条件变量是一个显式队列，当某些执行状态（条件）不满足时，线程可以把自己加入队列，等待该条件。当另外某个线程改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。</p>
<p>想一下我们解决自旋锁的思路。我们通过队列和 wait/weak 机制改进了自旋锁，如果把锁是否被占有视为一个条件，那么竞争线程等待执行线程的过程和父线程等待子线程几乎是一模一样的过程。不同之处在于条件变量允许用户自定义执行状态，用户可以针对不同的执行条件，管理不同的队列（条件变量），从而完成等待的逻辑控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;  <span class="comment">// 声明并初始化一个条件变量</span></span><br><span class="line">pthread_cond_wait(<span class="keyword">pthread_cond_t</span> *c, <span class="keyword">pthread_mutex_t</span> *m);  <span class="comment">// 线程要睡眠时调用</span></span><br><span class="line">pthread_cond_signal(<span class="keyword">pthread_cond_t</span> *c);  <span class="comment">// 唤醒等待在某个条件变量上的睡眠线程</span></span><br></pre></td></tr></table></figure>
<h1 id="实现-join-语义"><a href="#实现-join-语义" class="headerlink" title="实现 join 语义"></a>实现 join 语义</h1><p>我们使用 POSIX 的条件变量来改进上一节的自旋等待代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    done = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;c);  <span class="comment">// 唤醒 c 队列里的睡眠等待线程</span></span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="keyword">while</span> (done == <span class="number">0</span>) &#123;  <span class="comment">// 子线程未完成，父线程加入睡眠等待队列。</span></span><br><span class="line">        pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">    thr_exit();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    thr_join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两种情况需要考虑：</p>
<ol>
<li>父线程创建出子线程，但自己继续运行，然后马上调用 thr_join() 等待子线程。在这种情况下，它会先获取锁，检查条件，然后调用 wait() 让自己睡眠（从 15 行跳出）。子线程最终得以运行，打印出 child，并调用 thr_exit() 函数唤醒父线程。最后，父线程会运行（从 wait() 调用返回并持有锁），释放锁（17 行），</li>
<li>子线程在创建后立刻运行，设置变量 done 为 1，调用 signal 函数唤醒其他线程（这里没有其他线程），然后结束。父线程运行后调用 thr_join() 时，发现 done 已经是 1 了，就直接返回。</li>
</ol>
<p>join() 函数为何要使用 while？在本例中虽然使用 if 也是可以的，但使用 while 总是好的，详细原因下节会说明。</p>
<p>使用条件变量必须加锁吗？是的！我们假设线程在发信号和等待时都不加锁。如果父线程调用 thr_join()，然后检查完 done 的值为 0，然后试图睡眠。但在调用 wait 进入睡眠之前，父进程被中断。子线程修改变量 done 为 1，发出信号，同样没有等待线程。父线程再次运行时，就会长眠不醒。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">父线程</th>
<th style="text-align:center">子线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">if (done == 0)</td>
<td style="text-align:center">↓</td>
</tr>
<tr>
<td style="text-align:center">↓</td>
<td style="text-align:center">done = 1</td>
</tr>
<tr>
<td style="text-align:center">↓</td>
<td style="text-align:center">pthread_cond_signal(&amp;c); // invalid call</td>
</tr>
<tr>
<td style="text-align:center">pthread_cond_wait(&amp;c, &amp;m); // sleep forever</td>
<td style="text-align:center">↓</td>
</tr>
</tbody>
</table>
</div>
<div class="note info">
            <p>调用 signal 和 wait 时要持有锁：</p><ul><li>请在调用 signal 时尽量持有锁，尽管也有一些情况可以不加锁，但这应当避免。</li><li>调用 wait 必须持有锁，这是 wait 的语义强制要求的。因为 wait 调用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。</li></ul>
          </div>
<h1 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h1><p>生产者/消费者 (producer/consumer) 问题，也叫作有界缓冲区 (bounded buffer) 问题。</p>
<p>假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费。很多实际的系统中都会有这种场景。例如，在多线程的网络服务器中，一个生产者将 HTTP 请求放入工作队列（即有界缓冲区），消费线程从队列中取走请求并处理。</p>
<p><strong>因为有界缓冲区是共享资源，所以我们必须通过同步机制来访问它，以免产生竞态条件。</strong></p>
<h2 id="单值缓冲区"><a href="#单值缓冲区" class="headerlink" title="单值缓冲区"></a>单值缓冲区</h2><p>首先需要一个共享缓冲区，让生产者放入数据，消费者取出数据。简单起见，我们就拿一个整数来做缓冲区（你当然可以想到用一个指向数据结构的指针来代替），两个内部函数将值放入缓冲区，从缓冲区取值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// initially, empty</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(count == <span class="number">0</span>);</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    buffer = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(count == <span class="number">1</span>);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过锁和条件变量可以定义以下生产者和消费者线程代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">        &#125;</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;c);</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;c,&amp;m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;c);</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当只有一个生产者和一个消费者时，正常运行。然而当有两个以上消费者时，将会出现两个问题。</p>
<h3 id="Mesa-语义问题"><a href="#Mesa-语义问题" class="headerlink" title="Mesa 语义问题"></a>Mesa 语义问题</h3><p>第一个问题产生的原因很简单：在 $T<em>{C1}$ 被生产者唤醒后，但在它运行之前，缓冲区的状态被 $T</em>{C2}$ 改变了。发信号给线程只是唤醒它们，暗示状态发生了变化，但并不会保证在它运行之前状态一直是期望的情况。信号的这种释义常称为 Mesa 语义，为了纪念以这种方式建立条件变量的首次研究。另一种释义是 Hoare 语义，虽然实现难度大，但是会保证被唤醒线程立刻执行。实际上，几乎所有系统都采用了 Mesa 语义。</p>
<p>由于 Mesa 语义，我们要记住一条关于条件变量的简单规则：<strong>总是使用 while 循环</strong>。虽然有时候不需要重新检查条件，但这样做总是安全的，做了就开心了。</p>
<p>因此，解决这个问题的方式就是将上述两个 if 改成 while 即可。当消费者 $T_{C1}$ 被唤醒后，立刻再次检查共享变量。如果缓冲区此时为空，消费者就会回去继续睡眠，当然生产者中相应的 if 也需要改为 while。限于篇幅，代码不再列出。</p>
<h3 id="唤醒不明确问题"><a href="#唤醒不明确问题" class="headerlink" title="唤醒不明确问题"></a>唤醒不明确问题</h3><p>假设两个消费者 $T<em>{C1}$ 和 $T</em>{C2}$ 先运行，都睡眠了。生产者 $T<em>{P}$ 开始运行，在缓冲区放入一个值，唤醒了一个消费者 $T</em>{C1}$，并开始睡眠。现在是 $T<em>{C1}$ 消费者马上要运行，$T</em>{C2}$ 和 $T_{P}$ 都等待在同一个条件变量上。</p>
<p>消费者 $T<em>{C1}$ 消费了缓冲区，然后开始发信号，但是应该唤醒哪个线程呢？因为消费者已经清空了缓冲区，很显然，应该唤醒生产者。但是，如果它唤醒了 $T</em>{C2}$（这绝对是可能的，取决于等待队列是如何管理的），问题就出现了：</p>
<ul>
<li>消费者 $T<em>{C1}$ 消费了缓冲区，发完信号唤醒了 $T</em>{C2}$ 就回去睡眠了。</li>
<li>消费者 $T_{C2}$ 醒过来，发现队列为空，又继续回去睡眠。</li>
<li>生产者 $T_{P}$ 自从放入值后一直在睡眠。</li>
</ul>
<p>3 个线程都在睡眠，显然是一个缺陷!</p>
<p><strong>信号显然必须更有指向性，消费者不应该唤醒消费者，而应该只唤醒生产者，反之亦然</strong>。解决方案也很简单：使用两个条件变量，而不是一个，以便在系统状态改变时正确地发出信号，明确哪类线程应该唤醒。</p>
<h3 id="最终生产者-消费者方案"><a href="#最终生产者-消费者方案" class="headerlink" title="最终生产者/消费者方案"></a>最终生产者/消费者方案</h3><p>最终的解决方案如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// initially, empty</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> empty = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> fill = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    assert(count == <span class="number">0</span>);</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    buffer = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(count == <span class="number">1</span>);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> loops = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;empty, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;fill);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> loops = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;fill, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;empty);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check command line args */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;producer-num&gt; &lt;consumer-num&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create producers and consumers */</span></span><br><span class="line">    <span class="keyword">long</span> pro_num = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">long</span> con_num = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">pthread_t</span> producers[pro_num], consumers[con_num];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pro_num; i++) &#123;</span><br><span class="line">        pthread_create(&amp;producers[i], <span class="literal">NULL</span>, producer, (<span class="keyword">void</span> *)con_num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con_num; i++) &#123;</span><br><span class="line">        pthread_create(&amp;consumers[i], <span class="literal">NULL</span>, consumer, (<span class="keyword">void</span> *)pro_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() thread should do */</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生产者线程当缓存区满时等待条件变量 empty 为真，否则生产一个值并发信号给条件变量 fill。</li>
<li>消费者线程当缓存区空时等待条件变量 fill 为真，否则消费一个值并发信号给条件变量 empty。</li>
</ul>
<h2 id="多值缓冲区"><a href="#多值缓冲区" class="headerlink" title="多值缓冲区"></a>多值缓冲区</h2><p>我们现在有了可用的生产者/消费者方案，但不太通用。我们最后的修改是提高并发和效率。具体来说，增加更多缓冲区槽位，这样在线程睡眠之前可以生产/消费多个值。单个生产者和消费者时，这种方案因为上下文切换少，提高了效率。多个生产者和消费者时，它甚至支持并发生产和消费，从而提高了并发。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer[MAX];</span><br><span class="line"><span class="keyword">int</span> add = <span class="number">0</span>;   <span class="comment">// produce index</span></span><br><span class="line"><span class="keyword">int</span> use = <span class="number">0</span>;    <span class="comment">// consume index</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// initially, empty</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> empty = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> fill = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    buffer[add] = value;</span><br><span class="line">    add = (add + <span class="number">1</span>) % MAX;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = buffer[use];</span><br><span class="line">    use = (use + <span class="number">1</span>) % MAX;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> loops = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == MAX) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;empty, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;fill);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> loops = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;fill, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;empty);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check command line args */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;producer-num&gt; &lt;consumer-num&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create producers and consumers */</span></span><br><span class="line">    <span class="keyword">long</span> pro_num = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">long</span> con_num = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">pthread_t</span> producers[pro_num], consumers[con_num];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pro_num; i++) &#123;</span><br><span class="line">        pthread_create(&amp;producers[i], <span class="literal">NULL</span>, producer, (<span class="keyword">void</span> *)con_num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con_num; i++) &#123;</span><br><span class="line">        pthread_create(&amp;consumers[i], <span class="literal">NULL</span>, consumer, (<span class="keyword">void</span> *)pro_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() thread should do */</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了一个小技巧，让生产者线程数量 <em> 单位线程产出值数量（消费者线程数量） = 消费者线程数量 </em> 单位线程消费值数量（生产者线程数量），使得最终产生和消费数量相同，能正常退出进程。否则由于睡眠线程的存在，进程将不会退出。</p>
<h1 id="覆盖条件"><a href="#覆盖条件" class="headerlink" title="覆盖条件"></a>覆盖条件</h1><p>现在再来看条件变量的另一个例子，假设我们需要实现一个多线程的内存分配库。伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesLeft = MAX_HEAP_SIZE;  <span class="comment">// how many bytes of the heap are free?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cond_t</span> c;   <span class="comment">// need lock and condition too</span></span><br><span class="line"><span class="keyword">mutex_t</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="keyword">while</span> (bytesLeft &lt; size) Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    <span class="keyword">void</span> *ptr = ...;  <span class="comment">// get mem from heap</span></span><br><span class="line">    bytesLeft -= size;</span><br><span class="line">    Pthread_mutex_unlock(&amp;m);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;m);</span><br><span class="line">    bytesLeft += size;</span><br><span class="line">    Pthread_cond_signal(&amp;c);  <span class="comment">// whom to signal??</span></span><br><span class="line">    Pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，当线程调用进入内存分配代码时，它可能会因为内存不足而等待。相应的，线程释放内存时，会发信号说有更多内存空闲。但是，代码中有一个问题：应该唤醒哪个等待线程（可能有多个线程）？</p>
<p>假设目前没有空闲内存，线程 $T_A$ 调用 allocate(100)，接着线程 $T_B$ 调用 allocate(10) 请求较少的内存。$T_A$ 和 $T_B$ 都等待在条件并睡眠，因为没有足够的空闲内存来满足它们的请求。这时第三个线程 $T_C$ 调用了 free(50)。遗憾的是它可能不会唤醒申请 10 字节的 $T_B$ 线程，假设它发信号唤醒 $T_A$ ，由于内存不够，$T_A$ 重新睡眠等待。因为不知道唤醒哪个（或哪些）线程，所以上述代码无法正常工作。</p>
<p>解决方案也很直接：<strong>用 pthread_cond_broadcast() 代替上述代码中的 pthread_cond_signal()，以广播代替单播唤醒所有的等待线程</strong>。这确保了所有应该唤醒的线程都被唤醒。当然，不利的一面是可能会影响性能，因为不必要地唤醒了其他许多等待的线程，它们本来（还）不应该被唤醒。这些线程被唤醒后，重新检查条件，马上再次睡眠。</p>
<p>这种条件变量叫作<strong>覆盖条件 (covering condition)</strong>，因为它能覆盖所有需要唤醒线程的场景（保守策略）。</p>
<div class="note info">
            <p>在单个条件变量的生产者/消费者问题中，也可以使用这种方法，但在那个场景下两个条件变量是更好的选择。一般来说，如果你发现程序只有改成广播信号时才能工作（但你认为不需要），可能是程序有缺陷，修复它！但在上述内存分配的例子中，广播可能是最直接有效的方案。</p>
          </div>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们看到了引入锁之外的另一个重要同步原语：条件变量。当某些程序状态不符合要求时，通过允许线程进入睡眠状态（线程阻塞），条件变量使我们能够漂亮地解决许多重要的同步问题，包括著名的（仍然重要的）生产者/消费者问题，以及覆盖条件。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/uploads/wechatpay.png" alt="Yanjiu Li 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/uploads/alipay.jpeg" alt="Yanjiu Li 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Concurrency/" rel="tag"><i class="fa fa-tag"></i> Concurrency</a>
              <a href="/tags/Lock/" rel="tag"><i class="fa fa-tag"></i> Lock</a>
              <a href="/tags/Thread/" rel="tag"><i class="fa fa-tag"></i> Thread</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/31/os-lock/" rel="prev" title="Locks">
      <i class="fa fa-chevron-left"></i> Locks
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/02/os-process/" rel="next" title="进程 (Processes)">
      进程 (Processes) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80MTAzMS8xNzU1Ng=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么需要条件变量？"><span class="nav-number">1.</span> <span class="nav-text">为什么需要条件变量？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#条件变量"><span class="nav-number">2.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现-join-语义"><span class="nav-number">3.</span> <span class="nav-text">实现 join 语义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#生产者-消费者问题"><span class="nav-number">4.</span> <span class="nav-text">生产者/消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单值缓冲区"><span class="nav-number">4.1.</span> <span class="nav-text">单值缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mesa-语义问题"><span class="nav-number">4.1.1.</span> <span class="nav-text">Mesa 语义问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#唤醒不明确问题"><span class="nav-number">4.1.2.</span> <span class="nav-text">唤醒不明确问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最终生产者-消费者方案"><span class="nav-number">4.1.3.</span> <span class="nav-text">最终生产者/消费者方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多值缓冲区"><span class="nav-number">4.2.</span> <span class="nav-text">多值缓冲区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#覆盖条件"><span class="nav-number">5.</span> <span class="nav-text">覆盖条件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yanjiu Li"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Yanjiu Li</p>
  <div class="site-description" itemprop="description">演绎一场技术溯源的盛宴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanjiulab" title="GitHub → https://github.com/yanjiulab" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liyanjiu@outlook.com" title="E-Mail → mailto:liyanjiu@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Worth Reading
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://pages.cs.wisc.edu/~remzi/OSTEP" title="http://pages.cs.wisc.edu/~remzi/OSTEP" rel="noopener" target="_blank">OSTEP</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/" title="http://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/" rel="noopener" target="_blank">OSTEP-Chinese</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.apuebook.com/about3e.html" title="http://www.apuebook.com/about3e.html" rel="noopener" target="_blank">APUE</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mathcs.clarku.edu/~jbreecher/cs280/UNIX%20Network%20Programming(Volume1,3rd).pdf" title="https://mathcs.clarku.edu/~jbreecher/cs280/UNIX%20Network%20Programming(Volume1,3rd).pdf" rel="noopener" target="_blank">UNP</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cse.buffalo.edu/~hungngo/classes/TMA-Training/UNP/" title="https://cse.buffalo.edu/~hungngo/classes/TMA-Training/UNP/" rel="noopener" target="_blank">IUNP</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.yinwang.org/" title="http://www.yinwang.org/" rel="noopener" target="_blank">当然我在扯淡</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanjiu Li</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">217k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:17</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
