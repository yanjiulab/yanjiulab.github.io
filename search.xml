<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 执行 Shell 命令</title>
      <link href="/2020/11/15/python-with-shell/"/>
      <url>/2020/11/15/python-with-shell/</url>
      
        <content type="html"><![CDATA[<p>有时候编写的 shell 脚本逻辑复杂，然而 shell 提供的工具又不够简单易用，因此我们希望用 Python 重构其中复杂的逻辑，其中涉及到 Python 和 Shell 命令交互的方法。</p><a id="more"></a><h1 id="os-模块"><a class="markdownIt-Anchor" href="#os-模块"></a> <code>os</code> 模块</h1><p>os 模块提供了许多操作系统级别的功能接口。</p><h2 id="ossystem"><a class="markdownIt-Anchor" href="#ossystem"></a> os.system()</h2><p>运行 shell 命令的第一种也是最直接的方法是使用 <code>os.system()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">'ls -l'</span>)</span><br></pre></td></tr></table></figure><p>system() 函数以字符串形式接受一个命令，并在子 shell 中执行该命令。将上述代码保存成文件执行，我们可以在命令行中看到输出，这是通过调用标准 C 函数 system() 来实现的，并且两者具有相同的限制。</p><p>对于 <code>sys.stdin</code> 等的更改不会反映在已执行命令的环境中。并且如果命令生成任何输出，它将被发送到解释器标准输出流。</p><p>该函数的特点在于：<strong>无法以变量的形式得到命令的输出结果！该函数的返回值为命令的返回码</strong>。</p><h2 id="ospopen"><a class="markdownIt-Anchor" href="#ospopen"></a> os.popen()</h2><p><code>os.popen()</code> 命令从命令行或命令行打开管道，这意味着我们可以在 Python 中访问流，因此可以将输出作为变量获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="subprocess-模块"><a class="markdownIt-Anchor" href="#subprocess-模块"></a> <code>subprocess</code> 模块</h1><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://janakiev.com/blog/python-shell-commands/" target="_blank" rel="noopener">Python shell commands</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix/Linux 操作系统</title>
      <link href="/2020/10/21/os-unix/"/>
      <url>/2020/10/21/os-unix/</url>
      
        <content type="html"><![CDATA[<p>自 1969 年成立开始，Unix 系统便迅速流行，因为它为各种不同硬件架构的机器<strong>提供了统一的运行环境</strong>。Unix 系统分为两部分，一部分是<strong>程序 (programs) 和服务 (services)</strong> ,它们是供用户使用的，包括 Shell，邮件，文字处理包，源码控制系统等。另一部分是支持这些程序和服务的<strong>操作系统</strong>。</p><a id="more"></a><h2 id="发展历史"><a class="markdownIt-Anchor" href="#发展历史"></a> 发展历史</h2><ul><li>1965 年，Bell Telephone Laboratory，通用电气公司以及 MIT 的 MAC计划小组共同开发了 <strong>Multics</strong> 这个新的操作系统。</li><li>Multics 系统的原始版本确实在 GE 645 机器上运行，但因为没有提供预期统一计算服务，再加上发展目标不明确，因此，贝尔实验室结束了对该项目的支持。</li><li>贝尔实验室的科学家们打算改进它们自己的编程环境，于是，Ken Thompson, Dennis Ritchie 等人起草了一份文件系统 (file system) 设计的白皮书，后来推动了早期 Unix 文件系统的发展。后来再加上进程子系统和一些工具，Unix 就这样诞生了。其名称是相对于 Multics 的复杂而取的，<strong>暗含了 Unix 系统的精简</strong>。</li><li>第一版使用汇编语言和 B 语言写成。Ritchie 改进了 B 语言，创造了 C 语言，用来生成机器码，声明数据类型，定义数据结构。1973 年，<strong>系统用 C 语言重写</strong>。</li><li>1974年，汤普逊和里奇合作在 ACM 通信上发表了一篇关于 UNIX 的文章，这是 <strong>UNIX 第一次出现在贝尔实验室以外</strong>。</li><li>1982年，贝尔实验室综合了 AT&amp;T 开发的中多版本，形成了 <strong>UNIX System Ⅲ</strong>，不久有增加了一些新功能，重新命名为 <strong>UNIX System V</strong>，然而，加州大学伯克利分校开发了 <strong>BSD 4.3</strong>，其作为 UNIX System III 和 V 的替代选择。</li></ul><p>后来的事情大概也都是那些快速的发展和更迭，以及新特性的不断加入。目前，许多操作系统都是由 Unix 发展而来的，包括 Mac OS X，Linux 等。下图是 Unix 极其衍生操作系统发展过程的简单表示。<br><a href="unix-timeline.svg"><img src="unix-timeline.svg" alt="unix-timeline"></a></p><h2 id="系统结构"><a class="markdownIt-Anchor" href="#系统结构"></a> 系统结构</h2><p>将系统视为若干层，其中<strong>操作系统 (operating system, system kernel or just kernel) 直接与硬件交互，为上层程序提供通用服务并将它们与硬件特性隔离开来。</strong></p><p><img src="system-structure.png" alt="Architecture of UNIX Systems"></p><p>kernel 外的一层是 low-level 的程序，通过 <strong>系统调用 (system call)</strong> 与内核交互，这些程序包括 shell <code>sh</code> 和 editor <code>vi</code>，标准系统配置命令 (commands)，以及 <code>a.out</code> 这种由 C 编译器生成的可执行文件。同时，许多应用或程序是由许多 low-level 组合而成的，叫做 high-level 程序，这些程序通过对底层程序的调用，为用户提供了更好的界面和操作，同时简化了开发。</p><h2 id="编程接口"><a class="markdownIt-Anchor" href="#编程接口"></a> 编程接口</h2><p>在使用 C 语言编程实现某个功能时候，应当明确可以使用哪些基础库，包括：</p><ul><li>C 标准库</li><li>其他库<ul><li>POSIX (Portable Operating System Interface of Unix)</li><li>Linux Library</li><li>Windows Library</li><li>…</li></ul></li></ul><p>首先，应当尽可能使用 C 标准库中的接口，这些库保证了最佳的可移植性。当然编写 C 语言的代码不可避免的将会用到这些库。</p><p>在实际编程时，应<strong>尽量首选 POSIX 标准库接口</strong>，对于 Unix、Linux 以及 Mac OS X 系统，甚至 Windows 都具有较好的可移植性。标准定义了接口的规范，而不同的操作系统根据自身平台的特征实现了这些接口。</p><p>最后，考虑 Linux 库以及 Windows 库等，除非你确定编写的程序不需要跨平台使用。由于大部分时候我们的代码将会运行在 Linux 内核的机器上，因此有时候想要用到 Linux 内核相关功能，而 POSIX 标准没有涵盖这个接口的话，将不可避免的使用到 Linux 提供的相关库。</p><p><a href="https://stackoverflow.com/questions/2027991/list-of-standard-header-files-in-c-and-c" target="_blank" rel="noopener">List of standard header files in C and C++</a> 有一份详细的目录可以帮助你了解这些头文件。</p><h3 id="c-standard-library-headers"><a class="markdownIt-Anchor" href="#c-standard-library-headers"></a> C Standard Library Headers</h3><p>C 标准库也称为 ISO C 库，主要经历了 C89, C99, C11 三个大版本，目前包括 <strong>29</strong> 个头文件。详细说明可以在 <a class="btn" href="https://en.cppreference.com/w/c/header" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>C Standard Library header files          </a> 进行查阅。</p><h3 id="isoiec-90452008-posix-2008-single-unix-specification"><a class="markdownIt-Anchor" href="#isoiec-90452008-posix-2008-single-unix-specification"></a> ISO/IEC 9045:2008 (POSIX 2008, Single Unix Specification)</h3><p>C POSIX 库是与标准库同时发展的，它是 POSIX 系统中 C 标准库的规范，作为标准库的超集，其不仅兼容标准库，同时还引入了额外的功能。目前包括 <strong>82</strong> (包含所有 C99 头文件) 个头文件。</p><p>头文件详细说明可以在 <a class="btn" href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>IEEE and The Open Group          </a> 网站中的 <a class="btn" href="http://pubs.opengroup.org/onlinepubs/9699919799/toc.htm" target="_blank" rel="noopener">            <i class="fa fa-book fa-fw fa-lg"></i>IEEE Std POSIX.1-2017          </a> 进行查询。</p><h3 id="gnulinux"><a class="markdownIt-Anchor" href="#gnulinux"></a> GNU/Linux</h3><p>GNU/Linux 是 POSIX 兼容的系统，其使用了 GNU C Library (glibc) 的实现，该实现兼容 C 标准库、POSIX 库等，可以使用 man 手册查阅相关 C 库用法。</p><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3><p>Windows 有自己的头文件，可以在 MSDN 中找到，但也有 POSIX 兼容的版本，例如 Cygwin, MinGW 等。</p><h2 id="系统调用和库函数"><a class="markdownIt-Anchor" href="#系统调用和库函数"></a> 系统调用和库函数</h2><p>所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的 Unix 实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为<strong>系统调用 (system call)</strong>。不同的系统提供了不同的几十、上百个系统调用，具体数字在不同操作系统版本中会不同，</p><p>系统调用接口是用 C 语言定义的，Unix 所使用的技术是为每个系统调用在标准 C 库中设置一个具有同样名字的<strong>包装函数</strong>。用户进程用标准 C 代码来调用这些函数，然后这些函数又用系统所要求的技术调用相应的内核服务。</p><p>程序员可以使用的通用库函数在内部实现时可能会调用一个或多个内核的系统调用，但是它们并不是内核的入口点。同时，库函数当然也可以不使用任何内核的系统调用，这样的库函数仅仅是一些标准库为我们准备的用户层面代码而已。</p><p>从实现者的角度来看，系统调用和库函数之间有根本的区别，但从用户角度来看，其区别并不重要。特别是包装函数的存在，使得系统调用和库函数都以 C 函数的形式出现，两者都为应用程序提供服务。但是，我们应当理解库函数可以被替换，系统调用通常是不能被替换的。</p><p>应用程序既可以调用系统调用也可以调用库函数，而很多库函数则会调用系统调用。</p><p><img src="system-calls-functions.png" alt="system-calls-functions"></p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2020/10/21/os-thread/"/>
      <url>/2020/10/21/os-thread/</url>
      
        <content type="html"><![CDATA[<p>典型的 Unix 进程可以看成只有一个控制线程：一个进程在某一时刻只能做一件事情。有了多个控制线程以后，在程序设计时就可以把进程设计成在某一时刻能够做不止一件事，每个线程处理各自独立的任务。</p><a id="more"></a><h1 id="线程概念"><a class="markdownIt-Anchor" href="#线程概念"></a> 线程概念</h1><p>线程带来了很多好处：</p><ul><li>通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。</li><li>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件描述符。</li><li>有些问题可以分解从而提高整个程序的吞吐量。在只有一个控制线程的情况下，一个单线程进程要完成多个任务，只需要把这些任务串行化。但有多个控制线程时，相互独立的任务的处理就可以交叉进行，此时只需要为每个任务分配一个单独的线程。当然只有在两个任务的处理过程互不依赖的情况下，两个任务才可以交叉执行。</li><li>交互的程序同样可以通过使用多线程来改善响应时间，多线程可以把程序中处理用户输入输出的部分与其他部分分开。</li></ul><div class="note info">            <p>多线程代码与多处理器或多核系统并不是绑定的，尽管多核处理器能够充分发挥多线程的优势。但即使程序运行在单处理器上，也能得到多线程编程模型的好处。所以不管处理器的个数多少，程序都可以通过使用线程得以简化。而且由于某些线程在阻塞的时候还有另外一些线程可以运行，所以多线程程序在单处理器上运行还是可以改善响应时间和吞吐量。</p>          </div><p>每个线程都包含有表示执行环境所必需的信息，其中包括：进程中标识线程的线程 ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno 变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。</p><p>这里主要讨论 POSIX 线程，也成为 pthread 线程，头文件为 <code>&lt;pthread.h&gt;</code>。</p><h1 id="线程标识"><a class="markdownIt-Anchor" href="#线程标识"></a> 线程标识</h1><p>就像每个进程有一个进程 ID 一样，每个线程也有一个线程 ID。进程 ID 在整个系统中是唯一的，但线程 ID 只有在它所属的进程上下文中才有意义。</p><ul><li>进程 ID 使用 pid_t 数据类型来表示</li><li>线程 ID 使用 pthread_t 数据类型来表示</li></ul><p>Linux 上 pthread_t 使用 unsigned long int 实现，有时候打印线程 ID 很有用。而其他 Unix 变种系统却不一定，因此打印 ID 代码移植起来需要特别注意。</p><table><thead><tr><th>函数</th><th>解释</th></tr></thead><tbody><tr><td>pthread_t pthread_self(void);</td><td>获得自身线程 ID</td></tr><tr><td>int pthread_equal(pthread_t tid1, pthread_t tid2);</td><td>线程 ID 比较</td></tr></tbody></table><h1 id="线程创建"><a class="markdownIt-Anchor" href="#线程创建"></a> 线程创建</h1><p>在传统 Unix 进程模型中，每个进程只有一个控制线程。从概念上讲，这与基于线程的模型中每个进程只包含一个线程是相同的。程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。</p><p>新增的线程可以通过调用 pthread_create() 函数创建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * (*start_routine)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>其参数为：</p><ul><li>第一个参数代表该线程的指针</li><li>第二个参数表示该线程的属性</li><li>第三个参数表示该线程执行的任务</li><li>第四个参数表示需要执行任务中传入的参数</li></ul><p>执行成功时返回 0，失败时返回错误码。</p><h1 id="线程管理"><a class="markdownIt-Anchor" href="#线程管理"></a> 线程管理</h1><p>如果进程中的任意线程调用了exit, Exit 或者 _exit，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。</p><p>单个线程可以通过 3 种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。</p><ul><li>线程可以简单地从启动例程中返回，返回值是线程的退出码。</li><li>线程可以被同一进程中的其他线程取消。</li><li>线程调用 pthread_exit() 函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure><p>通过 pthread_exit() 函数终止调用线程，并且如果该线程是 joinable 的话，还可以通过 retval 返回值给同进程的其他线程。注意 retval 指针指向的值不能存在于栈中，因为线程结束后栈会被销毁。</p><p>当进程的所有的线程都终止后，则进程退出。因此 main 线程最后应该调用 pthread_exit() 明确指出退出主线程，如若不然，main 将会隐式的调用 exit，从而退出整个进程，从而导致其他线程被终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_join() 使得调用线程将一直阻塞，直到指定的线程调用 pthread_exit()、从启动线程中返回或者被取消。</p><p>如果对线程的返回值并不感兴趣，那么可以把 retval 指针设置为 NULL。在这种情况下，调用 pthread_join() 函数可以等待指定的线程终止，但并不获取线程的终止状态。</p><figure class="highlight c"><figcaption><span>Pthread Creation and Termination Example</span><a href="/downloads/code/linux/pthread_simple.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">print_hello</span><span class="params">(<span class="keyword">void</span> *threadid)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> taskid;</span><br><span class="line">    taskid = (<span class="keyword">long</span>)threadid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World! It's me, thread (tid:%ld) #%ld!\n"</span>, pthread_self(), taskid);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; NUM_THREADS; t++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In main: creating thread %ld\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, print_hello, (<span class="keyword">void</span> *)t);</span><br><span class="line">        <span class="keyword">if</span> (rc) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() should do */</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>Passing Multiple Arguments</span><a href="/downloads/code/linux/pthread_args.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> {</span></span><br><span class="line">    <span class="keyword">int</span> task_id;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> <span class="title">thread_data_array</span>[<span class="title">NUM_THREADS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">print_hello</span><span class="params">(<span class="keyword">void</span> *threadarg)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> *<span class="title">my_data</span>;</span></span><br><span class="line">    <span class="keyword">long</span> taskid;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    my_data = (struct thread_data *)threadarg;</span><br><span class="line">    taskid = my_data-&gt;task_id;</span><br><span class="line">    name = my_data-&gt;name;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World! It's me, thread #%ld, my name is %s!\n"</span>, taskid, name);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">char</span> *thread_names[NUM_THREADS];</span><br><span class="line">    thread_names[<span class="number">0</span>] = <span class="string">"Alice"</span>;</span><br><span class="line">    thread_names[<span class="number">1</span>] = <span class="string">"Bob"</span>;</span><br><span class="line">    thread_names[<span class="number">2</span>] = <span class="string">"Tom"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; NUM_THREADS; t++) {</span><br><span class="line">        thread_data_array[t].task_id = t;</span><br><span class="line">        thread_data_array[t].name = thread_names[t];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In main: creating thread #%ld\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, print_hello,</span><br><span class="line">                            (<span class="keyword">void</span> *)&amp;thread_data_array[t]);</span><br><span class="line">        <span class="keyword">if</span> (rc) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() should do */</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="api-总结"><a class="markdownIt-Anchor" href="#api-总结"></a> API 总结</h1><table><thead><tr><th>函数</th><th>解释</th></tr></thead><tbody><tr><td>pthread_t pthread_self(void);</td><td>获得自身线程 ID</td></tr><tr><td>int pthread_equal(pthread_t tid1, pthread_t tid2);</td><td>线程 ID 比较</td></tr><tr><td>void pthread_exit(void *retval);</td><td>退出调用线程，并可能传出返回值到其他线程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> C </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2020/09/18/db-mongodb/"/>
      <url>/2020/09/18/db-mongodb/</url>
      
        <content type="html"><![CDATA[<p>MongoDB 是一个具有可伸缩性和灵活性的<strong>文档数据库 (Document Database)</strong>，具体可以查看官网 <a href="https://www.mongodb.com/what-is-mongodb" target="_blank" rel="noopener">What Is MongoDB?</a>。</p><a id="more"></a><h1 id="起步"><a class="markdownIt-Anchor" href="#起步"></a> 起步</h1><p>各种平台的安装、运行方式请参考 <a href="https://docs.mongodb.com/manual/installation/" target="_blank" rel="noopener">Install MongoDB</a></p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>以下仅以在 Ubuntu 平台上安装 MongoDB 社区版为例</p><ol><li>导入包管理系统使用的公钥</li><li>创建 apt 源的 list 文件（国内源过慢可以替换阿里源 <code>http://mirrors.aliyun.com/mongodb/apt/ubuntu</code>）</li><li>更新本地 apt 数据库</li><li>安装</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/4.4 multiverse"</span> | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list</span><br><span class="line">sudo apt-get install -y mongodb-org</span><br></pre></td></tr></table></figure><h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2><p>按照以下步骤在系统上运行 MongoDB 社区版：</p><ol><li>查看系统 init 管理类型（大部分 Linux 如今采用 systemd 管理服务）</li><li>启动 mongodb 服务（如果启动失败请查看官方文档）</li><li>查看 mongodb 服务状态</li><li>（可选，推荐）设为开机启动项</li><li>（其他）停止 mongodb 服务</li><li>（其他）重启 mongodb 服务</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o comm 1   <span class="comment"># 假设为 systemd</span></span><br><span class="line">sudo systemctl start mongod</span><br><span class="line">sudo systemctl status mongod</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mongod</span><br><span class="line">sudo systemctl stop mongod</span><br><span class="line">sudo systemctl restart mongod</span><br></pre></td></tr></table></figure><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>mongodb 的配置文件为 <code>/etc/mongodb.conf</code>。</p><p>允许所有 IPv4 以及 IPv6 地址访问：</p><ul><li>可直接设置 <code>bindIpAll: true</code></li><li>也可以设置 <code>bindIp: 0.0.0.0,::</code></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net:</span><br><span class="line">  port: <span class="number">27017</span></span><br><span class="line">  bindIp: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>,::</span><br></pre></td></tr></table></figure><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><table><thead><tr><th>SQL 术语/概念</th><th>MongoDB 术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接，MongoDB 不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB 自动将 <code>_id</code> 字段设置为主键</td></tr></tbody></table><p>下图表示了传统 SQL 数据库表和 Mongo 数据库集合的表达形式对应关系：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/10/Figure-1-Mapping-Table-to-Collection-1.png" alt></p><h1 id="编程接口"><a class="markdownIt-Anchor" href="#编程接口"></a> 编程接口</h1><p>MongoDB 官方支持多种编程语言的 <a class="btn" href="https://docs.mongodb.com/drivers/" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>驱动库          </a>，可以方便开发人员将应用程序连接到数据库。</p><h2 id="java-driver"><a class="markdownIt-Anchor" href="#java-driver"></a> Java Driver</h2><ul><li><a href="https://mongodb.github.io/mongo-java-driver/3.12/driver/" target="_blank" rel="noopener">MongoDB Driver 3.12 Documentation</a><ul><li><a href="https://mongodb.github.io/mongo-java-driver/3.12/driver/tutorials/" target="_blank" rel="noopener">教程</a></li><li><a href="https://mongodb.github.io/mongo-java-driver/3.12/driver/tutorials/indexes/" target="_blank" rel="noopener">设置索引</a></li></ul></li></ul><table><thead><tr><th>API</th><th>Descrption</th></tr></thead><tbody><tr><td>MongoDatabase database = mongoClient.getDatabase(“mydb”);</td><td>Access a Database</td></tr><tr><td>MongoCollection<document> collection = database.getCollection(“test”);</document></td><td>Access a Collection</td></tr><tr><td>collection.insertOne(doc);</td><td>Insert a Document</td></tr></tbody></table><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://www.jianshu.com/p/647ddfd1f5d7" target="_blank" rel="noopener">mongodb 主从配置及备份</a></li><li><a href="https://www.jianshu.com/p/aec4899df434" target="_blank" rel="noopener">MongoDB 集群搭建 —— 主从模式</a></li><li><a href="https://blog.csdn.net/pelick/article/details/8644116" target="_blank" rel="noopener">https://blog.csdn.net/pelick/article/details/8644116</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ONOS</title>
      <link href="/2020/09/17/sdn-onos/"/>
      <url>/2020/09/17/sdn-onos/</url>
      
        <content type="html"><![CDATA[<p>开放网络操作系统（Open Network Operating System, ONOS）是领先的开源 SDN 控制器，用于构建下一代 SDN/NFV 解决方案。</p><a id="more"></a><h1 id="管理员-vs-开发者"><a class="markdownIt-Anchor" href="#管理员-vs-开发者"></a> 管理员 vs 开发者</h1><p>首先需要明确的一点是：需要 ONOS 做什么？我们是作为管理员还是开发者？</p><h2 id="管理员"><a class="markdownIt-Anchor" href="#管理员"></a> 管理员</h2><p>如果只是需要部署和管理 ONOS 实例，作为网络控制器使用，请参阅 <a href="https://wiki.onosproject.org/display/ONOS/Administrator+Guide" target="_blank" rel="noopener">Administrator Guide</a>。</p><p>如果是完全的 SDN 初学者，可以先走一遍管理员手册，了解如何</p><ul><li>安装运行 ONOS</li><li>配置 ONOS</li><li>与 ONOS 交互</li></ul><h2 id="开发者"><a class="markdownIt-Anchor" href="#开发者"></a> 开发者</h2><p>如果需要基于 ONOS 平台开发（包括核心框架和应用程序），请参阅 <a href="https://wiki.onosproject.org/display/ONOS/Developer+Guide" target="_blank" rel="noopener">Developer Guide</a>。</p><p>鉴于大部分情况下我们需要进行应用开发，因此本文以开发者的角色来熟悉 ONOS。</p><p>以下步骤是在一台开发计算机上构建并运行 ONOS，详细步骤参阅 <a href="https://wiki.onosproject.org/display/ONOS/Development+Environment+Setup" target="_blank" rel="noopener">Development Environment Setup</a>。</p><h3 id="安装依赖"><a class="markdownIt-Anchor" href="#安装依赖"></a> 安装依赖</h3><p>首先，确保如下依赖已经存在。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span></span><br><span class="line"><span class="symbol">zip</span></span><br><span class="line"><span class="symbol">curl</span></span><br><span class="line"><span class="symbol">unzip</span></span><br><span class="line"><span class="symbol">python</span> # <span class="number">2</span>.<span class="number">7</span> required <span class="keyword">by </span>some development scripts</span><br><span class="line"><span class="symbol">python3</span> # Required <span class="keyword">by </span><span class="keyword">Bazel</span></span><br><span class="line"><span class="keyword">bzip2 </span># Needed <span class="keyword">by </span>legacy GUI <span class="keyword">build</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>运行 ONOS 需要安装 JDK 吗？最简洁的答案是<strong>不</strong>！</p><p>从 ONOS 2.2开始，使用 Bazel 时，我们不再需要在系统中安装 JDK 来构建和运行 ONOS，因为我们使用了 Bazel 随附的 OpenJDK 11 版本。</p><p>但是，如果要运行某些开发工具（例如 onos-lib-gen 等），或者要在不使用 Bazel 的情况下运行 ONOS，则可能仍需要安装 Java Runtime Environment（JRE）或 JDK。</p>          </div><p>ONOS 是一个大型项目，由多个相对独立的模块组成，这些模块可以并行构建，因此速度更快。因此该项目选择通过 Bazel 进行构建，而不是之前使用的 Maven 和 Buck。</p><p>Bazelisk 是管理多个版本 Bazel 的工具。不同版本的 ONOS 已在不同版本的 Bazel 上验证，<code>.bazelversion</code> 文件中定义了 ONOS 使用的版本。用户应下载并安装 Bazelisk 以替代 bazel 命令。建议不要自己直接下载 Bazel，而是让 Bazelisk 为您获取正确的版本！</p><p>Linux 可以使用如下命令安装 Bazelisk。</p><figure class="highlight shell"><figcaption><span>Linux 安装 Bazelisk</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://github.com/bazelbuild/bazelisk/releases/download/v1.4.0/bazelisk-linux-amd64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x bazelisk-linux-amd64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mv bazelisk-linux-amd64 /usr/<span class="built_in">local</span>/bin/bazel</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/onos</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bazel version</span></span><br></pre></td></tr></table></figure><h3 id="运行-onos-控制器"><a class="markdownIt-Anchor" href="#运行-onos-控制器"></a> 运行 ONOS 控制器</h3><p>ONOS 源码托管于 <a href="http://gerrit.onosproject.org" target="_blank" rel="noopener">gerrit.onosproject.org</a>，而不是 github。如果只需要下载源码和运行，那么只需使用 git 即可，如果需要贡献源码等，则需要配置 Gerrit。</p><figure class="highlight crmsh"><figcaption><span>下载源码并构建 ONOS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://gerrit.onosproject.org/onos</span><br><span class="line">cd onos</span><br><span class="line">bazel build onos</span><br></pre></td></tr></table></figure><p>要在开发机器上本地运行 ONOS，只需运行以下命令：</p><figure class="highlight applescript"><figcaption><span>运行 ONOS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel <span class="built_in">run</span> onos-<span class="keyword">local</span> <span class="comment">-- clean debug</span></span><br></pre></td></tr></table></figure><ul><li>‘clean’ to delete all previous running status</li><li>‘debug’ to enable remote debugging</li></ul><p>要进入 ONOS CLI 控制台，运行：</p><figure class="highlight armasm"><figcaption><span>登录 ONOS 命令行</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tools</span>/test/<span class="keyword">bin/onos </span>localhost</span><br></pre></td></tr></table></figure><p>连接后，就可以运行各种 ONOS CLI 和 Apache Karaf 命令。例如，要启动 OpenFlow 和 ReactiveForwarding 应用程序，可以执行以下操作：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onos&gt; app activate org<span class="selector-class">.onosproject</span><span class="selector-class">.openflow</span></span><br><span class="line">onos&gt; app activate org<span class="selector-class">.onosproject</span><span class="selector-class">.fwd</span></span><br></pre></td></tr></table></figure><h3 id="连接-mininet-网络"><a class="markdownIt-Anchor" href="#连接-mininet-网络"></a> 连接 Mininet 网络</h3><figure class="highlight angelscript"><figcaption><span>运行 Mininet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --controller remote,ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6653</span> --topo torus,<span class="number">3</span>,<span class="number">3</span> --<span class="keyword">switch</span> ovsk,protocols=OpenFlow13 --mac</span><br></pre></td></tr></table></figure><p>注意 Mininet 使用的默认</p><h3 id="设置开发环境"><a class="markdownIt-Anchor" href="#设置开发环境"></a> 设置开发环境</h3><p>通过设置开发环境，可以更方便的进行 ONOS 开发，例如使用 <code>onos</code> 来代替 <code>tools/test/bin/onos</code> 命令，只需在 <code>~/.bash_profile</code>  或 <code>~/.bash_aliases</code> 中放入以下两行。</p><figure class="highlight bash"><figcaption><span>自定义 Bash 环境</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ONOS_ROOT=~/onos     <span class="comment"># it depends on your installation directory of onos</span></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ONOS_ROOT</span>/tools/dev/bash_profile</span><br></pre></td></tr></table></figure><h3 id="设置代理"><a class="markdownIt-Anchor" href="#设置代理"></a> 设置代理</h3><p>在国内网络情况不好，可以使用如下代理来构建。</p><figure class="highlight routeros"><figcaption><span>使用 Web Proxy 构建 ONOS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">HTTPS_PROXY</span>=https://&lt;proxy address&gt;:&lt;proxy port&gt;</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HTTP_PROXY</span>=http://&lt;proxy address&gt;:&lt;proxy port&gt;</span><br><span class="line"></span><br><span class="line">bazel build onos <span class="attribute">--action_env</span>=HTTP_PROXY=$HTTP_PROXY</span><br></pre></td></tr></table></figure><p>例如笔者的配置方式如下，请注意挂代理会导致非代理构建的包缓存不可用，因此会重新构建依赖包。</p><figure class="highlight routeros"><figcaption><span>使用 SOCKS5 代理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">HTTP_PROXY</span>=socks5://127.0.0.1:10808</span><br></pre></td></tr></table></figure><p>编译失败是在国内经常遇到的问题，主要原因是由于 GFW 的原因，很多网站访问不稳定或者很慢，必要的情况需要挂代理才能构建，除此之外可以尝试单独构建失败的包。假设 <code>//web/gui:_onos-gui-npm-install</code> 包导致构建失败，则可以单独构建，如果构建成功，将会存在缓存中，则再次进行 ONOS 构建便可成功。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build /<span class="regexp">/web/gui</span><span class="symbol">:_onos-gui-npm-install</span> --verbose_failures --sandbox_debug</span><br></pre></td></tr></table></figure><h3 id="其他步骤"><a class="markdownIt-Anchor" href="#其他步骤"></a> 其他步骤</h3><p>在官方文档中还包括以下有用的章节，但不是必需的核心部分，不再赘述。</p><ul><li>Building ONOS and executing unit tests</li><li>Building API docs</li><li>Development Workflow Options</li><li>Using an IDE with ONOS 1.14 or higher (Bazel build)</li></ul><h1 id="onos-交互方式"><a class="markdownIt-Anchor" href="#onos-交互方式"></a> ONOS 交互方式</h1><p>管理员可以通过几种方式与 ONOS 进行交互：</p><ul><li>CLI：类似于 UNIX shell，这是运行中的 ONOS 实例的主要管理界面。</li><li>GUI：ONOS 网络视图的可视化。</li><li>REST API：CLI 所用管理接口的 RESTful 接口。</li></ul><h2 id="cli-终端"><a class="markdownIt-Anchor" href="#cli-终端"></a> CLI 终端</h2><p>ONOS CLI 是 Karaf CLI 的拓展，因此可以利用 Karaf的 一些特性，例如程序可扩展性、动态加载卸载包（APP）以及 SSH 访问。</p><h3 id="进入-cli-终端"><a class="markdownIt-Anchor" href="#进入-cli-终端"></a> 进入 CLI 终端</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ onos <span class="string">[ip-addr]</span></span><br></pre></td></tr></table></figure><ul><li>如果位于目标机器，onos 命令可以直接连接本地计算机的 ONOS 实例。</li><li>如果位于部署管理机器，onos 命令支持连接到远程目标计算机的 ONOS 实例。</li></ul><div class="note info">            <p>onos 命令可能根据不同的部署、安装方式存储在不同的位置，如果按照官方手册，则：</p><ul><li>管理者：<code>/opt/onos/bin/onos</code></li><li>开发者：<code>${ONOS_HOME}/tools/test/bin/onos</code></li></ul>          </div><p>使用 CTRL+D 或者 logout 可以退出 CLI。</p><h3 id="onos-命令"><a class="markdownIt-Anchor" href="#onos-命令"></a> ONOS 命令</h3><p>ONOS 提供了一组自己的命令，<code>help onos</code> 列出了可用的命令。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onos&gt; <span class="keyword">help</span> onos</span><br><span class="line">COMMANDS</span><br><span class="line"><span class="string">....</span></span><br></pre></td></tr></table></figure><p>具体命令可以查看 <a href="https://wiki.onosproject.org/display/ONOS/Appendix+A+%3A+CLI+commands" target="_blank" rel="noopener">Appendix A : CLI commands</a>。</p><h3 id="模块管理"><a class="markdownIt-Anchor" href="#模块管理"></a> 模块管理</h3><p>Karaf 的 CLI 命令对于管理组成正在运行的 ONOS 实例的模块很有用。例如，list 可用于显示所有已加载的模块：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onos&gt; <span class="built_in">list</span></span><br><span class="line">START LEVEL <span class="number">100</span> , <span class="built_in">List</span> Threshold: <span class="number">50</span></span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure><p>以下是一些常用的模块配置管理命令：</p><figure class="highlight stylus"><figcaption><span>查看 OpenFlow 配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfg get org<span class="selector-class">.onosproject</span><span class="selector-class">.openflow</span><span class="selector-class">.controller</span><span class="selector-class">.impl</span><span class="selector-class">.OpenFlowControllerImpl</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><figcaption><span>设置 OpenFlow 端口为 6653</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfg set org<span class="selector-class">.onosproject</span><span class="selector-class">.openflow</span><span class="selector-class">.controller</span><span class="selector-class">.impl</span><span class="selector-class">.OpenFlowControllerImpl</span> openflowPorts <span class="number">6653</span></span><br></pre></td></tr></table></figure><h2 id="gui-图形界面"><a class="markdownIt-Anchor" href="#gui-图形界面"></a> GUI 图形界面</h2><p>ONOS 的 GUI 可以从任何浏览器通过目标计算机的 IP 地址进行访问。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>localhost:<span class="number">8181</span><span class="regexp">/onos/ui</span><span class="regexp">/index.html</span></span><br></pre></td></tr></table></figure><p>默认的用户名和密码为 onos/rocks。</p><p>快捷键</p><h2 id="rest-api"><a class="markdownIt-Anchor" href="#rest-api"></a> REST API</h2><h1 id="onos-应用开发"><a class="markdownIt-Anchor" href="#onos-应用开发"></a> ONOS 应用开发</h1><p>本节提供 ONOS API 的概述，并描述如何编译，运行和修改 ONOS 示例应用程序。</p><h2 id="onos-api-简介"><a class="markdownIt-Anchor" href="#onos-api-简介"></a> ONOS API 简介</h2><p>ONOS 主要有如下的 API 供开发者使用。</p><ul><li>ONOS Java API 是 ONOS 系统的主要 API，已记录为标准 javadoc 文档，可从 <a href="http://api.onosproject.org" target="_blank" rel="noopener">api.onosproject.org</a> 获得。</li><li>REST API 主要是为 Web 应用程序和脚本语言与 ONOS 系统进行交互提供一种简单但缓慢的方式。不建议将其用于路由或高性能网络应用程序，但对诸如系统管理之类的任务很有用。</li><li>ONOS Web GUI也是可编程和可扩展的，并且在客户端（JavaScript）和服务器（Java）端均提供了自己的框架</li></ul><h2 id="构建示例应用"><a class="markdownIt-Anchor" href="#构建示例应用"></a> 构建示例应用</h2><p>开发 ONOS 应用程序的一种开始方法是尝试修改现有的 ONOS 示例应用程序。通过尝试对现有功能进行更改，这是使您专心致志的好方法，并且可能比从头开始创建全新的应用程序容易。</p><h3 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h3><p>ONOS 应用可以使用官方提供的 onos-app-samples 来修改，该工程使用 mvn 构建。由于 ONOS 本身使用 bazel 构建，因此官方后期可能会将 APP 构建和 ONOS 构建合并到一个构建系统中。</p><p>在构建 ONOS 应用程序之前，应确保已安装 Java，git 和 Maven。</p><h3 id="获取源码"><a class="markdownIt-Anchor" href="#获取源码"></a> 获取源码</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://gerrit.onosproject.org/onos-app-samples</span><br><span class="line">cd onos-app-samples</span><br></pre></td></tr></table></figure><p>默认该应用基于 master 版本，如果需要针对特定版本的 ONOS，可以在 pom 文件中指定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.onosproject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>onos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基本编译"><a class="markdownIt-Anchor" href="#基本编译"></a> 基本编译</h3><p>进入工作目录，直接使用 mvn 编译。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mvn </span>compile</span><br></pre></td></tr></table></figure><p>编译完成后构建 <code>.oar</code> 文件</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mvn </span>install</span><br></pre></td></tr></table></figure><div class="note info">            <p>mvn install 实际上不会将软件包安装到 ONOS 中！相反，您需要按照适当的说明将应用安装并激活到自己的 ONOS 系统中。</p>          </div><h2 id="应用模板"><a class="markdownIt-Anchor" href="#应用模板"></a> 应用模板</h2><p>除了修改 ONOS 的 APP Demo，还可以使用 <code>onos-create-app</code> 工具来构建更加自定义的项目，使得应用的代码和功能更加精简。</p><p><code>onos-create-app</code> 本质是一个 Maven 的 archetypes，该工具生成了一个基本的 ONOS 应用模板，包括与 CLI REST API，以及 GUI 的交互。</p><h1 id="安装和部署"><a class="markdownIt-Anchor" href="#安装和部署"></a> 安装和部署</h1><ul><li><a href="https://github.com/opennetworkinglab/onos" target="_blank" rel="noopener">Github</a></li><li><a href="https://hub.docker.com/r/onosproject/onos/" target="_blank" rel="noopener">docker - onosproject/onos</a></li><li><a href="https://wiki.onosproject.org/" target="_blank" rel="noopener">ONOS Wiki</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
            <tag> ONOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenVirtex</title>
      <link href="/2020/09/16/sdn-ovx/"/>
      <url>/2020/09/16/sdn-ovx/</url>
      
        <content type="html"><![CDATA[<p>作为一个网络虚拟机监视器，<a class="btn" href="https://openvirtex.com/" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>OpenVirtex/Libera          </a> 用来在物理网络之上创建多个虚拟的可编程网络。每个租户 (tenant) 可以使用<strong>完整的地址空间</strong>，搭建自己的<strong>拓扑</strong>，部署自己的<strong>网络 OS (控制器)</strong>。OVX 是一个处于控制层和物理链路层的虚拟化层，对于控制器来说，OVX 为其提供底层网络拓扑；对于底层物理网络，OVX 扮演了控制器的功能。</p><a id="more"></a><h1 id="虚网数据库"><a class="markdownIt-Anchor" href="#虚网数据库"></a> 虚网数据库</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_id"</span>:<span class="string">"ObjectId("</span><span class="string">"5f6071753966af4442734171"</span><span class="string">")"</span>,</span><br><span class="line">   <span class="attr">"controllerUrls"</span>:[</span><br><span class="line">      <span class="string">"tcp:localhost:6653"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"tenantId"</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="attr">"networkAddress"</span>:<span class="number">167772160</span>,</span><br><span class="line">   <span class="attr">"mask"</span>:<span class="number">8</span>,</span><br><span class="line">   <span class="attr">"switches"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"vdpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"dpids"</span>:[</span><br><span class="line">            NumberLong(<span class="number">1</span>)</span><br><span class="line">         ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"vdpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"dpids"</span>:[</span><br><span class="line">            NumberLong(<span class="number">2</span>)</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"ports"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"dpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"vport"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"port"</span>:<span class="number">3</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"dpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"vport"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"port"</span>:<span class="number">3</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"dpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"vport"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"port"</span>:<span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"dpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"vport"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"port"</span>:<span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"dpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"vport"</span>:<span class="number">3</span>,</span><br><span class="line">         <span class="attr">"port"</span>:<span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"dpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"vport"</span>:<span class="number">3</span>,</span><br><span class="line">         <span class="attr">"port"</span>:<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"hosts"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"vdpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"vport"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"hostId"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"mac"</span>:NumberLong(<span class="number">257</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"vdpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"vport"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"hostId"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"mac"</span>:NumberLong(<span class="number">2</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"links"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"backup_num"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"path"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"srcDpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">               <span class="attr">"dstDpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">               <span class="attr">"dstPort"</span>:<span class="number">2</span>,</span><br><span class="line">               <span class="attr">"srcPort"</span>:<span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">         ],</span><br><span class="line">         <span class="attr">"srcDpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"dstDpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"dstPort"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"linkId"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"srcPort"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"priority"</span>:<span class="number">64</span>,</span><br><span class="line">         <span class="attr">"algorithm"</span>:<span class="string">"spf"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"backup_num"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"path"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"srcDpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">               <span class="attr">"dstDpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">               <span class="attr">"dstPort"</span>:<span class="number">2</span>,</span><br><span class="line">               <span class="attr">"srcPort"</span>:<span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">         ],</span><br><span class="line">         <span class="attr">"srcDpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"dstDpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"dstPort"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"linkId"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"srcPort"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"priority"</span>:<span class="number">64</span>,</span><br><span class="line">         <span class="attr">"algorithm"</span>:<span class="string">"spf"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"backup_num"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"path"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"srcDpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">               <span class="attr">"dstDpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">               <span class="attr">"dstPort"</span>:<span class="number">1</span>,</span><br><span class="line">               <span class="attr">"srcPort"</span>:<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">         ],</span><br><span class="line">         <span class="attr">"srcDpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"dstDpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"dstPort"</span>:<span class="number">3</span>,</span><br><span class="line">         <span class="attr">"linkId"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"srcPort"</span>:<span class="number">3</span>,</span><br><span class="line">         <span class="attr">"priority"</span>:<span class="number">64</span>,</span><br><span class="line">         <span class="attr">"algorithm"</span>:<span class="string">"spf"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"backup_num"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"path"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"srcDpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">               <span class="attr">"dstDpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">               <span class="attr">"dstPort"</span>:<span class="number">1</span>,</span><br><span class="line">               <span class="attr">"srcPort"</span>:<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">         ],</span><br><span class="line">         <span class="attr">"srcDpid"</span>:NumberLong(<span class="number">2</span>),</span><br><span class="line">         <span class="attr">"dstDpid"</span>:NumberLong(<span class="number">1</span>),</span><br><span class="line">         <span class="attr">"dstPort"</span>:<span class="number">3</span>,</span><br><span class="line">         <span class="attr">"linkId"</span>:<span class="number">2</span>,</span><br><span class="line">         <span class="attr">"srcPort"</span>:<span class="number">3</span>,</span><br><span class="line">         <span class="attr">"priority"</span>:<span class="number">64</span>,</span><br><span class="line">         <span class="attr">"algorithm"</span>:<span class="string">"spf"</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pipeline-handler"><a class="markdownIt-Anchor" href="#pipeline-handler"></a> Pipeline &amp; Handler</h1><ul><li><p>OpenflowChannelPipeline</p><ul><li>ClientChannelPipeline</li></ul></li><li><p>IdleStateAwareChannelHandler</p><ul><li>OFChannelHandler<ul><li>ControllerChannelHandler</li></ul></li></ul></li><li><p>SimpleChannelUpstreamHandler</p><ul><li>HandshakeTimeoutHandler</li></ul></li></ul><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><h2 id="实验一"><a class="markdownIt-Anchor" href="#实验一"></a> 实验一</h2><h3 id="拓扑"><a class="markdownIt-Anchor" href="#拓扑"></a> 拓扑</h3><h3 id="物理拓扑"><a class="markdownIt-Anchor" href="#物理拓扑"></a> 物理拓扑</h3><figure class="highlight json"><figcaption><span>getPhysicalTopology</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"switches"</span>: [</span><br><span class="line">        <span class="string">"00:00:00:00:00:00:00:01"</span>,</span><br><span class="line">        <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"links"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"linkId"</span>: <span class="number">24</span>,</span><br><span class="line">            <span class="attr">"dst"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"src"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"linkId"</span>: <span class="number">25</span>,</span><br><span class="line">            <span class="attr">"dst"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"2"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"src"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"2"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"linkId"</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="attr">"dst"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"2"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"src"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"2"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"linkId"</span>: <span class="number">22</span>,</span><br><span class="line">            <span class="attr">"dst"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"src"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="物理主机"><a class="markdownIt-Anchor" href="#物理主机"></a> 物理主机</h3><figure class="highlight json"><figcaption><span>getPhysicalHosts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"mac"</span>: <span class="string">"00:00:00:00:00:01"</span>,</span><br><span class="line">        <span class="attr">"hostId"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"ipAddress"</span>: <span class="string">"1.0.0.1"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"mac"</span>: <span class="string">"00:00:00:00:00:02"</span>,</span><br><span class="line">        <span class="attr">"hostId"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"ipAddress"</span>: <span class="string">"1.0.0.2"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="虚拟拓扑"><a class="markdownIt-Anchor" href="#虚拟拓扑"></a> 虚拟拓扑</h3><figure class="highlight json"><figcaption><span>getVirtualTopology</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"switches"</span>: [</span><br><span class="line">        <span class="string">"00:00:00:00:00:00:00:02"</span>,</span><br><span class="line">        <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"links"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"linkId"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"dst"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"3"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"src"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"3"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tenantId"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"linkId"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"dst"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"3"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"src"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"3"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tenantId"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"linkId"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"dst"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"2"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"src"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"2"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tenantId"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"linkId"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"dst"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"2"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"src"</span>: &#123;</span><br><span class="line">                <span class="attr">"port"</span>: <span class="string">"2"</span>,</span><br><span class="line">                <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"tenantId"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟主机"><a class="markdownIt-Anchor" href="#虚拟主机"></a> 虚拟主机</h3><figure class="highlight json"><figcaption><span>getVirtualHosts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"mac"</span>: <span class="string">"00:00:00:00:00:01"</span>,</span><br><span class="line">        <span class="attr">"hostId"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"ipAddress"</span>: <span class="string">"10.0.0.1"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:01"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"mac"</span>: <span class="string">"00:00:00:00:00:02"</span>,</span><br><span class="line">        <span class="attr">"hostId"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"ipAddress"</span>: <span class="string">"10.0.0.2"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"dpid"</span>: <span class="string">"00:00:00:00:00:00:00:02"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="删除一个虚拟主机"><a class="markdownIt-Anchor" href="#删除一个虚拟主机"></a> 删除一个虚拟主机</h3>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
            <tag> OpenVirteX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存 (Cache)</title>
      <link href="/2020/09/15/os-cache/"/>
      <url>/2020/09/15/os-cache/</url>
      
        <content type="html"><![CDATA[<p>缓存 (Cache) 是一个硬件或软件的组件，用来存储将来可能用到的数据，从而能让数据获取更快。如今缓存的概念已被扩充，不仅在 CPU 和主内存之间有多级 SRAM 缓存，而且在内存和硬盘之间也有磁盘缓存，乃至在硬盘与网络之间也有某种意义上的缓存。</p><p>凡是位于速度相差较大的两种硬件/软件之间，用于协调两者数据传输速度差异的结构，均可称之为缓存。</p><a id="more"></a><h1 id="缓存思想"><a class="markdownIt-Anchor" href="#缓存思想"></a> 缓存思想</h1><p>缓存的思想古以有之，并且在生活中我们有意无意的也会利用缓存的思想，在工业计算机领域，缓存率先出现在硬件电路上，通过使用 SRAM 缓存协调 CPU 和主内存之间的数据传输，并且随着时间的增加，出现了缓存的缓存，也就是多级缓存。如今的 CPU 将三级缓存全部集成到 CPU 芯片上，多核 CPU 通常为每个核配有独享的一级和二级缓存，以及各核之间共享的三级缓存。</p><p>不同的存储技术有着不同的价格和性能的折中。不同存储器访问时间差异很大，速度较快的技术每字节的成本要比速度较慢的技术高，而且容量小。由此形成了金字塔存储器层次结构：</p><p><img src="cpu-cache.png" alt="cpu-cache"></p><p>一般而言，高速缓存是一个小而快的存储设备，它作为存储在更大也更慢的设备中的数据对象的缓冲区域。</p><h1 id="缓存特性"><a class="markdownIt-Anchor" href="#缓存特性"></a> 缓存特性</h1><p>缓存也是一个数据模型对象，那么必然有它的一些特征：</p><h2 id="命中率"><a class="markdownIt-Anchor" href="#命中率"></a> 命中率</h2><p>当某个请求能够通过访问缓存而得到响应时，称为<strong>缓存命中</strong>。缓存命中率越高，缓存的利用率也就越高。</p><h2 id="最大空间"><a class="markdownIt-Anchor" href="#最大空间"></a> 最大空间</h2><p>缓存中可以存放的最大元素的数量，一旦缓存中元素数量超过这个值（或者缓存数据所占空间超过其最大支持空间），那么将会触发缓存启动清空策略。</p><p>很明显，如果缓存最大空间太小，则命中率必然不高，反之，则耗费资源越多并且可能造成查找的效率降低。因此，根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的利用缓存。</p><h2 id="淘汰策略"><a class="markdownIt-Anchor" href="#淘汰策略"></a> 淘汰策略</h2><p>既然缓存的最大空间有限制，则必然会出现缓存空间被用满的情况，假设不进行任何更新替换，则只有缓存中的数据可以命中，这显然会造成极低的缓存命中率，如果更新替换数据，那么将哪些数据剔除出去就由缓存清空策略来决定。</p><p>设计适合自身数据特征的清空策略能有效提升命中率。常见的一般策略有：</p><ul><li><strong>先进先出策略 (First In First Out, FIFO)</strong>：，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最旧的数据）被淘汰。</li><li><strong>最近最久未使用策略 (Least Recently Used, LRU)</strong>：，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li><li><strong>最不经常使用策略 (Least Frequently Used, LFU)</strong>：，优先淘汰一段时间内使用次数最少的数据。</li></ul><h3 id="lru"><a class="markdownIt-Anchor" href="#lru"></a> LRU</h3><p>以下是基于双向链表 + HashMap 的 LRU 算法实现：</p><ul><li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li><li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li></ul><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LeetCode - LRU 缓存机制</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;(maxSize * <span class="number">4</span> / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        unlink(node);</span><br><span class="line">        appendHead(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            unlink(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        map.put(key, node);</span><br><span class="line">        appendHead(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.size() &gt; maxSize) &#123;</span><br><span class="line">            Node toRemove = removeTail();</span><br><span class="line">            map.remove(toRemove.k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlink</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        Node next = node.next;</span><br><span class="line"></span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line"></span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node next = head.next;</span><br><span class="line">        node.next = next;</span><br><span class="line">        next.pre = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = tail.pre;</span><br><span class="line"></span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        tail.pre = pre;</span><br><span class="line">        pre.next = tail;</span><br><span class="line"></span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Node cur = head.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur != tail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Node node = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">return</span> node.k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缓存种类"><a class="markdownIt-Anchor" href="#缓存种类"></a> 缓存种类</h1><p>对于程序员来说，从硬件介质上来看，缓存无非就是内存和硬盘两种，但从技术上，可以分成内存、硬盘文件、数据库。</p><ul><li>内存：将缓存存储于内存中是最快的选择，无需额外的 I/O 开销，但是内存的缺点是没有持久化落地物理磁盘，一旦应用异常而重新启动，数据很难或者无法复原。</li><li>硬盘：一般来说，很多缓存框架会结合使用内存和硬盘，在内存分配空间满了或是在异常的情况下，可以被动或主动的将内存空间数据持久化到硬盘中，达到释放空间或备份数据的目的。</li><li>数据库：前面有提到，增加缓存的策略的目的之一就是为了减少数据库的 I/O 压力。现在使用数据库做缓存介质是不是又回到了老问题上了？其实，数据库也有很多种类型，像那些不支持 SQL，只是简单的 key-value 存储结构的特殊数据库（如 Redis），响应速度和吞吐量都远远高于我们常用的关系型数据库等。</li></ul><p>因此，在程序员的世界，实际上缓存可以存在于许多位置，例如：</p><ul><li>浏览器：当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</li><li>ISP：网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</li><li>反向代理：反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</li><li>编程语言：以 Java 为例，Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</li><li>数据库缓存：MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</li></ul><p>通常，根据缓存与应用的耦合度，可以将缓存分为：</p><ul><li>本地缓存</li><li>分布式缓存</li></ul><h2 id="本地缓存"><a class="markdownIt-Anchor" href="#本地缓存"></a> 本地缓存</h2><p><strong>本地缓存指的是在应用中的缓存组件</strong>，其最大的优点是应用和缓存是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。</p><p>例如，Java 中可以使用 Guava Cache 组件将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h3 id="直接实现"><a class="markdownIt-Anchor" href="#直接实现"></a> 直接实现</h3><p>TODO</p><h3 id="ehcache"><a class="markdownIt-Anchor" href="#ehcache"></a> Ehcache</h3><p>Ehcache 是现在最流行的纯 Java 开源缓存框架，配置简单、结构清晰、功能强大，是一个非常轻量级的缓存实现。</p><h3 id="guava-cache"><a class="markdownIt-Anchor" href="#guava-cache"></a> Guava Cache</h3><p>Guava Cache 是 Google 开源的 Java 重用工具集库 Guava 里的一款缓存工具。</p><h2 id="分布式缓存"><a class="markdownIt-Anchor" href="#分布式缓存"></a> 分布式缓存</h2><p><strong>分布式缓存指的是与应用分离的缓存组件或服务</strong>，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存。</p><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h3 id="memcached-缓存"><a class="markdownIt-Anchor" href="#memcached-缓存"></a> Memcached 缓存</h3><h3 id="redis-缓存"><a class="markdownIt-Anchor" href="#redis-缓存"></a> Redis 缓存</h3><p>Redis 是一个远程内存数据库（非关系型数据库），性能强劲，具有复制特性以及解决问题而生的独一无二的数据模型。它可以存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。</p><p>CPU 多级缓存<br>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p><h1 id="缓存问题"><a class="markdownIt-Anchor" href="#缓存问题"></a> 缓存问题</h1><h2 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h2><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p>解决方案：</p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h2 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h2><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p>解决方案：</p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h2 id="缓存一致性"><a class="markdownIt-Anchor" href="#缓存一致性"></a> 缓存一致性</h2><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>解决方案：</p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h1 id="数据分布"><a class="markdownIt-Anchor" href="#数据分布"></a> 数据分布</h1><h2 id="哈希分布"><a class="markdownIt-Anchor" href="#哈希分布"></a> 哈希分布</h2><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：<code>hash(key)%N</code>。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p><div class="note info">            <p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p>          </div><h2 id="顺序分布"><a class="markdownIt-Anchor" href="#顺序分布"></a> 顺序分布</h2><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://tech.meituan.com/2017/03/17/cache-about.html" target="_blank" rel="noopener">缓存那些事</a></li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 流量控制 (Traffic Control)</title>
      <link href="/2020/09/10/linux-tc/"/>
      <url>/2020/09/10/linux-tc/</url>
      
        <content type="html"><![CDATA[<p>流量控制 (Traffic Control, TC) 是 Linux 内核提供的流量限速、整形和策略控制机制。它以 qdisc-class-filter 的树形结构来实现对流量的分层控制：</p><a id="more"></a><h1 id="流量控制概念"><a class="markdownIt-Anchor" href="#流量控制概念"></a> 流量控制概念</h1><h2 id="整形-shaping"><a class="markdownIt-Anchor" href="#整形-shaping"></a> 整形 (Shaping)</h2><p>整形器（shaper）是将数据包延迟，从而使得数据包传输速度满足特定速率。</p><h2 id="调度-scheduling"><a class="markdownIt-Anchor" href="#调度-scheduling"></a> 调度 (Scheduling)</h2><p>调度器（scheduler）负责数据包如何在队列中组织。</p><h2 id="分类-classifying"><a class="markdownIt-Anchor" href="#分类-classifying"></a> 分类 (Classifying)</h2><p>分类器（classifying）将流量分类到不同队列中。</p><h2 id="策略-policing"><a class="markdownIt-Anchor" href="#策略-policing"></a> 策略 (Policing)</h2><p>策略器在特定队列中测量和限制流量。</p><h2 id="丢弃-dropping"><a class="markdownIt-Anchor" href="#丢弃-dropping"></a> 丢弃 (Dropping)</h2><p>丢弃机制可以将整个数据包、整个流或是整个分类都丢弃掉。</p><h2 id="标记-marking"><a class="markdownIt-Anchor" href="#标记-marking"></a> 标记 (Marking)</h2><p>标记是一种更改数据包的机制。</p><h1 id="linux-流量控制组件"><a class="markdownIt-Anchor" href="#linux-流量控制组件"></a> Linux 流量控制组件</h1><p>对于流量控制而言，Linux 内核通过几个组件直接或间接的实现了流量控制的若干元素概念。主要以 <code>qdisc-class-filter</code> 的树形结构来实现对流量的分层控制。</p><table><thead><tr><th>传统元素</th><th>Linux 组件</th></tr></thead><tbody><tr><td>整形 (Shaping)</td><td>class 提供整形功能</td></tr><tr><td>调度 (Scheduling)</td><td>qdisc 是调度器，可以是简单的 FIFO，也可以是复杂的包含 class 和其他 qdiscs 的 HTB。</td></tr><tr><td>分类 (Classifying)</td><td>filter 对象通过 classifier 对象的代理执行分类功能。</td></tr><tr><td>策略 (Policing)</td><td>policer 作为 filter 的一部分存在。</td></tr><tr><td>丢弃 (Dropping)</td><td>要丢弃流量，需要使用带有“丢弃”动作的 policer 配合 filter 进行过滤。</td></tr><tr><td>标记 (Marking)</td><td>dsmark qdisc 用于标记。</td></tr></tbody></table><h2 id="队列调度-qdisc"><a class="markdownIt-Anchor" href="#队列调度-qdisc"></a> 队列调度 (qdisc)</h2><p>qdisc 是一个调度器，每个输出接口都有一种调度器，默认是 FIFO。Linux 下可用的其他 qdiscs 将根据该调度器的规则重新排列进入调度器队列的数据包。</p><p>qdisc 是流量控制的主要组成部分，也称为队列规则 (queuing discipline)，根据有无层级可以划分为两种：</p><ul><li>分类 qdiscs 可以包括 class，并且提供附加 filter 的接口。</li><li>无类 qdiscs 不能包含任何 class，也无法将 filter 附加到无类 qdisc。</li></ul><p>每个接口都包括两个端口：</p><ul><li>egress 用于 outbound traffic</li><li>ingress 用于 inbound traffic</li></ul><p>其中，主流和常用的是 egress qdisc，也称为 root qdisc。</p><p>对于接口上接受的流量，将进入 ingress qdisc，它不允许创建任何子类，而仅作为可附加过滤器的对象存在。出于实际目的，入口 qdisc 只是一个方便的对象，在其上附加了策略器以限制网络接口上接受的流量。</p><p>简而言之，egress qdisc 可以进行更多操作，因为它包含真实的 qdisc 和流量控制系统的全部功能。ingress qdisc 只能支持 policer。</p><h2 id="类-class"><a class="markdownIt-Anchor" href="#类-class"></a> 类 (class)</h2><p>class 只存在于分类 qdisc 中，class 可以包括多个子类或者一个独立的子队列。</p><p>任何类都可以附加任意数量的过滤器，使得流量可以进入子类或者重新分类/丢弃进入特定类别的流量。</p><p>叶子类是 qdisc 中的终端类，它包含一个 qdisc（默认 FIFO），并且永远不会包含子类。任何包含子类的类都是内部类（或根类），而不是叶子类。</p><h2 id="过滤器-filter"><a class="markdownIt-Anchor" href="#过滤器-filter"></a> 过滤器 (filter)</h2><p>过滤器是 Linux 流量控制系统中最复杂的组件。过滤器提供了一种方便的机制可以将流量控制的几个关键要素粘合在一起，其最明显的作用是对数据包进行分类，Linux 允许用户使用多个不同的 filter 或单个 filter 将数据包分类到输出队列中。</p><ul><li>过滤器必须包含分类器部分</li><li>过滤器可能包含策略器部分</li></ul><p>可以将过滤器附加到 <strong>classful qdisc</strong> 或 <strong>class</strong> 上。排队的数据包始终首先进入 root qdisc，在遍历附加到 root qdisc 的 filter 之后，可以将包定向到任何子类（可以具有自己的 filter），在该子类中包可以进行进一步分类。</p><h2 id="分类器-classifier"><a class="markdownIt-Anchor" href="#分类器-classifier"></a> 分类器 (classifier)</h2><p>可以使用 tc 进行操作的过滤器对象可以使用几种不同的分类机制，其中最常见的是 u32 分类器。u32 分类器允许用户根据数据包的属性选择数据包，分类器是可用作过滤器的一部分的工具，以识别数据包或数据包元数据的特征。Linux 分类器对象类似于流量控制 classifying 概念的基本操作和机制。</p><h2 id="策略器-policer"><a class="markdownIt-Anchor" href="#策略器-policer"></a> 策略器 (policer)</h2><p>策略器的基本机制仅在 Linux 流量控制中用作过滤器的一部分。策略器要求在指定速率之上执行一项操作，而在指定速率之下执行另一项操作。</p><p>尽管策略和整形都是限制带宽使用的流量控制的基本元素，但<strong>策略器永远不会延迟流量</strong>，它只能根据指定的标准执行操作。</p><h2 id="标识符-handle"><a class="markdownIt-Anchor" href="#标识符-handle"></a> 标识符 (handle)</h2><p>每个 class 和分类 qdisc 在流量控制结构中都需要一个唯一的标识符，也称为 handle，由 <code>major:minor</code> 两部分数字组成。</p><ul><li>major：此参数对内核完全没有意义。用户可以使用任意编号方案，但是流量控制结构中具有相同父对象的所有对象必须共享 major 号。对于直接附加到 root qdisc 的对象，常规编号方案从 1 开始。</li><li>minor：minor 为 0，则表示该对象是 qdisc，其他值表示该对象是 class，具有共同父母的 class 必须具有唯一的 minor 号。</li></ul><h1 id="linux-网络栈与队列"><a class="markdownIt-Anchor" href="#linux-网络栈与队列"></a> Linux 网络栈与队列</h1><p>在数据传输路径上，Linux 网络栈和队列的关系可以简化为下图表示</p><p><img src="stack-qdisc.jpg" alt="stack-qdisc"></p><p>驱动程序队列（Diver queue）位于网络栈和网络接口控制器（NIC）之间。此队列通常实现为先进先出（FIFO）环形缓冲区，只需将其视为固定大小的缓冲区即可。驱动程序队列不包含数据包数据，它由指向其他数据结构的描述符组成，这些数据称为套接字内核缓冲区（SKB），这些数据结构保存着数据包数据，并在整个内核中使用。</p><h1 id="iproute2-工具-tc"><a class="markdownIt-Anchor" href="#iproute2-工具-tc"></a> iproute2 工具 (tc)</h1><p><code>iproute2</code> 是一套命令行实用程序，可操纵内核结构以在计算机上进行 IP 网络配置。其中 <code>tc</code> 是唯一用于流量控制的命令行工具。</p><p>tc 命令使用方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@leander]<span class="comment"># tc</span></span><br><span class="line">Usage: tc [ OPTIONS ] OBJECT &#123; COMMAND | <span class="built_in">help</span> &#125;</span><br><span class="line"><span class="built_in">where</span>  OBJECT := &#123; qdisc | class | filter &#125;</span><br><span class="line">       OPTIONS := &#123; -s[tatistics] | -d[etails] | -r[aw] &#125;</span><br></pre></td></tr></table></figure><p>tc qdisc 命令使用方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@leander]<span class="comment"># tc qdisc add    \ (1)</span></span><br><span class="line">&gt;                  dev eth0     \ (2)</span><br><span class="line">&gt;                  root         \ (3)</span><br><span class="line">&gt;                  handle 1:0   \ (4)</span><br><span class="line">&gt;                  htb            (5)</span><br></pre></td></tr></table></figure><p>tc class 命令使用方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@leander]<span class="comment"># tc class add    \ (1)</span></span><br><span class="line">&gt;                  dev eth0     \ (2)</span><br><span class="line">&gt;                  parent 1:1   \ (3)</span><br><span class="line">&gt;                  classid 1:6  \ (4)</span><br><span class="line">&gt;                  htb          \ (5)</span><br><span class="line">&gt;                  rate 256kbit \ (6)</span><br><span class="line">&gt;                  ceil 512kbit   (7)</span><br></pre></td></tr></table></figure><p>tc filter 命令使用方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@leander]<span class="comment"># tc filter add               \ (1)</span></span><br><span class="line">&gt;                  dev eth0                 \ (2)</span><br><span class="line">&gt;                  parent 1:0               \ (3)</span><br><span class="line">&gt;                  protocol ip              \ (4)</span><br><span class="line">&gt;                  prio 5                   \ (5)</span><br><span class="line">&gt;                  u32                      \ (6)</span><br><span class="line">&gt;                  match ip port 22 0xffff  \ (7)</span><br><span class="line">&gt;                  match ip tos 0x10 0xff   \ (8)</span><br><span class="line">&gt;                  flowid 1:6               \ (9)</span><br><span class="line">&gt;                  police                   \ (10)</span><br><span class="line">&gt;                  rate 32000bps            \ (11)</span><br><span class="line">&gt;                  burst 10240              \ (12)</span><br><span class="line">&gt;                  mpu 0                    \ (13)</span><br><span class="line">&gt;                  action drop/<span class="built_in">continue</span>       (14)</span><br></pre></td></tr></table></figure><h1 id="qdisc"><a class="markdownIt-Anchor" href="#qdisc"></a> qdisc</h1><h2 id="无类-qdisc-classless-queuing-disciplines"><a class="markdownIt-Anchor" href="#无类-qdisc-classless-queuing-disciplines"></a> 无类 qdisc (Classless Queuing Disciplines)</h2><h3 id="先入先出队列-fifo-first-in-first-out"><a class="markdownIt-Anchor" href="#先入先出队列-fifo-first-in-first-out"></a> 先入先出队列 (FIFO, First-In First-Out)</h3><p>FIFO 算法构成所有 Linux 网络接口（pfifo_fast）上默认 qdisc 的基础，它不对数据包进行整形或重新排列，而仅仅只是在接收并排队后尽快传输数据包。FIFO qdisc 也是在所有新创建的 class 中使用的 qdisc，直到另一个 qdisc 或一个 class 替换它。</p><p><img src="fifo-qdisc.png" alt="fifo-qdisc"></p><p>但是，真实的 FIFO qdisc 必须具有大小限制（缓冲区大小），以防止数据包入队速度大于出队速度时产生溢出。Linux 实现了两个基本的 FIFO qdiscs：</p><ul><li>pfifo 基于字节</li><li>bfifo 基于数据包</li></ul><p>无论使用哪种 FIFO，队列的大小都由参数 limit 定义，对于 pfifo 单位为分组，而对于 bfifo 单位为字节。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc ... add pfifo [ <span class="built_in">limit</span> packets ]</span><br><span class="line"></span><br><span class="line">tc qdisc ... add bfifo [ <span class="built_in">limit</span> bytes ]</span><br></pre></td></tr></table></figure><p>对于 pfifo，默认值为接口的 txqueuelen, 可通过 <code>ip</code> 命令或 <code>ifconfig</code> 命令查看，一般为 1000。该值范围为 [0, UINT32_MAX]。</p><p>对于 pfifo，默认值为接口的 txqueuelen * MTU，该值范围为 [0, UINT32_MAX] 字节。</p><h3 id="快速-fifo-队列-pfifo_fast"><a class="markdownIt-Anchor" href="#快速-fifo-队列-pfifo_fast"></a> 快速 FIFO 队列 (pfifo_fast)</h3><p>快速 FIFO 队列使用了三个 pfifo，并<strong>根据 TOS 字段或者用户自定义的优先级字典</strong>将不同的数据包入队不同的 FIFO，是 Linux 的默认队列实现。</p><p><img src="pfifo_fast-qdisc.png" alt="pfifo_fast-qdisc"></p><p>需要注意的是，三个队列并非同时出队，当数字较小的队列（高优先级，lower bands）阻塞时，数字较大的队列（低优先级，higher bands）将永远不会出队。</p><p>因此该队列可用于流量的优先级处理，这与 prio 队列非常相似。</p><h3 id="随机公平队列-sfq-stochastic-fair-queuing"><a class="markdownIt-Anchor" href="#随机公平队列-sfq-stochastic-fair-queuing"></a> 随机公平队列 (SFQ, Stochastic Fair Queuing)</h3><p>随机公平队列也使用了多个 FIFO 队列，与 pfifo_fast 队列依据优先级不同， sfq 队列根据<strong>流 (flow)</strong> 来决定数据包的流向。</p><p><img src="sfq-qdisc.png" alt="sfq-qdisc"></p><p>默认情况下，sfq 队列的散列函数根据数据包的以下三个值来计算散列值，相同的散列值的数据包视为同一个流，因此会进入相同的队列。</p><ul><li>Source address</li><li>Destination address</li><li>Source and Destination port</li></ul><p>出队时采用 round robin 轮转算法，每个流都按顺序得到发送机会，这也是该队列公平的体现，从而保证了每一个流都不会被其它流所淹没。SFQ 之所以被称为“随机”，是因为它并不是真的为每一个流创建一个队列，而是使用一个散列算法把所有的流映射到有限的几个队列中去。</p><p>用户可以通过参数来决定散列的细节，例如：</p><ul><li>divisor：散列桶的大小。</li><li>limit：SFQ 最大长度。</li><li>depth：每条流的最大长度。</li><li>perturb：每隔多长时间更新一次散列函数，以达到更好的公平性。</li><li>…</li></ul><p>更多参数细节不再列出。</p><p>另外，用户可以通过 filter 来改变散列函数，通过允许用户控制使用哪种哈希算法来分配对网络带宽的访问，用户可以达到更公平的带宽实际分配。</p><p>sfq 队列的用处在于：如果你的链路已经塞满了，而你想保证不会有某一个流独占出口带宽，使用随机公平队列可以达到此效果。</p><h3 id="令牌桶过滤-tbf-token-bucket-filter"><a class="markdownIt-Anchor" href="#令牌桶过滤-tbf-token-bucket-filter"></a> 令牌桶过滤 (TBF, Token Bucket Filter)</h3><p>此 qdisc 建立在令牌和存储桶上，它只是对接口上传输的流量进行整形。为了限制数据包从特定接口出队的速度，TBF qdisc 是理想的解决方案，它只是将传输的流量减慢到指定的速率（令牌入桶的速率）。</p><p><img src="tbf-qdisc.png" alt="tbf-qdisc"></p><p>其 tc 语法如下（为了便于观看做了额外的换行，并且将参数用 <code>**</code>标识）：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tc  qdisc  ...  tbf </span><br><span class="line">    <span class="built_in">rate</span> *<span class="built_in">rate</span>* </span><br><span class="line">    burst *bytes/<span class="built_in">cell</span>* </span><br><span class="line">    ( latency *ms* | limit *bytes* ) </span><br><span class="line">    [ mpu *bytes* [ peakrate *<span class="built_in">rate</span>* mtu *bytes/<span class="built_in">cell</span>* ] ]</span><br></pre></td></tr></table></figure><ul><li>rate：令牌入桶速率，也就是限制发送的速率。</li><li>burst：缓存区最大容量，也就是桶的容量。这决定了瞬发流量的峰值能达到多少，通常更高的整形要求需要更大的缓存。</li><li>limit 或 latency：队列中最多允许多少字节等待令牌可用；或者最多允许等待多长时延。超过 limit 或 latency 的部分可能会被丢弃。</li><li>mpu：最小分组单位（Minimum Packet Unit）, 它决定了令牌的最低消耗。</li></ul><div class="note info">            <p><strong>tbf 队列是 classless 还是 classful ?</strong><br>在 tc 主文档（man page）和各类教程中，tbf 队列是无类 qdisc，但是 <code>man tc-tbf</code> 可以发现在描述开头就指出其为分类队列：</p><blockquote><p>The Token Bucket Filter is a classful queueing discipline available for traffic control with the tc(8) command.</p></blockquote><p>通过实践可以发现每当创建一个 tbf qdisc 时，便会同时生成一个对应的 class。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tc qdisc add dev veth handle 1: root tbf burst 20480 <span class="built_in">limit</span> 20480 mtu 1514 rate 32000bps</span><br><span class="line">$ tc qdisc show dev veth </span><br><span class="line">qdisc tbf 1: root refcnt 2 rate 256Kbit burst 20Kb lat 0us </span><br><span class="line">$ tc class show dev veth </span><br><span class="line">class tbf 1:1 parent 1: </span><br></pre></td></tr></table></figure><p>当有其他 qdisc 指定该 tbf 为 parent 时，该 class 将会增加 leaf 字段。有趣的是，即使其他 qdisc 的 parent-id 不为 1:1（例如 1:4），但只要 parent-id 的 major 值为 tbf 的 handle 值即可作为 tbf 的叶子队列。如果此时有另一个 qdisc 将 parent-id 设置为 1:1 时，也就是将 tbf qdisc 作为 classful qdisc 使用，将会报错。</p><p>综上所述，tbf 实现上为 classful qdisc，因为其有默认 class，同时在语义上保留了 classless 的特点，因为 tbf 无法完成分流的功能， 这个特性使得用户可以方便的将 tbf 串联进某个 qdisc 处理链的中间用于限制带宽。具体见实践章节。</p>          </div><h3 id="网络模拟器-netem-network-emulator"><a class="markdownIt-Anchor" href="#网络模拟器-netem-network-emulator"></a> 网络模拟器 (NETEM, Network Emulator)</h3><p>网络模拟器是流量控制系统的一个增强工具，可以在接口的输出端增加一些网络数据包特性，包括：时延、丢包、重复等。</p><h2 id="分类-qdisc-classful-queuing-disciplines"><a class="markdownIt-Anchor" href="#分类-qdisc-classful-queuing-disciplines"></a> 分类 qdisc (Classful Queuing Disciplines)</h2><h3 id="分层令牌桶-htb-hierarchical-token-bucket"><a class="markdownIt-Anchor" href="#分层令牌桶-htb-hierarchical-token-bucket"></a> 分层令牌桶 (HTB, Hierarchical Token Bucket)</h3><p>见实践相关章节</p><h1 id="实践"><a class="markdownIt-Anchor" href="#实践"></a> 实践</h1><h2 id="搭建本地环境"><a class="markdownIt-Anchor" href="#搭建本地环境"></a> 搭建本地环境</h2><p>利用 Linux 命名空间隔离机制，搭建一个本地的测试环境，在虚拟网卡上进行 tc 命令的测试，不影响机器当前的物理网卡设置。</p><figure class="highlight sh"><figcaption><span>config.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ip netns add tcns</span><br><span class="line">ip link add veth <span class="built_in">type</span> veth peer name eth0</span><br><span class="line">ip link <span class="built_in">set</span> eth0 netns tcns</span><br><span class="line">ip address add 192.168.1.1/24 dev veth</span><br><span class="line">ip netns <span class="built_in">exec</span> tcns ip addr add 192.168.1.2/24 dev eth0</span><br><span class="line">ip link <span class="built_in">set</span> veth up</span><br><span class="line">ip netns <span class="built_in">exec</span> tcns ip link <span class="built_in">set</span> eth0 up</span><br><span class="line">ip address show veth</span><br><span class="line">ip netns <span class="built_in">exec</span> tcns ip address show eth0</span><br></pre></td></tr></table></figure><p>根据以上脚本可以搭建一个 tcns 命名空间，其 IP 地址为 192.168.1.2/24，接口为 eth0；可以在本机执行 ping 192.168.1.2 测试联通性。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo sh config.sh       # 设置环境</span><br><span class="line">sudo<span class="built_in"> ip </span>netns del tcns  # 清空设置</span><br><span class="line">ping 192.168.1.2        # 测试联通性</span><br></pre></td></tr></table></figure><p>我们所有的 tc 设置都设置到 veth 接口，从而验证流量控制。</p><h2 id="限制带宽"><a class="markdownIt-Anchor" href="#限制带宽"></a> 限制带宽</h2><p>使用令牌桶 qdisc 将接口最高速率限制到 256Kbit/s，设置缓冲区和最大排队字节数均为 20Kb，没有时延。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc add dev veth handle <span class="number">1</span>:<span class="number">0</span> root tbf burst <span class="number">20480</span> limit <span class="number">20480</span> mtu <span class="number">1514</span> rate <span class="number">32000</span>bps</span><br><span class="line">$ tc qdisc show dev veth</span><br><span class="line">qdisc dsmark <span class="number">1</span>: root <span class="built_in">ref</span>cnt <span class="number">2</span> indices <span class="number">0x0001</span> default_index <span class="number">0x0000</span> </span><br><span class="line">qdisc tbf <span class="number">2</span>: parent <span class="number">1</span>: rate <span class="number">256</span>Kbit burst <span class="number">20</span>Kb lat <span class="number">0</span>us</span><br></pre></td></tr></table></figure><p>使用 iperf 工具测速，结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo<span class="built_in"> ip </span>netns exec tcns iperf -s </span><br><span class="line">Server listening on TCP<span class="built_in"> port </span>5001</span><br><span class="line">TCP window size:  128 KByte (default)</span><br><span class="line">[  4] local 192.168.1.2<span class="built_in"> port </span>5001 connected with 192.168.1.1<span class="built_in"> port </span>34594</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  4]  0.0-15.8 sec   489 KBytes   254 Kbits/sec</span><br></pre></td></tr></table></figure><h2 id="模拟时延和丢包"><a class="markdownIt-Anchor" href="#模拟时延和丢包"></a> 模拟时延和丢包</h2><p>使用 netem 来模拟一些物理特性，这里设置了 5ms 时延和 5%丢包。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc add dev veth handle <span class="number">1</span>:<span class="number">0</span> root netem delay <span class="number">5</span>ms loss <span class="number">5</span>%</span><br><span class="line">$ tc qdisc show dev veth </span><br><span class="line">qdisc netem <span class="number">1</span>: root <span class="built_in">ref</span>cnt <span class="number">2</span> limit <span class="number">1000</span> delay <span class="number">5.0</span>ms loss <span class="number">5</span>%</span><br></pre></td></tr></table></figure><p>使用 ping 命令测试一下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in"> ping </span>192.168.1.2</span><br><span class="line">PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.1.2: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=5.09 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.1.2: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=5.18 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.1.2: <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=5.27 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.1.2: <span class="attribute">icmp_seq</span>=4 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=5.08 ms</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line">--- 192.168.1.2<span class="built_in"> ping </span>statistics ---</span><br><span class="line">24 packets transmitted, 23 received, 4.16667% packet loss, time 23045ms</span><br><span class="line">rtt min/avg/max/mdev = 5.080/5.184/5.273/0.062 ms</span><br></pre></td></tr></table></figure><p>除了 delay 和 loss 常规设置之外，还可以：</p><ul><li>通过 distribution 设置时延的分布函数。</li><li>通过一些参数可以为丢包率的设置引入一些概率分布和随机性。</li><li>通过 corrupt 设置噪声导致的比特错误，支持引入相关性等参数。</li><li>通过 duplicate 设置包重复率，支持引入相关性等参数。</li><li></li></ul><h2 id="综合限制带宽模拟时延和丢包"><a class="markdownIt-Anchor" href="#综合限制带宽模拟时延和丢包"></a> 综合：限制带宽+模拟时延和丢包</h2><p>通过 tbf 和 netem 结合使用同时限制带宽，并且为接口增加时延。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tc qdisc add dev veth handle <span class="number">1</span>: root netem limit <span class="number">10240</span> delay <span class="number">10</span>ms loss <span class="number">5</span>%</span><br><span class="line">$ sudo tc qdisc add dev veth handle <span class="number">10</span>: parent <span class="number">1</span>:<span class="number">1</span> tbf burst <span class="number">20480</span> limit <span class="number">20480</span> mtu <span class="number">1514</span> rate <span class="number">32000</span>bps</span><br><span class="line">$ sudo tc qdisc show dev veth</span><br><span class="line">qdisc netem <span class="number">1</span>: root <span class="built_in">ref</span>cnt <span class="number">2</span> limit <span class="number">10240</span> delay <span class="number">20.0</span>ms loss <span class="number">5</span>%</span><br><span class="line">qdisc tbf <span class="number">10</span>: parent <span class="number">1</span>:<span class="number">1</span> rate <span class="number">256</span>Kbit burst <span class="number">20</span>Kb lat <span class="number">0</span>us </span><br></pre></td></tr></table></figure><p>重复上述测试方法，可以看到参数设置生效。</p><div class="note info">            <p>netem 中也有设置 rate 的参数，但是限速会一定程度上影响 delay，因此通过 tbf 来进行限制带宽更加精准。</p>          </div><h2 id="多级流量分类"><a class="markdownIt-Anchor" href="#多级流量分类"></a> 多级流量分类</h2><p>使用分层令牌桶完成多级流量分类。</p><p>首先在接口的 root 处创建一个 htb qdisc，设置默认类为 1:30。接着创建一个根分类以及三个子类，并设置相应的速率，同时包括 burst 以及 ceil。最后为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev veth root handle 1: htb default 30</span><br><span class="line">tc class add dev veth parent 1: classid 1:1 htb rate 6mbit burst 15k</span><br><span class="line">tc class add dev veth parent 1:1 classid 1:10 htb rate 5mbit burst 15k</span><br><span class="line">tc class add dev veth parent 1:1 classid 1:20 htb rate 3mbit ceil 6mbit burst 15k</span><br><span class="line">tc class add dev veth parent 1:1 classid 1:30 htb rate 1kbit ceil 6mbit burst 15k</span><br><span class="line"></span><br><span class="line">tc qdisc add dev veth parent 1:10 handle 10: sfq perturb 10</span><br><span class="line">tc qdisc add dev veth parent 1:20 handle 20: sfq perturb 10</span><br><span class="line">tc qdisc add dev veth parent 1:30 handle 30: sfq perturb 10</span><br></pre></td></tr></table></figure><p>查看创建的 qdisc 以及 class：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tc qdisc show dev veth </span><br><span class="line">qdisc htb 1: root refcnt 2 r2q 10 default 0x30 direct_packets_stat 24 direct_qlen 1000</span><br><span class="line">qdisc sfq 10: parent 1:10 <span class="built_in">limit</span> 127p quantum 1514b depth 127 divisor 1024 perturb 10sec </span><br><span class="line">qdisc sfq 20: parent 1:20 <span class="built_in">limit</span> 127p quantum 1514b depth 127 divisor 1024 perturb 10sec </span><br><span class="line">qdisc sfq 30: parent 1:30 <span class="built_in">limit</span> 127p quantum 1514b depth 127 divisor 1024 perturb 10sec </span><br><span class="line"></span><br><span class="line">$ tc class show dev veth </span><br><span class="line">class htb 1:1 root rate 6Mbit ceil 6Mbit burst 15Kb cburst 1599b </span><br><span class="line">class htb 1:10 parent 1:1 leaf 10: prio 0 rate 5Mbit ceil 5Mbit burst 15Kb cburst 1600b </span><br><span class="line">class htb 1:20 parent 1:1 leaf 20: prio 0 rate 3Mbit ceil 6Mbit burst 15Kb cburst 1599b </span><br><span class="line">class htb 1:30 parent 1:1 leaf 30: prio 0 rate 1Kbit ceil 6Mbit burst 15Kb cburst 1599b </span><br></pre></td></tr></table></figure><p>使用 iperf 测试带宽为 5.75M，因为此时没有别的流量，其 ceil 值生效。查看统计信息确认所有流量进入了 30: 队列。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tc -s qdisc show dev veth </span><br><span class="line">qdisc htb 1: root refcnt 2 r2q 10 default 0x30 direct_packets_stat 24 direct_qlen 1000</span><br><span class="line"> Sent 7956658 bytes 5291 pkt (dropped 0, overlimits 3100 requeues 0) </span><br><span class="line"> backlog 0b 0p requeues 0</span><br><span class="line">qdisc sfq 30: parent 1:30 <span class="built_in">limit</span> 127p quantum 1514b depth 127 divisor 1024 perturb 10sec </span><br><span class="line"> Sent 7950694 bytes 5263 pkt (dropped 0, overlimits 0 requeues 0) </span><br><span class="line"> backlog 0b 0p requeues 0</span><br><span class="line">qdisc sfq 10: parent 1:10 <span class="built_in">limit</span> 127p quantum 1514b depth 127 divisor 1024 perturb 10sec </span><br><span class="line"> Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0) </span><br><span class="line"> backlog 0b 0p requeues 0</span><br><span class="line">qdisc sfq 20: parent 1:20 <span class="built_in">limit</span> 127p quantum 1514b depth 127 divisor 1024 perturb 10sec </span><br><span class="line"> Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0) </span><br><span class="line"> backlog 0b 0p requeues 0</span><br></pre></td></tr></table></figure><p>一旦在 root 上设置了分类 qdisc 以及 class，就必须使用 filter 来指示哪个类应处理哪个包。接下来使用 filter 来将流量分到不同的 class 中。</p><p>我们采用如下的过滤方案：</p><ul><li>TCP 目的端口为 5001 的包进入 1:10 class 处理</li><li>TCP 目的端口为 5002 的包进入 1:20 class 处理</li><li>IP 目的地址为 192.168.1.2/32 的包进入 1:30 class 处理</li><li>其余默认走 1:30 类</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tc filter add dev veth protocol ip parent 1: prio 1 u32 match ip dport 5001 0xffff flowid 1:10</span><br><span class="line">tc filter add dev veth protocol ip parent 1: prio 1 u32 match ip dport 5002 0xffff flowid 1:20</span><br><span class="line">tc filter add dev veth protocol ip parent 1: prio 2 u32 match ip dst 192.168.1.2/32 flowid 1:30</span><br></pre></td></tr></table></figure><p>使用 iperf 测试，在 192.168.1.2 上建立两个 tcp server 分别监听 5001 和 5002 端口，观察过滤情况。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/index.html" target="_blank" rel="noopener">Traffic Control HOWTO</a></li><li><a href="https://www.linuxjournal.com/content/queueing-linux-network-stack" target="_blank" rel="noopener">Queueing in the Linux Network Stack</a></li><li><a href="https://www.cs.unm.edu/~crandall/netsfall13/TCtutorial.pdf" target="_blank" rel="noopener">Traffic Control Manual For Lab1</a></li><li><a href="http://home.ifi.uio.no/paalh/students/AndersMoe.pdf" target="_blank" rel="noopener">Implementing Rate Control in NetEm</a></li><li><a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank" rel="noopener">Netem wiki</a></li><li><a href="https://wiki.archlinux.org/index.php/Advanced_traffic_control" target="_blank" rel="noopener">Advanced traffic control, Archwiki</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network Local Socket</title>
      <link href="/2020/09/01/network-local-socket/"/>
      <url>/2020/09/01/network-local-socket/</url>
      
        <content type="html"><![CDATA[<p>Unix 域 (Unix Domain Socket) 是一种 IPC 方式，也称为本地套接字通信。</p><a id="more"></a><h1 id="unix-域字节流客户服务器实例"><a class="markdownIt-Anchor" href="#unix-域字节流客户服务器实例"></a> Unix 域字节流客户/服务器实例</h1><h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">char</span>* path = <span class="string">"/tmp/parent"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">remoteaddr</span>, <span class="title">localaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    sockfd = socket(AF_LOCAL, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    unlink(path);</span><br><span class="line">    bzero(&amp;remoteaddr, <span class="keyword">sizeof</span>(remoteaddr));</span><br><span class="line">    bzero(&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line"></span><br><span class="line">    localaddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(localaddr.sun_path,path);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[main] bind success\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>n;</span><br><span class="line"><span class="keyword">socklen_t</span>len;</span><br><span class="line"><span class="keyword">char</span>mesg[MAXLINE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">len = <span class="keyword">sizeof</span>(remoteaddr);</span><br><span class="line">        n = recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, &amp;remoteaddr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[main] recieve %s from server %s\n"</span>, (<span class="keyword">char</span> *)mesg, remoteaddr.sun_path);</span><br><span class="line">sendto(sockfd, mesg, n, <span class="number">0</span>, &amp;remoteaddr, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[main] send %s to server %s\n"</span>, (<span class="keyword">char</span> *)mesg, remoteaddr.sun_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">char</span>* server_path = <span class="string">"/tmp/parent"</span>;</span><br><span class="line">    <span class="keyword">char</span>* path = <span class="string">"/tmp/child"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">remoteaddr</span>, <span class="title">localaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    sockfd = socket(AF_LOCAL, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[child] %d\n"</span>,sockfd);</span><br><span class="line">    unlink(path);</span><br><span class="line">    bzero(&amp;remoteaddr, <span class="keyword">sizeof</span>(remoteaddr));</span><br><span class="line">    bzero(&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line"></span><br><span class="line">    localaddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(localaddr.sun_path,path);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[child] bind to %s success\n"</span>, path);</span><br><span class="line"></span><br><span class="line">    remoteaddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(remoteaddr.sun_path, server_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>n;</span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(remoteaddr);</span><br><span class="line">    <span class="keyword">char</span> sendbuf[MAXLINE] = &#123;<span class="string">'f'</span>, <span class="string">'u'</span>, <span class="string">'c'</span>, <span class="string">'k'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> recvbuf[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    sendto(sockfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, &amp;remoteaddr, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[child] send %s to server %s\n"</span>, (<span class="keyword">char</span> *)sendbuf, remoteaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    n = recvfrom(sockfd, recvbuf, MAXLINE, <span class="number">0</span>, &amp;remoteaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[child] recieve %s from server %s\n"</span>,(<span class="keyword">char</span> *) recvbuf, remoteaddr.sun_path);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br></pre></td></tr></table></figure><h1 id="unix-域数据报客户服务器实例"><a class="markdownIt-Anchor" href="#unix-域数据报客户服务器实例"></a> Unix 域数据报客户/服务器实例</h1>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Socket </tag>
            
            <tag> I/O </tag>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Operating System</title>
      <link href="/2020/08/03/os-intro/"/>
      <url>/2020/08/03/os-intro/</url>
      
        <content type="html"><![CDATA[<p>计算机是如何运行程序的？简而言之：执行指令。</p><ul><li>首先处理器从内存中获取 (fetch) 一条指令；</li><li>然后对其进行解码 (decode)，弄清楚这是什么指令；</li><li>接着执行 (execute) 它，具体可以做什么和处理器的指令集有关；</li><li>完成这条指令后，跳转到下一条指令，直到最后完成程序的执行。</li></ul><a id="more"></a><p>这就是冯·诺依曼计算模型的基础，它的实质就是如此的简单。然而实际上编写这样的代码无异于异常困难，你需要对这个系统中方方面面都了解才能写出一个简单的程序。而<strong>操作系统负责让程序运行变得容易</strong>，允许程序与设备交互，甚至允许你同时运行多个程序！</p><p>为了实现上述目的，操作系统利用<strong>虚拟化</strong>技术将物理资源 (如 CPU、内存、硬盘) 转换为更加通用、强大且易于使用的虚拟形式，因此操作系统是一个资源管理器。</p><p>为了让你知道你能通过操作系统做些什么，操作系统还提供了一些接口供你调用，实际上典型的操作系统会提供几百个<strong>系统调用 (system call)</strong> 供程序使用。因此操作系统为应用程序提供了一个标准库。下面是 Unix 系统的结构，最底层是硬件，然后是内核 (操作系统) ，上层是利用各种系统调用而构建的库或工具，再上层便是应用程序。</p><p><img src="system-structure.png" alt="system-structure"></p><h1 id="虚拟化-cpu"><a class="markdownIt-Anchor" href="#虚拟化-cpu"></a> 虚拟化 CPU</h1><p>以下是一个简单的程序，该程序的作用是：每隔一秒打印一个字符串。</p><figure class="highlight c"><figcaption><span>cpu.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: cpu &lt;string&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接运行一个程序，然后使用 <code>Control + C</code> 来强制终止他。但假如同时运行四个程序，我们会观察到四个程序仿佛在同时运行，程序交替输出 A B C D，但顺序是不能保证的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">liyj@ubuntu:~$ gcc -o cpu cpu.c </span><br><span class="line">liyj@ubuntu:~$ ./cpu <span class="string">"A"</span></span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">^C</span><br><span class="line">liyj@ubuntu:~$ ./cpu <span class="string">"A"</span> &amp; ./cpu <span class="string">"B"</span> &amp; ./cpu <span class="string">"C"</span> &amp; ./cpu <span class="string">"D"</span> &amp;</span><br><span class="line">... <span class="comment"># 4 个程序的 PID</span></span><br><span class="line">... <span class="comment"># 交替输出的 ABCD</span></span><br></pre></td></tr></table></figure><p>虽然我们只有一个 CPU (忽略多核超线程) ，但我们好似拥有无限的 CPU，从而让许多程序看似同时运行，这就是 <strong>CPU 虚拟化</strong>。</p><h1 id="虚拟化内存"><a class="markdownIt-Anchor" href="#虚拟化内存"></a> 虚拟化内存</h1><p>现代机器提供的物理内存模型非常简单：内存就是一个字节数组。程序运行需要访问内存，因为我们的代码和数据都存储在内存之上。</p><figure class="highlight c"><figcaption><span>mem.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d) memory address of p: %p\n"</span>, getpid(), p);</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        *p = *p + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%d) p: %d\n"</span>, getpid(), *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">liyj@ubuntu:~$ ./mem &amp; ./mem &amp;</span><br><span class="line">... <span class="comment"># 2 个进程的 PID </span></span><br><span class="line">(9170) memory address of p: 0x555555559260</span><br><span class="line">(9171) memory address of p: 0x555555559260</span><br><span class="line">... <span class="comment"># 交替输出 p 值</span></span><br></pre></td></tr></table></figure><p>可以发现，两个进程中的 p 的地址竟然是完全一样的！这正是操作系统虚拟化内存的作用，每个进程都拥有自己的虚拟地址空间，而虚拟地址以某种方式映射到了物理地址上，从而不会影响其他进程。</p><div class="note info">            <p>当然，要想看到上述效果，必须保证禁用了<strong>地址空间随机化</strong>，随机化可以带来更好的安全性。</p>          </div><h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1><p><strong>并发 (Concurrency)</strong> 指的是可以<strong>同时具有多个活动的任务</strong>。并发的反义词是顺序 (Sequential)，顺序执行的意思是各个任务必须依次执行，而不是并发的交替执行。与并发经常对比的另一个术语是<strong>并行 (parallelism)</strong>，并行强调<strong>同时执行</strong>。</p><div class="note info">            <p>早期的单核处理器系统 (Uniprocessor System) 中，因为仅仅只有一个 CPU 可以执行程序，因此并发执行仅是通过使一台计算机在其执行任务之间快速切换来模拟的。</p><p>然而，在现代多处理器系统 (Multiprocessor System) 已经司空见惯，多处理器系统具有多个 CPU (通常称为核心 core) 集成到单个 IC 芯片中，同时，超线程技术 (Hyperthreading) 使得单个 CPU 核心可以执行多个控制流，看起来我们拥有了更多的 CPU 硬件。假设你的 PC 使用了一颗 Intel Core i7 8 核 16 线程的芯片，那么可以认为你的 PC 拥有 16 个 CPU 可以用来执行代码。</p><p>正是由于现代多处理器系统的出现，并发的底层实际上不一定需要频繁的切换任务来模拟，它可能是真正并行执行的。然而作为用户我们无需深究这个过程，因为并发是逻辑上的概念，而并行是一种用来优化的底层技术。</p>          </div><p>操作系统为我们提供了多种形式的并发手段：基于进程、基于线程、基于 IO 多路复用。当我们需要并发的时候，我们需要同时执行多个任务，那么任务之间的关系就有两种可能性：</p><ol><li>分工：多个任务之间不需要交流，每个任务只需专注自己的任务。</li><li>合作：多个任务之间需要传递信息。</li></ol><p>对于分工式的并发，情况要好处理的多。然而对于合作式的并发，多个任务同时正确的操作共享 (shared) 可变的 (mutable) 资源可能很有难度。</p><p>通过 CPU 虚拟化和内存虚拟化我们已经知道了进程这个概念，<strong>基于进程的并发(process-based concurrency)</strong> 是操作系统固有的并发手段，进程具有“单独的虚拟地址空间”，每个进程都是由内核调度和维护的。</p><p>随着线程的出现，并发可以更小的粒度来实现，线程是在单个进程的中运行并由内核调度的逻辑流。<strong>基于线程的并发 (thread-based concurrency)</strong> 似乎是目前最常用的手段。</p><p>还有一类比较高级的并发基于 IO 多路复用实现，这种方式称为<strong>基于事件的并发 (event-based concurrency)</strong>。与前两种并发手段不同的是，基于事件的并发不再依赖操作系统进行任务调度，所有的任务的逻辑流都是由程序员来完成的。基于事件的并发常用于一些 GUI 程序或网络服务器中。</p><p>另一种新兴的并发手段是协程 (coroutine)，这种并发手段专注于协作式任务，通常由高级编程语言所支持，与基于事件的并发相同，这种并发手段也是由程序员来完成的。</p><h1 id="持久性"><a class="markdownIt-Anchor" href="#持久性"></a> 持久性</h1><p>内存的特性是掉电丢失，因此，操作系统需要<strong>硬件和软件</strong>来持久地（persistently）存储数据。</p><ul><li>硬件以某种输入/输出设备的形式出现。在现代系统中可能是磁盘驱动器（Hard Disk Driver）或者固态硬盘（SSD）。</li><li>操作系统中管理磁盘的软件通常称为<strong>文件系统（file system）</strong>，它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。</li></ul><p>不像操作系统为 CPU 和内存提供的抽象，操作系统不会为每个应用程序创建专用的虚拟磁盘。相反，它假设用户经常需要<strong>共享文件</strong>中的信息。</p><h1 id="抽象-机制-策略"><a class="markdownIt-Anchor" href="#抽象-机制-策略"></a> 抽象、机制、策略</h1><p>操作系统会将某项功能抽象为具体的形式，例如：</p><ul><li>将虚拟化 CPU 抽象为进程</li><li>将虚拟化内存抽象为进程的地址空间</li><li>将并发功能抽象为线程</li><li>将持久化功能抽象为文件系统</li></ul><p>为了实现这些抽象，操作系统就需要一些低级机制以及一些高级智能。我们将低级机制称为<strong>机制 (mechanism)</strong>。机制是一些低级方法或协议，实现了所需的功能。例如，进程切换是一种虚拟化 CPU 的机制。</p><p>在这些机制之上，操作系统中有一些智能以<strong>策略 (policy)</strong> 的形式存在，策略是在操作系统内做出某种决定的算法。操作系统在不同的情况下可以使用不同的策略，从而获得更高效的性能。这是一种模块化的思想，即操作系统可以在底层机制不变的情况下，通过更改策略来更好的实现功能。例如，当需要进程切换时，需要切换到哪一个进程就是进程调度策略。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存 (Virtual Memory)</title>
      <link href="/2020/08/03/os-vm/"/>
      <url>/2020/08/03/os-vm/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象地址空间"><a class="markdownIt-Anchor" href="#抽象地址空间"></a> 抽象：地址空间</h1><h1 id="机制地址转换"><a class="markdownIt-Anchor" href="#机制地址转换"></a> 机制：地址转换</h1><h1 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h1><h1 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h1><p>首先，它不会导致外部碎片，因为分页 (按设计) 将内存划分为固定大小的单元。其次，它非常灵活，支持稀疏虚拟地址空间。</p><p>页表太大 -》 多级页表<br>查询速度太慢 -》TLB</p><h2 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h2>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程 (Processes)</title>
      <link href="/2020/08/02/os-process/"/>
      <url>/2020/08/02/os-process/</url>
      
        <content type="html"><![CDATA[<p>从程序员的角度来看，进程就是运行中的程序。从操作系统的角度来看，进程是一种操作系统用来进行资源分配的最小单位，进程是对 CPU、内存、外设的一个抽象的表示模型。虽然只有少量的物理 CPU 可用，但是操作系统却通过进程提供了几乎有无数个 CPU 可用的假象。</p><a id="more"></a><h1 id="抽象进程"><a class="markdownIt-Anchor" href="#抽象进程"></a> 抽象：进程</h1><p>操作系统为正在运行的程序提供的抽象，就是所谓的进程。为了理解构成进程的是什么，我们必须理解它的机器状态 (machine state)：程序在运行时可以读取或更新的内容。具体而言，一个进程的机器状态涉及到 CPU、内存和外设。</p><ol><li>指令存在内存中，正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为<strong>地址空间</strong>，address space）是该进程的一部分。</li><li>进程的机器状态的另一部分是<strong>寄存器</strong>。许多指令明确地读取或更新寄存器，因此它们对于执行该进程很重要。例如，程序计数器 (Program Counter，PC) 告诉我们程序当前正在执行哪个指令。</li><li>程序也经常访问<strong>持久存储设备</strong>。因此进程需要包含此类 I/O 信息，例如当前打开的文件列表。</li></ol><h2 id="程序-vs-进程"><a class="markdownIt-Anchor" href="#程序-vs-进程"></a> 程序 vs 进程</h2><p>程序如何转化为进程？具体来说，操作系统如何启动并运行一个程序？</p><p>操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载 (load) 到内存中，加载到进程的地址空中。程序最初以某种可执行格式驻留在磁盘（或固态硬盘 SSD）上。因此，将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处。</p><p><img src="process-create.png" alt="process-create"></p><p>在早期的（或简单的）操作系统中，加载过程在运行程序之前会全部完成，而现代操作系统使用惰性加载机制，即程序执行期间需要加载的代码或数据片段才会加载，要真正理解代码和数据的惰性加载是如何工作的，必须更多地了解分页和交换的机制，这是我们将来讨论<strong>内存虚拟化</strong>时要涉及的主题。</p><p>将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作。必须为程序的<strong>运行时栈</strong> (run-time stack) 分配一些内存。C 程序使用<strong>栈存放局部变量、函数参数和返回地址</strong>。操作系统也可能为程序的<strong>堆</strong> (heap) 分配一些内存。在 C 程序中，<strong>堆用于显式请求的动态分配数据</strong>。程序通过调用 malloc()来请求这样的空间，并通过调用 free()来明确地释放它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随着程序运行，通过 malloc()库 API 请求更多内存，操作系统可能会参与分配更多内存给进程，以满足这些调用。</p><p>操作系统还将执行一些其他初始化任务，特别是与<strong>输入/输出</strong> (I/O) 相关的任务。例如，在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符 (file descriptor)，用于标准输入、输出和错误，这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。</p><p>通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 I/O 设置相关的其他工作，OS 现在终于为程序执行搭好了舞台。然后它有最后一项任务：启动程序，在入口处运行，即 main()。通过跳转到 main() 例程，OS 将 CPU 的控制权转移到新创建的进程中，从而程序开始执行。</p><h2 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h2><p>既然已经了解了进程是什么，以及它大致是如何创建的，让我们来谈谈进程在给定时间可能处于的不同状态 (state)。简而言之，进程的三个基本状态为：</p><ul><li><strong>就绪 (Ready)</strong>：在创建过程之后，该过程进入就绪状态，即该过程被加载到主存储器中。此处的进程已准备就绪，可以运行，并且正在等待获取 CPU 时间以执行该进程，就绪进程将维护在一个队列中。</li><li><strong>运行 (Running)</strong>：进程获得 CPU 时间片，真正开始运行。</li><li><strong>阻塞 (Blocked)</strong>：一个进程正在等待某一事件 (例如请求 I/O 或等待 I/O 完成等) 而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</li></ul><p><img src="process-state-3.png" alt="process-state"></p><div class="note info">            <p>为了完整性，有时会定义<strong>新建 (New/Create)</strong> 以及<strong>终止 (Terminated)</strong> 两个额外的状态。</p>          </div><p>支持<strong>虚拟内存</strong>的系统中的进程可以使用两个其他状态，在这两种状态下，进程都存储在辅助存储器（通常是硬盘） 上。</p><ul><li>挂起就绪 (Suspended Ready)</li><li>挂起阻塞 (Suspended Blocked)</li></ul><p>简单的理解，当进程就绪或阻塞时，将会加入到一个队列，如果这个队列实际存在物理内存中，则是正常的状态；如果这个队列实际存在于硬盘上，则会附加一个<strong>挂起</strong>的标志，表示当前进程已经不在内存中。</p><p><img src="process-state.png" alt="process-state"></p><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><p>操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的信息。例如，</p><ul><li>记录某个进程信息的数据结构</li><li>为所有就绪的进程保留某种进程列表</li><li>以某种方式跟踪被阻塞的进程</li></ul><p>以下展示了 xv6 内核中每个进程的信息类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the registers xv6 will save and restore to stop and subsequently restart a process </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> eip;</span><br><span class="line"> <span class="keyword">int</span> esp;</span><br><span class="line"> <span class="keyword">int</span> ebx;</span><br><span class="line"> <span class="keyword">int</span> ecx;</span><br><span class="line"> <span class="keyword">int</span> edx;</span><br><span class="line"> <span class="keyword">int</span> esi;</span><br><span class="line"> <span class="keyword">int</span> edi;</span><br><span class="line"> <span class="keyword">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the different states a process can be in</span></span><br><span class="line"><span class="keyword">enum</span> proc_state &#123; UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">                RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the information xv6 tracks about each process</span></span><br><span class="line"><span class="comment">// including its register context and state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *mem; <span class="comment">// Start of process memory</span></span><br><span class="line">    uint sz; <span class="comment">// Size of process memory</span></span><br><span class="line">    <span class="keyword">char</span> *kstack; <span class="comment">// Bottom of kernel stack</span></span><br><span class="line">    <span class="comment">// for this process</span></span><br><span class="line">    <span class="keyword">enum</span> proc_state state; <span class="comment">// Process state</span></span><br><span class="line">    <span class="keyword">int</span> pid; <span class="comment">// Process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line">    <span class="keyword">void</span> *chan; <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">    <span class="keyword">int</span> killed; <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// Open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span> <span class="comment">// Current directory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// Switch here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// Trap frame for the</span></span><br><span class="line">    <span class="comment">// current interrupt</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>除了一些常规进程信息，寄存器上下文 (context) 需要额外注意一下：对于不运行的进程，context 将保存其寄存器的内容。当一个进程停止时，它的寄存器将被保存到这个内存位置，通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程，这称为上下文切换。</p><p>“真正的”操作系统中存在类似的进程结构，如 Linux、macOS X 或 Windows。通常称之为<strong>进程控制块 (Process Control Block, PCB)</strong>，PCB 是计算机操作系统用来存储有关进程的所有信息的数据结构，每个进程都有一个 PCB 结构。</p><ul><li>创建 (初始化或安装) 进程后，操作系统将为其创建一个相应的进程控制块。</li><li>在进程状态转换期间，将更新 PCB 中的信息（寄存器上下文）。</li><li>当进程终止时，其 PCB 返回到从中提取新 PCB 的池中。</li></ul><p>PCB 的作用是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。PCB 必须保存在受到保护的内存区域中，在某些操作系统中，PCB 放置在进程内核栈的开头。</p><div class="note info">            <p>在 Linux 中，PCB 结构为 task_struct 结构体。</p>          </div><h1 id="机制受限直接执行"><a class="markdownIt-Anchor" href="#机制受限直接执行"></a> 机制：受限直接执行</h1><p>为了虚拟化 CPU，操作系统需要用某种方式让多任务共享物理 CPU，让他们看起来像是同时运行。基本思想很简单：运行一个进程一段时间，然后切换其他进程运行一段时间，如此轮换。通过以这种方式<strong>时分共享 CPU</strong>实现了虚拟化。</p><p>首先我们看看程序是如何在 CPU 上<strong>直接执行</strong>的，大致流程如下：</p><ol><li>在进程列表中为其创建一个进程条目；</li><li>为其分配一些内存；</li><li>将程序代码 (可执行文件) 加载到内存中；</li><li>执行一些初始化任务 (如根据 argc/argv 设置程序栈)</li><li>找到入口点 (main() 函数) 并跳转到那里进行执行。</li><li><strong>(程序代码) 执行 main() 代码，并通过 return 返回</strong>。</li><li>释放进程内存，并从进程列表中清除该进程条目。</li></ol><p>上述的过程很简单，除了加粗的过程是我们的程序可以决定的，其余过程均是操作系统完成的。在这个过程中，很明显有两个问题需要考虑：</p><ol><li><strong>操作系统如何确保程序不做我们不想让它做的事情</strong>。如果没有安全限制，一个恶意程序很快就可以破坏整个系统。</li><li><strong>操作系统如何主动切换不同的进程</strong>。如果不能主动切换，程序代码永远不返回岂不是操作系统再也拿不回硬件的控制权。</li></ol><p>由于有上述两个问题需要处理，因此操作系统虚拟化 CPU 的底层机制称为<strong>受限直接执行 (limited direct access)</strong>。</p><h2 id="处理器模式"><a class="markdownIt-Anchor" href="#处理器模式"></a> 处理器模式</h2><p>为了解决第一个问题，<strong>硬件提供了不同的执行模式来协助操作系统</strong>：</p><ul><li>用户模式 (User mode) ：应用程序不能完全访问硬件资源。</li><li>内核模式 (Kernel mode) ：应用程序可以做任何事情，操作系统就运行在这种模式下。</li></ul><p>如果用户需要执行某种特权操作 (磁盘读写、创建进程、分配更多内存、进程间通信) 怎么办？这依靠操作系统提供的<strong>系统调用 (System Call)</strong>。</p><p>要执行系统调用，程序必须执行一个特定的 <code>trap</code> 指令。这个指令会跳转到内核程序并且将特权级改为 Kernel mode，这样就可以执行任何指令了。执行完毕后，OS 会调用一个特定的 <code>return-from-trap</code> 指令，这个指令会将程序返回到用户程序并且将特权级改为 User mode。</p><p>操作系统在启动时会初始化一个 trap 指令表，用来记住每个系统调用的处理代码地址。当系统调用执行时，就会转到这个地址运行系统调用对应的程序。</p><p><img src="kernel-user-mode.png" alt="kernel-user-mode"></p><h2 id="进程间切换"><a class="markdownIt-Anchor" href="#进程间切换"></a> 进程间切换</h2><p>如果一个进程在 CPU 上运行，这就意味着操作系统没有运行。如果操作系统没有运行，它便什么也不能做。像一个哲学问题，操作系统如何重新获得 CPU 的控制权 (regain control) ，以便它可以在进程之间切换？答案很简单：<strong>时钟中断 (timer interrupt)</strong>。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序 (interrupt handler) 会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p><p>当操作系统获得控制权之后，切换到哪个进程是由调度程序 (scheduler) 决定的，但如果决定进行切换，OS 就会执行一些底层代码，即所谓的<strong>上下文切换 (context switch)</strong>。操作系统要做的就是为当前正在执行的进程保存一些寄存器的值 (到它的内核栈) ，并为即将执行的进程恢复一些寄存器的值 (从它的内核栈)。</p><p>通过切换栈，内核在进入切换代码调用时，是一个进程 (被中断的进程) 的上下文，在返回时，是另一进程 (即将执行的进程) 的上下文。当操作系统最终执行 <code>return-from-trap</code> 时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</p><p><img src="context-switch.png" alt="context-switch"></p><h1 id="策略进程调度"><a class="markdownIt-Anchor" href="#策略进程调度"></a> 策略：进程调度</h1><p>现在已经有了运行进程的底层机制——上下文切换，那么还需要一些上层策略来决定当发生切换时应该选择哪个进程进行切换，这称之为<strong>进程调度/CPU 调度 (CPU Scheduling)</strong>。</p><h2 id="基本调度思想"><a class="markdownIt-Anchor" href="#基本调度思想"></a> 基本调度思想</h2><h3 id="先来先服务-fcfs"><a class="markdownIt-Anchor" href="#先来先服务-fcfs"></a> 先来先服务 (FCFS)</h3><p>先到先服务 (First Come First Service, FCFS) 是最基本的算法，也称为先进先出 (FIFO) 。</p><h3 id="最短任务优先-sjf"><a class="markdownIt-Anchor" href="#最短任务优先-sjf"></a> 最短任务优先 (SJF)</h3><p>最短任务优先 (Shortest Job First, SJF) 的策略是：先运行最短的任务，然后是次短的任务，如此下去。</p><h3 id="最短完成时间优先-stcf"><a class="markdownIt-Anchor" href="#最短完成时间优先-stcf"></a> 最短完成时间优先 (STCF)</h3><p>最短完成时间优先 (Shortest Time-to-Completion First, STCF) 或抢占式最短作业优先 (Preemptive Shortest Job First, PSJF) 的策略是向 SJF 添加抢占，每当新工作进入系统时，确定剩余工作和新工作中谁的剩余时间更少，然后调度该工作。</p><h3 id="轮转-rr"><a class="markdownIt-Anchor" href="#轮转-rr"></a> 轮转 (RR)</h3><p>轮转调度 (Round Robin, RR) 的基本思想很简单：RR 在一个时间片 (time slice，有时称为调度量子，scheduling quantum) 内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。因此，RR 有时被称为时间切片 (time-slicing) 。</p><div class="note info">            <p>时间片长度必须是时钟中断周期的倍数。因此，如果时钟中断是每 10ms 中断一次，则时间片可以是 10ms、20ms 或 10ms 的任何其他倍数。</p>          </div><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><table><thead><tr><th>方法</th><th>是否抢占</th></tr></thead><tbody><tr><td>FIFO</td><td>非抢占</td></tr><tr><td>SJF</td><td>非抢占</td></tr><tr><td>PSJF/STCF</td><td>抢占</td></tr><tr><td>RR</td><td>抢占</td></tr></tbody></table><h2 id="实用调度方法"><a class="markdownIt-Anchor" href="#实用调度方法"></a> 实用调度方法</h2><h3 id="多级反馈队列-mlfq"><a class="markdownIt-Anchor" href="#多级反馈队列-mlfq"></a> 多级反馈队列 (MLFQ)</h3><p>多级反馈队列 (Multi-level Feedback Queue, MLFQ)<br>MLFQ 的两条基本规则。</p><ul><li>规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A (不运行 B) 。</li><li>规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。</li><li>规则 3：工作进入系统时，放在最高优先级 (最上层队列) 。</li><li>规则 4a：工作用完整个时间片后，降低其优先级 (移入下一个队列) 。</li><li>规则 4b：如果工作在其时间片以内主动释放 CPU，则优先级不变。</li><li>规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li><li>规则 4：一旦工作用完了其在某一层中的时间配额 (无论中间主动放弃了多少次 CPU) ，就降低其优先级 (移入低一级队列) 。</li></ul><p>MLFQ 有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ 可以同时满足各种工作的需求：</p><ul><li>对于短时间运行的交互型工作，获得类似于 SJF/STCF 的很好的全局性能，</li><li>同时对长时间运行的 CPU 密集型负载也可以公平地、不断地稳步向前。</li></ul><p>因此，许多系统使用某种类型的 MLFQ 作为自己的基础调度程序，包括类 BSD UNIX 系统、Solaris 以及 Windows NT 和其后的 Window 系列操作系统。</p><h3 id="比例份额调度"><a class="markdownIt-Anchor" href="#比例份额调度"></a> 比例份额调度</h3><p>比例份额 (proportional-share) 调度程序，有时也称为公平份额 (fair-share) 调度程序。比例份额算法基于一个简单的想法：<strong>调度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。</strong></p><p>彩票调度背后是一个非常基本的概念：彩票数 (ticket) 代表了进程 (或用户或其他) 占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p><h2 id="多处理器调度"><a class="markdownIt-Anchor" href="#多处理器调度"></a> 多处理器调度</h2><p>目前为止都讨论的单处理器调度的算法，然而多处理器如今已经司空见惯。操作系统应该如何在多 CPU 上调度工作？会遇到什么新问题？已有的技术依旧适用吗？是否需要新的思路？</p><h3 id="多处理器架构"><a class="markdownIt-Anchor" href="#多处理器架构"></a> 多处理器架构</h3><h3 id="单队列调度"><a class="markdownIt-Anchor" href="#单队列调度"></a> 单队列调度</h3><h3 id="多队列调度"><a class="markdownIt-Anchor" href="#多队列调度"></a> 多队列调度</h3><h3 id="linux-多处理器调度"><a class="markdownIt-Anchor" href="#linux-多处理器调度"></a> Linux 多处理器调度</h3><p>有趣的是，在构建多处理器调度程序方面，Linux 社区一直没有达成共识。一直以来，存在 3 种不同的调度程序：</p><ul><li>O(1) 调度程序：采用多队列，基于优先级（类似 MLFQ），随时间推移改变进程的优先级，然后调度最高优先级进程，来实现各种调度目标。</li><li>完全公平调度程序 (CFS)：采用多队列，CFS 是确定的比例调度方法（类似彩票调度）</li><li>BF 调度程序 (BFS)：采用单队列，基于比例调度，但采用了其他方法。</li></ul><p>目前 CFS 是 Linux 内核的默认调度程序。更多可以参考 <a href="https://wongxingjun.github.io/2015/09/09/Linux%E5%86%85%E6%A0%B8-CFS%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/" target="_blank" rel="noopener">Linux内核-CFS进程调度器</a>。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Condition Variables</title>
      <link href="/2020/08/01/os-cv/"/>
      <url>/2020/08/01/os-cv/</url>
      
        <content type="html"><![CDATA[<p>通过硬件和操作系统支持，正确组合可以实现锁。然而，锁并不是线程并发程序设计所需的唯一原语。具体来说，在很多情况下，线程需要检查某一条件 (condition) 满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕，这常被称为 join()。这种等待如何实现呢？</p><a id="more"></a><h1 id="为什么需要条件变量"><a class="markdownIt-Anchor" href="#为什么需要条件变量"></a> 为什么需要条件变量？</h1><p>下图是一个父线程想要等待子线程的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">    <span class="comment">// XXX how to indicate we are done?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// XXX how to wait for child?</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们期待这样的输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent: begin</span><br><span class="line">child</span><br><span class="line">parent: end</span><br></pre></td></tr></table></figure><p>但几乎任何时候（不是必然）你都会得到这样的输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent: begin</span><br><span class="line">parent: end</span><br></pre></td></tr></table></figure><p>这是因为此时<strong>父线程没有任何等待子线程执行完毕的机制</strong>，父线程结束时的 return 语句触发 exit()，所以将整个进程退出，导致子线程也退出，这就是根本没有 child 输出的原因。</p><p>等待另一个线程执行完毕并不是一个陌生的场景，在使用锁的场景中，竞争线程需要等待执行线程完毕才能执行，这里也是一样，我们可以在父线程上<strong>自旋等待</strong>，自旋时判断子线程是否执行完毕，当子线程执行完毕时，才继续执行父线程。</p><p>因此，我们可以利用一个全局变量和自旋来实现 join()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> done = <span class="number">0</span>;  <span class="comment">// always read done variable form memory instead of cpu cache</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">    done = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (done == <span class="number">0</span>)</span><br><span class="line">        ;  <span class="comment">// spin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，这样的程序得到了我们期待的输出。</p><div class="note info">            <p><strong>关键问题：如何等待一个条件？</strong><br>多线程程序中，一个线程等待某些条件是很常见的。简单的方案是自旋直到条件满足，这是极其低效的，某些情况下甚至是错误的。</p>          </div><h1 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h1><p>线程可以使用条件变量来等待一个条件变成真。条件变量是一个显式队列，当某些执行状态（条件）不满足时，线程可以把自己加入队列，等待该条件。当另外某个线程改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。</p><p>想一下我们解决自旋锁的思路。我们通过队列和 wait/weak 机制改进了自旋锁，如果把锁是否被占有视为一个条件，那么竞争线程等待执行线程的过程和父线程等待子线程几乎是一模一样的过程。不同之处在于条件变量允许用户自定义执行状态，用户可以针对不同的执行条件，管理不同的队列（条件变量），从而完成等待的逻辑控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;  <span class="comment">// 声明并初始化一个条件变量</span></span><br><span class="line">pthread_cond_wait(<span class="keyword">pthread_cond_t</span> *c, <span class="keyword">pthread_mutex_t</span> *m);  <span class="comment">// 线程要睡眠时调用</span></span><br><span class="line">pthread_cond_signal(<span class="keyword">pthread_cond_t</span> *c);  <span class="comment">// 唤醒等待在某个条件变量上的睡眠线程</span></span><br></pre></td></tr></table></figure><h1 id="实现-join-语义"><a class="markdownIt-Anchor" href="#实现-join-语义"></a> 实现 join 语义</h1><p>我们使用 POSIX 的条件变量来改进上一节的自旋等待代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    done = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;c);  <span class="comment">// 唤醒 c 队列里的睡眠等待线程</span></span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="keyword">while</span> (done == <span class="number">0</span>) &#123;  <span class="comment">// 子线程未完成，父线程加入睡眠等待队列。</span></span><br><span class="line">        pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">    thr_exit();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    thr_join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两种情况需要考虑：</p><ol><li>父线程创建出子线程，但自己继续运行，然后马上调用 thr_join() 等待子线程。在这种情况下，它会先获取锁，检查条件，然后调用 wait() 让自己睡眠（从 15 行跳出）。子线程最终得以运行，打印出 child，并调用 thr_exit() 函数唤醒父线程。最后，父线程会运行（从 wait() 调用返回并持有锁），释放锁（17 行），</li><li>子线程在创建后立刻运行，设置变量 done 为 1，调用 signal 函数唤醒其他线程（这里没有其他线程），然后结束。父线程运行后调用 thr_join() 时，发现 done 已经是 1 了，就直接返回。</li></ol><p>join() 函数为何要使用 while？在本例中虽然使用 if 也是可以的，但使用 while 总是好的，详细原因下节会说明。</p><p>使用条件变量必须加锁吗？是的！我们假设线程在发信号和等待时都不加锁。如果父线程调用 thr_join()，然后检查完 done 的值为 0，然后试图睡眠。但在调用 wait 进入睡眠之前，父进程被中断。子线程修改变量 done 为 1，发出信号，同样没有等待线程。父线程再次运行时，就会长眠不醒。</p><table><thead><tr><th style="text-align:center">父线程</th><th style="text-align:center">子线程</th></tr></thead><tbody><tr><td style="text-align:center">if (done == 0)</td><td style="text-align:center">↓</td></tr><tr><td style="text-align:center">↓</td><td style="text-align:center">done = 1</td></tr><tr><td style="text-align:center">↓</td><td style="text-align:center">pthread_cond_signal(&amp;c); // invalid call</td></tr><tr><td style="text-align:center">pthread_cond_wait(&amp;c, &amp;m); // sleep forever</td><td style="text-align:center">↓</td></tr></tbody></table><div class="note info">            <p>调用 signal 和 wait 时要持有锁：</p><ul><li>请在调用 signal 时尽量持有锁，尽管也有一些情况可以不加锁，但这应当避免。</li><li>调用 wait 必须持有锁，这是 wait 的语义强制要求的。因为 wait 调用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。</li></ul>          </div><h1 id="生产者消费者问题"><a class="markdownIt-Anchor" href="#生产者消费者问题"></a> 生产者/消费者问题</h1><p>生产者/消费者 (producer/consumer) 问题，也叫作有界缓冲区 (bounded buffer) 问题。</p><p>假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费。很多实际的系统中都会有这种场景。例如，在多线程的网络服务器中，一个生产者将 HTTP 请求放入工作队列（即有界缓冲区），消费线程从队列中取走请求并处理。</p><p><strong>因为有界缓冲区是共享资源，所以我们必须通过同步机制来访问它，以免产生竞态条件。</strong></p><h2 id="单值缓冲区"><a class="markdownIt-Anchor" href="#单值缓冲区"></a> 单值缓冲区</h2><p>首先需要一个共享缓冲区，让生产者放入数据，消费者取出数据。简单起见，我们就拿一个整数来做缓冲区（你当然可以想到用一个指向数据结构的指针来代替），两个内部函数将值放入缓冲区，从缓冲区取值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// initially, empty</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(count == <span class="number">0</span>);</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    buffer = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(count == <span class="number">1</span>);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过锁和条件变量可以定义以下生产者和消费者线程代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">        &#125;</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;c);</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;c,&amp;m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;c);</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当只有一个生产者和一个消费者时，正常运行。然而当有两个以上消费者时，将会出现两个问题。</p><h3 id="mesa-语义问题"><a class="markdownIt-Anchor" href="#mesa-语义问题"></a> Mesa 语义问题</h3><p>第一个问题产生的原因很简单：在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 被生产者唤醒后，但在它运行之前，缓冲区的状态被 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 改变了。发信号给线程只是唤醒它们，暗示状态发生了变化，但并不会保证在它运行之前状态一直是期望的情况。信号的这种释义常称为 Mesa 语义，为了纪念以这种方式建立条件变量的首次研究。另一种释义是 Hoare 语义，虽然实现难度大，但是会保证被唤醒线程立刻执行。实际上，几乎所有系统都采用了 Mesa 语义。</p><p>由于 Mesa 语义，我们要记住一条关于条件变量的简单规则：<strong>总是使用 while 循环</strong>。虽然有时候不需要重新检查条件，但这样做总是安全的，做了就开心了。</p><p>因此，解决这个问题的方式就是将上述两个 if 改成 while 即可。当消费者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 被唤醒后，立刻再次检查共享变量。如果缓冲区此时为空，消费者就会回去继续睡眠，当然生产者中相应的 if 也需要改为 while。限于篇幅，代码不再列出。</p><h3 id="唤醒不明确问题"><a class="markdownIt-Anchor" href="#唤醒不明确问题"></a> 唤醒不明确问题</h3><p>假设两个消费者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 先运行，都睡眠了。生产者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开始运行，在缓冲区放入一个值，唤醒了一个消费者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并开始睡眠。现在是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 消费者马上要运行，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都等待在同一个条件变量上。</p><p>消费者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 消费了缓冲区，然后开始发信号，但是应该唤醒哪个线程呢？因为消费者已经清空了缓冲区，很显然，应该唤醒生产者。但是，如果它唤醒了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（这绝对是可能的，取决于等待队列是如何管理的），问题就出现了：</p><ul><li>消费者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 消费了缓冲区，发完信号唤醒了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就回去睡眠了。</li><li>消费者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{C2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 醒过来，发现队列为空，又继续回去睡眠。</li><li>生产者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 自从放入值后一直在睡眠。</li></ul><p>3 个线程都在睡眠，显然是一个缺陷!</p><p><strong>信号显然必须更有指向性，消费者不应该唤醒消费者，而应该只唤醒生产者，反之亦然</strong>。解决方案也很简单：使用两个条件变量，而不是一个，以便在系统状态改变时正确地发出信号，明确哪类线程应该唤醒。</p><h3 id="最终生产者消费者方案"><a class="markdownIt-Anchor" href="#最终生产者消费者方案"></a> 最终生产者/消费者方案</h3><p>最终的解决方案如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// initially, empty</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> empty = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> fill = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    assert(count == <span class="number">0</span>);</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    buffer = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(count == <span class="number">1</span>);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> loops = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;empty, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;fill);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> loops = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;fill, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;empty);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check command line args */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;producer-num&gt; &lt;consumer-num&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create producers and consumers */</span></span><br><span class="line">    <span class="keyword">long</span> pro_num = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">long</span> con_num = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">pthread_t</span> producers[pro_num], consumers[con_num];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pro_num; i++) &#123;</span><br><span class="line">        pthread_create(&amp;producers[i], <span class="literal">NULL</span>, producer, (<span class="keyword">void</span> *)con_num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con_num; i++) &#123;</span><br><span class="line">        pthread_create(&amp;consumers[i], <span class="literal">NULL</span>, consumer, (<span class="keyword">void</span> *)pro_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() thread should do */</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者线程当缓存区满时等待条件变量 empty 为真，否则生产一个值并发信号给条件变量 fill。</li><li>消费者线程当缓存区空时等待条件变量 fill 为真，否则消费一个值并发信号给条件变量 empty。</li></ul><h2 id="多值缓冲区"><a class="markdownIt-Anchor" href="#多值缓冲区"></a> 多值缓冲区</h2><p>我们现在有了可用的生产者/消费者方案，但不太通用。我们最后的修改是提高并发和效率。具体来说，增加更多缓冲区槽位，这样在线程睡眠之前可以生产/消费多个值。单个生产者和消费者时，这种方案因为上下文切换少，提高了效率。多个生产者和消费者时，它甚至支持并发生产和消费，从而提高了并发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer[MAX];</span><br><span class="line"><span class="keyword">int</span> add = <span class="number">0</span>;   <span class="comment">// produce index</span></span><br><span class="line"><span class="keyword">int</span> use = <span class="number">0</span>;    <span class="comment">// consume index</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// initially, empty</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> empty = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> fill = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    buffer[add] = value;</span><br><span class="line">    add = (add + <span class="number">1</span>) % MAX;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = buffer[use];</span><br><span class="line">    use = (use + <span class="number">1</span>) % MAX;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> loops = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == MAX) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;empty, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;fill);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> loops = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;fill, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;empty);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check command line args */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;producer-num&gt; &lt;consumer-num&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create producers and consumers */</span></span><br><span class="line">    <span class="keyword">long</span> pro_num = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">long</span> con_num = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">pthread_t</span> producers[pro_num], consumers[con_num];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pro_num; i++) &#123;</span><br><span class="line">        pthread_create(&amp;producers[i], <span class="literal">NULL</span>, producer, (<span class="keyword">void</span> *)con_num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; con_num; i++) &#123;</span><br><span class="line">        pthread_create(&amp;consumers[i], <span class="literal">NULL</span>, consumer, (<span class="keyword">void</span> *)pro_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() thread should do */</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了一个小技巧，让生产者线程数量 * 单位线程产出值数量（消费者线程数量） = 消费者线程数量 * 单位线程消费值数量（生产者线程数量），使得最终产生和消费数量相同，能正常退出进程。否则由于睡眠线程的存在，进程将不会退出。</p><h1 id="覆盖条件"><a class="markdownIt-Anchor" href="#覆盖条件"></a> 覆盖条件</h1><p>现在再来看条件变量的另一个例子，假设我们需要实现一个多线程的内存分配库。伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesLeft = MAX_HEAP_SIZE;  <span class="comment">// how many bytes of the heap are free?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cond_t</span> c;   <span class="comment">// need lock and condition too</span></span><br><span class="line"><span class="keyword">mutex_t</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="keyword">while</span> (bytesLeft &lt; size) Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    <span class="keyword">void</span> *ptr = ...;  <span class="comment">// get mem from heap</span></span><br><span class="line">    bytesLeft -= size;</span><br><span class="line">    Pthread_mutex_unlock(&amp;m);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;m);</span><br><span class="line">    bytesLeft += size;</span><br><span class="line">    Pthread_cond_signal(&amp;c);  <span class="comment">// whom to signal??</span></span><br><span class="line">    Pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，当线程调用进入内存分配代码时，它可能会因为内存不足而等待。相应的，线程释放内存时，会发信号说有更多内存空闲。但是，代码中有一个问题：应该唤醒哪个等待线程（可能有多个线程）？</p><p>假设目前没有空闲内存，线程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 调用 allocate(100)，接着线程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">T_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 调用 allocate(10) 请求较少的内存。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">T_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都等待在条件并睡眠，因为没有足够的空闲内存来满足它们的请求。这时第三个线程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">T_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 调用了 free(50)。遗憾的是它可能不会唤醒申请 10 字节的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">T_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 线程，假设它发信号唤醒 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，由于内存不够，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 重新睡眠等待。因为不知道唤醒哪个（或哪些）线程，所以上述代码无法正常工作。</p><p>解决方案也很直接：<strong>用 pthread_cond_broadcast() 代替上述代码中的 pthread_cond_signal()，以广播代替单播唤醒所有的等待线程</strong>。这确保了所有应该唤醒的线程都被唤醒。当然，不利的一面是可能会影响性能，因为不必要地唤醒了其他许多等待的线程，它们本来（还）不应该被唤醒。这些线程被唤醒后，重新检查条件，马上再次睡眠。</p><p>这种条件变量叫作<strong>覆盖条件 (covering condition)</strong>，因为它能覆盖所有需要唤醒线程的场景（保守策略）。</p><div class="note info">            <p>在单个条件变量的生产者/消费者问题中，也可以使用这种方法，但在那个场景下两个条件变量是更好的选择。一般来说，如果你发现程序只有改成广播信号时才能工作（但你认为不需要），可能是程序有缺陷，修复它！但在上述内存分配的例子中，广播可能是最直接有效的方案。</p>          </div><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>我们看到了引入锁之外的另一个重要同步原语：条件变量。当某些程序状态不符合要求时，通过允许线程进入睡眠状态（线程阻塞），条件变量使我们能够漂亮地解决许多重要的同步问题，包括著名的（仍然重要的）生产者/消费者问题，以及覆盖条件。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> Lock </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Locks</title>
      <link href="/2020/07/31/os-lock/"/>
      <url>/2020/07/31/os-lock/</url>
      
        <content type="html"><![CDATA[<p>并发编程的一个基本问题：我们总是希望原子式 (atomic) 的执行一系列指令。但由于处理器的中断，我们总是做不到。能够直接解决这个问题的一个办法就是使用锁。程序员在源代码中加锁，放在需要保护的关键区 (critical sections) 周围，保证这些关键部分代码能够像单条原子指令一样执行。</p><a id="more"></a><h1 id="锁的基本思想"><a class="markdownIt-Anchor" href="#锁的基本思想"></a> 锁的基本思想</h1><p><strong>更新共享变量</strong>是一种典型的关键代码段。尽管在源代码层次看起来只有一行，但编译后却产生多条指令，这是一个读-改-写模式，在其中任意一步发生线程调度，都可能造成错误的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance = balance + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其他的关键区还可能是：为共享的链表增加一个元素，或对共享结构的复杂更新操作。</p><p>锁的解决思路如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock_t</span> mutex; <span class="comment">// some globally-allocated lock ’mutex’</span></span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>锁就是一个变量，这个变量主要保存了锁在某一时刻的状态，它</p><ul><li>要么是<strong>可用的</strong>，表示没有线程持有锁，</li><li>要么是<strong>被占用的</strong>，表示有一个线程持有锁，并且正处于关键区。</li></ul><p>lock 和 unlock 的语义十分简单：</p><ul><li>lock() 尝试获取锁，如果没有其他线程持有该锁，则该线程获取锁，并进入关键区。</li><li>unlock() 由持有锁的线程调用，一旦被释放，锁就变为可用状态。</li></ul><p>锁为程序员提供了最小的调度控制，使得程序员可以获得一些控制权，通过给关键区加锁，<strong>保证关键区内代码只有一个线程活跃</strong>，因此将原本由操作系统调度的混乱状态变得可控。</p><h1 id="pthread-锁"><a class="markdownIt-Anchor" href="#pthread-锁"></a> Pthread 锁</h1><p>POSIX 库将锁称之为互斥量 (mutual exclusion, mutex)，有时也叫 Pthread 锁，被用来提供线程之间的互斥。</p><p>使用起来也十分简单，大致代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock); </span><br></pre></td></tr></table></figure><h1 id="锁的实现和性能"><a class="markdownIt-Anchor" href="#锁的实现和性能"></a> 锁的实现和性能</h1><p>我们已经从程序员的角度，对锁如何工作有了一定的理解。那如何实现一个锁呢？我们需要什么<strong>硬件</strong>支持？需要什么<strong>操作系统</strong>的支持？</p><p>在实现锁之前，我们应该首先明确目标，为了评价锁是否能工作（并工作得好），我们应该先设立一些标准。</p><ul><li>第一是锁的基本任务，即提供<strong>互斥 (mutual exclusion)</strong>。锁是否能够有效阻止多个线程进入关键区？</li><li>第二是<strong>公平性 (fairness)</strong>。当锁可用时，是否每一个竞争线程有公平的机会抢到锁？从线程角度看就是，是否有竞争锁的线程由于一直无法竞争到锁而饿死。</li><li>最后是<strong>性能 (performance)</strong>。使用锁之后增加的时间开销有多少，不同的场景有何区别？</li></ul><h1 id="基于硬件的锁"><a class="markdownIt-Anchor" href="#基于硬件的锁"></a> 基于硬件的锁</h1><p>在本节中，我们仅用硬件支持，看看能实现到什么程度？</p><h2 id="控制中断"><a class="markdownIt-Anchor" href="#控制中断"></a> 控制中断</h2><p>最早提供的互斥解决方案之一，就是在关键区关闭中断，这个解决方案是为单处理器系统开发的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然由于是中断导致线程的切换，那我们就解决掉中断。很好，既然解决不了问题，就解决提出问题的人。</p><p>假设我们运行在这样一个单处理器系统上。通过在进入临界区之前关闭中断（使用特殊的硬件指令），可以保证临界区的代码不会被中断，从而原子地执行。结束之后，我们重新打开中断（同样通过硬件指令），程序正常运行。</p><p>这种方法简单，但却存在许多问题，主要包括：</p><ol><li>要求我们允许所有调用线程执行特权操作（打开关闭中断），并信任这种机制不会被滥用。无条件的信任一个用户程序是一个糟糕的选择。</li><li>这种方案不支持多处理器。</li><li>关闭中断导致中断丢失，可能会导致严重的系统问题。例如磁盘或者网络刚好来了数据，请求中断怎么办？</li></ol><h2 id="自旋锁-一次失败的尝试"><a class="markdownIt-Anchor" href="#自旋锁-一次失败的尝试"></a> 自旋锁 - 一次失败的尝试</h2><p>首先我们实现一个锁，<strong>用一个变量标记锁是否被持有</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>) <span class="comment">// TEST the flag</span></span><br><span class="line">    ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">1</span>; <span class="comment">// now SET it!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看互斥性，很明显可以分析出，该方法不满足互斥性。如果 Thread 1 在进入 lock 之后，设置 flag 为 1 之前被中断调度，那么由于此时 flag 仍然为 0，则其他线程同样可以进入 lock。</p><h2 id="基于-test-and-set-的自旋锁"><a class="markdownIt-Anchor" href="#基于-test-and-set-的自旋锁"></a> 基于 Test-And-Set 的自旋锁</h2><p>造成上述结果的原因是 test-and-set 这个过程不是原子的！基于这种概念，一些系统提供了一种最简单的硬件支持是测试并设置指令 (test-and-set instruction)，也叫作原子交换 (atomic exchange)。在 x86 上是 xchg 原子交换指令。我们用如下的 C 代码片段来定义 test-and-set 指令做了什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *old_ptr; <span class="comment">// fetch old value at old_ptr</span></span><br><span class="line">    *old_ptr = <span class="keyword">new</span>; <span class="comment">// store 'new' into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>test-and-set 指令做了下述事情。它返回 old_ptr 指向的旧值，同时更新为 new 的新值。当然，关键是这些代码原子地执行。因此我们之前的锁可以变为以下内容，其实只有 lock() 部分做了一点修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 test-and-set 指令，我们已经实现了一把最简单的<strong>自旋锁 (spin lock)</strong>。竞争锁的线程在 CPU 周期内一直自旋，直到锁可用。</p><p><strong>自旋锁在单 CPU 的情况下需要抢占式的调度器</strong>，即不断通过时钟中断一个线程，运行其他线程。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</p><p>我们来分析一下这个锁：</p><p>首先是互斥性，由于 test-and-set 指令，不难分析，在 lock 的过程要么线程进入关键区并设置 flag 为 1，要么一直等待自旋，直到 flag 为 0。</p><p>下一个标准是公平性，自旋锁对于等待线程的公平性如何呢？能够保证一个等待线程会进入临界区吗？答案是<strong>自旋锁不提供任何公平性保证</strong>。实际上，自旋的线程在竞争条件下可能会永远自旋。</p><p>最后是性能，性能可以分为两方面考虑：</p><ul><li>在单 CPU 的情况下，性能开销相当大。假设 N 个线程有一个进入关键区，则竞争锁的 N-1 个线程都会在放弃 CPU 之前自旋一个时间片。</li><li>在多 CPU 上，自旋锁性能不错。假设线程 A 在 CPU 1，线程 B 在 CPU 2 竞争同一个锁。线程 A（CPU 1）占有锁时，线程 B 竞争锁就会自旋（在 CPU 2 上）。然而，临界区一般都很短，因此很快锁就可用，然后线程 B 获得锁。自旋等待其他处理器上的锁，并没有浪费很多 CPU 周期，因此效果不错。</li></ul><h2 id="基于-compare-and-swap-的自旋锁"><a class="markdownIt-Anchor" href="#基于-compare-and-swap-的自旋锁"></a> 基于 Compare-And-Swap 的自旋锁</h2><p>某些系统提供了另一个硬件原语，名为 CAS。以下是这条指令的 C 语言伪代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (actual == expected)</span><br><span class="line">        *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> actual;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>有了 CAS 指令，就可以实现一个锁，类似于用 TAS 那样。例如，我们只要用下面的代码替换 lock() 函数即可实现一个自旋锁，其余代码不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><div class="note info">            <p>CAS 比 TAS 更强大，但就实现一个简单的自旋锁方面，两者是等价的。</p>          </div><h2 id="基于-ll-sc-的自旋锁"><a class="markdownIt-Anchor" href="#基于-ll-sc-的自旋锁"></a> 基于 LL-SC 的自旋锁</h2><p>一些平台提供了实现临界区的一对指令。例如 MIPS 架构中，链接加载（load-linked）和条件式存储（store-conditional）可以用来配合使用，实现其他并发结构。</p><figure class="highlight c"><figcaption><span>Load Linkd and Stroe conditional</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadLinked</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StoreConditional</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no one has updated *ptr since the LoadLinked to <span class="keyword">this</span> address) &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Load-Linked 指令和典型加载指令类似，关键区别来自 Store-Conditional 指令，只有上一次加载的地址在期间都没有更新时，才会成功，（同时更新刚才 Load-Linked 的地址的值）。成功时，Store-Conditional 返回 1，并将 ptr 指向的值更新为 value。失败时，返回 0，并且不会更新值。</p><p>我们可以用链接加载和条件存储指令改写我们的 lock() 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (LoadLinked(&amp;lock-&gt;flag) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin until it's zero</span></span><br><span class="line">        <span class="keyword">if</span> (StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// if set-it-to-1 was a success: all done</span></span><br><span class="line">                <span class="comment">// otherwise: try it all over again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程调用 lock()，执行了链接的加载指令，返回 0。在执行条件式存储之前，中断产生了，另一个线程进入 lock 的代码，也执行链接式加载指令，同样返回 0。现在，两个线程都执行了链接式加载指令，将要执行条件存储。重点是只有一个线程能够成功更新标志为 1，从而获得锁；第二个执行条件存储的线程会失败（因为另一个线程已经成功执行了条件更新），必须重新尝试获取锁。</p><h2 id="基于-fetch-and-add-的自旋锁"><a class="markdownIt-Anchor" href="#基于-fetch-and-add-的自旋锁"></a> 基于 Fetch-And-Add 的自旋锁</h2><p>最后一个硬件原语是获取并增加（fetch-and-add）指令，它能原子地返回特定地址的旧值，并且让该值自增一。获取并增加的 C 语言伪代码如下：</p><p>我们使用 fetch-and-add 指令可以实现一个 ticket 锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ticket;</span><br><span class="line">    <span class="keyword">int</span> turn;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>不是用一个值，这个解决方案使用了 ticket 和 turn 变量来构建锁。基本操作也很简单：如果线程希望获取锁，首先对一个 ticket 值执行一个原子的获取并相加指令。这个值作为该线程的“turn”（顺位，即 myturn）。根据全局共享的 lock-&gt;turn 变量，当某一个线程的（myturn== turn）时，则轮到这个线程进入临界区。unlock 则是增加 turn，从而下一个等待线程可以进入临界区。</p><p>ticket 锁的过程类似于<strong>排队</strong>，每个竞争的线程 lock() 相当于入队，而 unlock() 相当于出队。不同于之前的方法：本方法能够<strong>保证所有线程都能抢到锁</strong>。只要一个线程获得了 ticket 值，最终一定会被调度。</p><h2 id="总结自旋过多"><a class="markdownIt-Anchor" href="#总结自旋过多"></a> 总结：自旋过多</h2><p>基于硬件的锁简单（只有几行代码）而且有效，这也是任何好的系统或者代码的特点。但是某些场景下，这些解决方案会效率低下。</p><p>如何让锁不会不必要地自旋，浪费 CPU 时间？只有硬件支持是不够的。我们还需要操作系统支持！</p><h1 id="基于硬件和-os-的锁"><a class="markdownIt-Anchor" href="#基于硬件和-os-的锁"></a> 基于硬件和 OS 的锁</h1><p>通过基于硬件的锁，有没有发现，每一个线程无论处于获取锁或是竞争锁的状态，都在不停的运行。</p><p>通过操作系统的支持，我们可以给线程定义状态：</p><ul><li>运行 (Running)：线程可以执行并正在执行，该线程此时获得 CPU 时间片。</li><li>就绪 (Ready)：线程可以执行，但由于线程调度机制，此时并没有获取 CPU 时间片。</li><li>阻塞 (Blocked)：线程不可以执行，因此也不参与线程调度，需要被唤醒后才能重新参与线程调度。</li></ul><h2 id="yield-系统调用让出替代自旋"><a class="markdownIt-Anchor" href="#yield-系统调用让出替代自旋"></a> yield 系统调用：让出替代自旋</h2><p>硬件支持让我们有了很大的进展：我们已经实现了有效、公平（通过 ticket 锁）的锁。但是，问题仍然存在：如果临界区的线程发生上下文切换，其他线程只能一直自旋，等待被中断的（持有锁的）进程重新运行。有什么好办法？</p><p>第一种简单友好的方法就是，<strong>在要自旋的时候放弃 CPU 时间片</strong>。在这种方法中，我们假定操作系统提供原语 yield()，线程可以调用它主动放弃 CPU，从而让其他线程运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        yield(); <span class="comment">// give up the CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程可以处于 3 种状态之一（运行、就绪和阻塞）。yield() 系统调用能够让运行 (running) 态变为就绪 (ready) 态，从而允许其他线程运行。因此，线程让出本质上是线程<strong>取消调度 (deschedules)</strong> 了它自己。</p><p>考虑在单 CPU 上运行两个线程。在这个例子中，基于 yield 的方法十分有效。如果许多线程（例如 100 个）反复竞争一把锁，则竞争线程将会一直处于 run-and-yield 模式，虽然比自旋好多了，但也浪费了不少时间在上下文切换的场景上。</p><p>更糟的是，我们还没有考虑饿死的问题。一个线程可能一直处于让出的循环，而其他线程反复进出临界区。</p><h2 id="使用队列睡眠替代自旋"><a class="markdownIt-Anchor" href="#使用队列睡眠替代自旋"></a> 使用队列：睡眠替代自旋</h2><p>前面一些方法的真正问题是存在太多的偶然性。调度程序决定如何调度。如果调度不合理，线程或者一直自旋（第一种方法），或者立刻让出 CPU（第二种方法）。无论哪种方法，都可能造成浪费或饿死。</p><p>因此，我们必须显式地施加某种控制，决定锁释放时谁能抢到锁。为了做到这一点，我们需要操作系统的更多支持，并需要一个<strong>队列</strong>来保存等待锁的线程。</p><p>简单起见，我们利用 Solaris 提供的支持，它提供了两个调用</p><ul><li>park() 能够让调用线程睡眠</li><li>unpark(threadID) 则会唤醒 threadID 标识的线程</li></ul><p>可以用这两个调用来实现锁，<strong>让调用者在获取不到锁时睡眠，在锁可用时被唤醒</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> guard;</span><br><span class="line">    <span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ;  <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">        m-&gt;flag = <span class="number">1</span>;  <span class="comment">// lock is acquired</span></span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">        park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ;  <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = <span class="number">0</span>;  <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(queue_remove(m-&gt;q));  <span class="comment">// hold lock (for next thread!)</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解决方案中存在一个问题，假如在 park() 调用之前，刚好遇到该线程 park()，这时切换到另一个线程（比如持有锁的线程），如果该线程随后释放了锁。那当第一个线程重新获得时间片后，接下来又会执行一个 park()，因此可能会永远睡下去。这种问题有时称为<strong>唤醒/等待竞争 (wakeup/waiting race)</strong>。为了避免这种情况，我们需要额外的工作。</p><h2 id="linux-系统实现-两段锁"><a class="markdownIt-Anchor" href="#linux-系统实现-两段锁"></a> Linux 系统实现 - 两段锁</h2><p>例如，Linux 提供了 futex，它类似于 Solaris 的接口，但提供了更多内核功能。具体来说，每个 futex 都关联一个特定的物理内存位置，也有一个事先建好的内核队列。调用者通过 futex 调用（见下面的描述）来睡眠或者唤醒。</p><p>具体来说有两个调用：</p><ul><li>调用 futex_wait(address, expected) 时，如果 address 处的值等于 expected，就会让调线程睡眠。否则，调用立刻返回。</li><li>调用 futex_wake(address) 唤醒等待队列中的一个线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span><span class="params">(<span class="keyword">int</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">/* Bit 31 was clear, we got the mutex (this is the fastpath) */</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_bit_test_set(mutex, <span class="number">31</span>) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    atomic_increment(mutex);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (atomic_bit_test_set(mutex, <span class="number">31</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            atomic_decrement(mutex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We have to wait now. First make sure the futex value</span></span><br><span class="line"><span class="comment">        we are monitoring is truly negative (i.e. locked). */</span></span><br><span class="line">        v = *mutex;</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        futex_wait(mutex, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_unlock</span><span class="params">(<span class="keyword">int</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Adding 0x80000000 to the counter results in 0 if and only if</span></span><br><span class="line"><span class="comment">    there are not other interested threads */</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_add_zero(mutex, <span class="number">0x80000000</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* There are other threads waiting for this mutex,</span></span><br><span class="line"><span class="comment">    wake one of them up. */</span></span><br><span class="line">    futex_wake(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码利用一个整数，同时记录锁<strong>是否被持有</strong>（整数的最高位），以及<strong>等待者的个数</strong>（整数的其余所有位）。因此，如果锁是负的，它就被持有（因为最高位被设置，该位决定了整数的符号）。这段代码的有趣之处还在于，它展示了如何优化常见的情况，即没有竞争时：只有一个线程获取和释放锁，所做的工作很少（获取锁时测试和设置的原子位运算，释放锁时原子的加法）。</p><p>Linux 采用的这种古老的锁方案多年来不断被采用，现在也称为<strong>两段锁 (two-phase lock)</strong>。两阶段锁意识到自旋可能很有用，尤其是在很快就要释放锁的场景。因此，两阶段锁的第一阶段会先自旋一段时间，希望它可以获取锁。但是，如果第一个自旋阶段没有获得锁，第二阶段调用者会睡眠，直到锁可用。上文的 Linux 锁就是这种锁，不过只自旋一次；更常见的方式是在循环中自旋固定的次数，然后使用 futex 睡眠。</p><h1 id="线程锁总结"><a class="markdownIt-Anchor" href="#线程锁总结"></a> 线程锁总结</h1><p>通过锁的方式可以实现关键区的原子性，评价一个锁的指标至少包括互斥性和公平性。</p><p>仅通过<strong>硬件原子原语</strong>的支持，我们可以实现简单的<strong>自旋锁</strong>，自旋锁在多 CPU 的情况下性能不错，但过多的自旋总是浪费宝贵的 CPU 时间片。</p><p>通过借助<strong>操作系统系统调用</strong>的支持，我们可以实现更有效率的锁，其中：</p><ul><li>通过 <strong>yield 系统调用</strong>可以显式让竞争线程在自旋时切换，节省 CPU 时间，但会导致频繁切换线程上下文的问题，或者线程反复让出 CPU 时间片而最终饿死自己。这种方式本质上是让线程在 running 和 ready 之间反复切换。</li><li>通过借助 <strong>wait/wake 函数和队列</strong>，可以让竞争线程在自旋时睡眠，并加入一个睡眠队列，通过逐个唤醒竞争线程来让竞争线程获得 CPU 时间片。这种方式本质上是让线程在 running 和 ready 状态之外还可以处于 block 状态，由于 block 线程不参与线程调度，因此节省了时间片。</li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
            <tag> Lock </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tool-Jmeter</title>
      <link href="/2020/07/29/tool-jmeter/"/>
      <url>/2020/07/29/tool-jmeter/</url>
      
        <content type="html"><![CDATA[<p>Apache JMeter™ 是一个 100％ 纯 Java 编写的开源应用软件，主要用于接口功能测试和压力测试。</p><a id="more"></a><h1 id="起步"><a class="markdownIt-Anchor" href="#起步"></a> 起步</h1><h2 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h2><p>在 <a class="btn" href="https://jmeter.apache.org" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>官网          </a> 可以下载编译好的二进制 JMeter 软件，解压即可使用，根据不同的操作系统，在 <code>bin/</code> 文件夹下选择对应的 jmeter 可执行文件即可开启。</p><p>JMeter 运行需要 Java 8+ 环境，并且依赖于 <code>JAVA_HOME</code> 或 <code>JRE_HOME</code> 环境变量。</p><h2 id="使用流程"><a class="markdownIt-Anchor" href="#使用流程"></a> 使用流程</h2><p>使用 JMeter 需要以下几个流程：</p><ol><li>构建测试计划<ul><li>使用浏览器或者应用程序录制测试方法：可以直接将请求录制下来，例如测试计划为访问一个网页。</li><li>手动构建测试计划：确保了解主要的概念之后，自己定制计划，能够更灵活的控制。</li></ul></li><li>加载启动测试：测试计划构建完成之后，配置测试参数，最后通过<strong>命令行模式</strong>启动测试计划。</li><li>分析测试结果：负载测试完成后，您可以使用HTML报告分析负载测试。</li></ol><p>JMeter 是支持中文的，启动 JMeter 后，点击 Options -&gt; Choose Language 来选择语言。</p><div class="note error">            <p>不要使用 GUI 模式运行测试脚本！</p>          </div><h2 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h2><p>上述三个流程，主要内容是<strong>制定测试计划</strong>，构建测试计划的基本步骤为 <a href="https://jmeter.apache.org/usermanual/build-test-plan.html" target="_blank" rel="noopener">Building a Test Plan</a> 对于不同类型的测试计划，需要阅读对应文档，主要的计划类型包括：</p><ul><li><a href="https://jmeter.apache.org/usermanual/build-web-test-plan.html" target="_blank" rel="noopener">Web Test Plan</a></li><li>Advanced Web Test Plan</li><li>JDBC</li><li>FTP</li><li>JMS Point-to-Point</li><li>JMS Topic</li><li>LDAP</li><li>LDAP Extended</li><li>WebServices (SOAP)</li></ul><h1 id="构建测试计划"><a class="markdownIt-Anchor" href="#构建测试计划"></a> 构建测试计划</h1><p>测试计划描述了 JMeter 在运行时将执行的一系列步骤。完整的测试计划将由一个或多个线程组、逻辑控制器、样本生成控制器、侦听器、计时器、断言和配置元素组成。</p><h1 id><a class="markdownIt-Anchor" href="#"></a> </h1>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP Socket Programming</title>
      <link href="/2020/07/26/network-udp/"/>
      <url>/2020/07/26/network-udp/</url>
      
        <content type="html"><![CDATA[<p>本文内容介绍基本的 UDP 编程接口，并给出几个基本的 UDP Echo Server 的实现。</p><a id="more"></a><p><img src="udp.svg" alt="udp"></p>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Socket </tag>
            
            <tag> I/O </tag>
            
            <tag> Networking </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP Socket Programming</title>
      <link href="/2020/07/26/network-tcp/"/>
      <url>/2020/07/26/network-tcp/</url>
      
        <content type="html"><![CDATA[<p>本文内容介绍基本的 TCP 编程接口，并给出几个基本的 TCP Echo Server 的实现。</p><a id="more"></a><p>下图是 TCP 编程过程中所需要的函数，以及在程序运行过程中的 TCP 状态变化。</p><p><img src="tcp.svg" alt="tcp"></p><h1 id="基本-tcp-编程接口"><a class="markdownIt-Anchor" href="#基本-tcp-编程接口"></a> 基本 TCP 编程接口</h1><h2 id="socket-函数"><a class="markdownIt-Anchor" href="#socket-函数"></a> socket 函数</h2><figure class="highlight c"><figcaption><span>socket - create an endpoint for communication</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new socket of type TYPE in domain DOMAIN, using</span></span><br><span class="line"><span class="comment">   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.</span></span><br><span class="line"><span class="comment">   Returns a file descriptor for the new socket, or -1 for errors.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>socket 创建一个通信 endpoint，并返回一个指向该端点的文件描述符 (file descriptor)。三个参数逐步缩小 socket 类型的范围。</p><h3 id="通信域协议族-domain"><a class="markdownIt-Anchor" href="#通信域协议族-domain"></a> 通信域/协议族 - Domain</h3><p><code>domain</code> 指定了通信域，决定了通信时使用的协议族。常用的有：</p><ul><li>AF_UNIX, AF_LOCAL</li><li>AF_INET</li><li>AF_INET6</li><li>AF_NETLINK</li><li>AF_PACKET</li></ul><div class="note info">            <p>协议族中的 AF_* 前缀意为 Address Family，4.x BSD 使用 PF_* 前缀，意为 Protocol Family。然而两者是完全相同的，标准推荐使用 AF_* 前缀。</p><figure class="highlight c"><figcaption><span>/include/linux/socket.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">......... some uninteresting details</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_LOCAL        AF_LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET         AF_INET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_AX25         AF_AX25</span></span><br><span class="line">.....same pattern</span><br></pre></td></tr></table></figure><p>The AF_ALG protocol type was added in Linux 2.6.38.</p>          </div><h3 id="通信类型协议类型-type"><a class="markdownIt-Anchor" href="#通信类型协议类型-type"></a> 通信类型/协议类型 - Type</h3><p><code>type</code> 指定了通信的类型，从而决定了通信的语义，如可靠性，序列性，等。常用的类型有：</p><ul><li>SOCK_STREAM</li><li>SOCK_DGRAM</li><li>SOCK_RAW</li><li>SOCK_PACKET 废弃，不应该在新软件中使用</li></ul><div class="note info">            <p>一些类型可能并没有在所有的协议族中实现。</p>          </div><h3 id="通信协议-protocol"><a class="markdownIt-Anchor" href="#通信协议-protocol"></a> 通信协议 - Protocol</h3><ul><li><code>protocol</code> 指定了通信时使用的具体协议，通常对于给定的协议族和类型，只会有一种协议与之对应，这种情况下 protocol 值设为 0 即可，然而当该类型有多种协议可选时，必须指定协议。</li></ul><h3 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h3><p>创建一个合适的 socket 是第一步，因此要明确自己的需求。</p><ul><li>如果需要捕获一个帧 (2 层) 的全部信息，应当使用底层的接口 AF_PACKE<ul><li>如果你需要自己处理帧头，指明类型为 SOCK_RAW</li><li>如果帧头交由系统自动处理指明类型为 SOCK_DGRAM</li><li>如果你明确需要只接收某种二层以上协议的帧，指明第三个协议参数，例如 ETH_P_IP 或者 ETH_P_ARP 表示只接收 IP 帧或者 ARP 帧，否则可以使用 ETH_P_ALL 来表示收发所有协议的帧。</li></ul></li><li>如果你需要处理 IP 层信息，可以使用较高的接口 AF_INET，进行 IP 包收发。<ul><li>如果你需要自己处理 IP 头，则指明类型为 SOCK_RAW</li><li>如果你只关心应用层信息，并且想使用 TCP，则指明类型为 SOCK_STREAM，协议默认为 0 即可。</li><li>如果你只关心应用层信息，并且想使用 UDP，则指明类型为 SOCK_DGRAM，协议默认为 0 即可。</li></ul></li></ul><figure class="highlight c"><figcaption><span>socket()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Full frame including the link-level header (L2 header + L2 payload)</span></span><br><span class="line"><span class="keyword">int</span> sock_raw_all = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));   <span class="comment">// All Kinds of Frame</span></span><br><span class="line"><span class="keyword">int</span> sock_raw_ip = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IP));     <span class="comment">// Only IP Frame</span></span><br><span class="line"><span class="keyword">int</span> sock_raw_arp = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ARP));   <span class="comment">// Only ARP Frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cooked packets with the link-level header removed.</span></span><br><span class="line"><span class="keyword">int</span> sock_dgram_ip = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));     <span class="comment">// Only IP Packet</span></span><br><span class="line"><span class="keyword">int</span> sock_dgram_arp = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_ARP_IP));     <span class="comment">// Only ARP Packet</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IP packet (IP header + IP payload)</span></span><br><span class="line"><span class="keyword">int</span> sock_ip = socket(AF_INET, SOCK_RAW, <span class="number">0</span>);         <span class="comment">// same with sock_dgram_ip</span></span><br><span class="line"><span class="keyword">int</span> sock_ip_tcp = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">int</span> sock_ip_udp = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);</span><br><span class="line"><span class="keyword">int</span> sock_ip_icmp = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// L4 packet or flow</span></span><br><span class="line"><span class="keyword">int</span> sock_udp = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);     <span class="comment">// (UDP header + UDP payload)</span></span><br><span class="line"><span class="keyword">int</span> sock_tcp = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);     <span class="comment">// (TCP header + TCP payload)</span></span><br></pre></td></tr></table></figure><h2 id="bind-函数"><a class="markdownIt-Anchor" href="#bind-函数"></a> bind 函数</h2><figure class="highlight c"><figcaption><span>bind - bind a name to a socket</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Give the socket FD the local address ADDR (which is LEN bytes long).  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>bind 操作将给 sockfd 分配一个长度为 addrlen 的 addr 地址。第二个参数 sockaddr 是一个通用 socket 地址，然而任何具体的 bind 调用必须要将指向特定协议的套接字地址结构的指针进行强制类型转换，变成指向某个通用套接字地址结构的指针。以下是三种常用结构体。</p><ul><li>struct sockaddr     - 通用 socket 地址</li><li>struct sockaddr_in  - Internet socket 地址 (IPv4)</li><li>struct sockaddr_in6 - Internet socket 地址 (IPv6)</li></ul><p>以下是<strong>通用套接字地址</strong>和<strong>IPv4套接字地址</strong>的结构体定义。</p><figure class="highlight c"><figcaption><span>Socket address structures</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing a generic socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);      <span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure describing an Internet socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;<span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr'.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">        __SOCKADDR_COMMON_SIZE -</span><br><span class="line">        <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">        <span class="keyword">sizeof</span> (struct in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，强制类型转换的代码需要写成以下形式，即：将 address 的地址强行按照 sockaddr 结构体的方式读取。避免了编译器报不兼容指针类型的错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span>     <span class="comment">/* IPv4 socket address structure */</span></span><br><span class="line">bind(sockfd, (structure sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address))</span><br></pre></td></tr></table></figure><h2 id="listen-函数"><a class="markdownIt-Anchor" href="#listen-函数"></a> listen 函数</h2><figure class="highlight c"><figcaption><span>listen - listen for connections on a socket</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare to accept connections on socket FD.</span></span><br><span class="line"><span class="comment">   N connection requests will be queued before further requests are refused.</span></span><br><span class="line"><span class="comment">   Returns 0 on success, -1 for errors.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>listen() 将 sockfd 指向的套接字标记为一个<strong>被动套接字 (passive socket)</strong>，即该套接字不能主动发起连接，内核应当接收指向该套接字的连接请求，该套接字使用 accept() 来接收请求。</p><p>一旦应用程序调用了 listen，TCP 协议栈将为所有传入连接执行<strong>三次握手</strong>，这些连接在内核中排队，然后 accept 从队列中检索下一个连接并返回它。backlog 定义为<strong>由未处理连接构成的队列可能增长到的最大长度</strong>。当队列已满时，客户端可能会收到一个 ECONNREFUSED 错误。</p><div class="note info">            <p>虽然 listen 表面上作为监听之意，但 listen 并不是一个阻塞的调用，它将会立即返回调用程序。</p>          </div><h2 id="accept-函数"><a class="markdownIt-Anchor" href="#accept-函数"></a> accept 函数</h2><figure class="highlight c"><figcaption><span>accept, accept4 - accept a connection on a socket</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd 是一个通过 socket 创建的套接字，该套接字已经 bind 到一个本地地址，并且经过 listen 设置为等待连接的状态。</p><p>addr 是一个 指向 sockaddr 类型的指针，该结构需要使用 addrlen 指针指明长度。当连接建立时，该地址结构将会<strong>填充对端的信息</strong>。</p><p>addrlen 必须正确的初始化为对端 socket 地址结构的字节数，如果你看到对端地址都是 0.0.0.0 之类的信息，请立即检查初始化是否正确。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socklen_t = clientlen;</span><br><span class="line">// ...</span><br><span class="line">clientlen = sizeof(struct sockaddr_in);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);</span><br></pre></td></tr></table></figure><div class="note info">            <p>执行完三次握手的连接将会在内核中排队，然而如果内核队列中没有连接时，则应用程序会阻塞在 accept 这里，等待一个连接的到来。</p>          </div><h2 id="connect-函数"><a class="markdownIt-Anchor" href="#connect-函数"></a> connect 函数</h2><figure class="highlight c"><figcaption><span>connect - initiate a connection on a socket</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>如果说一个被动套接字通过 listen 和 accept 过程才能完成一个连接的话，那么这个连接是对端通过 connect 主动发起的。通常 TCP 服务器端有一个监听套接字，而客户端使用 connect 发起连接。</p><p>connect 函数将使用 sockfd 套接字发起连接，其对端的地址为 addr 指针指向的结构，该地址大小为 addrlen。与 accept 不同，connect 函数的地址大小参数不是一个指针。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span> serveraddr;</span><br><span class="line"><span class="comment">// ... initialize serveraddr</span></span><br><span class="line">connect(sockfd, (<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span> *)&amp;serveraddr, sizeof(serveraddr);</span><br></pre></td></tr></table></figure><div class="note info">            <p>connect 意为连接之意，我们知道 UDP 并没有连接的概念，只有类似 TCP 的流协议才有连接的语义，然而这并不意味着 UDP 套接字 (SOCK_DGRAM) 类型不可以使用 connect，虽然这确实是较少使用的场景，但仍然是可能的，我们将在后续文章再讨论这种特殊情况。</p><blockquote><p>If  the  socket  sockfd is of type SOCK_DGRAM, then addr is the address to which datagrams are sent by default, and the only address from which datagrams are received.</p></blockquote>          </div><h2 id="close-函数"><a class="markdownIt-Anchor" href="#close-函数"></a> close 函数</h2><figure class="highlight c"><figcaption><span>close - close a file descriptor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>close 函数用来关闭套接字，并终止 TCP 连接。</p><p>close 并非立即终止 TCP 连接，其默认行为是把该套接字标记成已关闭，然后立即返回到调用进程，此时该套接字描述符不能再由调用进程使用（不能再进行读写），然后 TCP 将继续尝试发送已排队等待发送到对端的数据，数据发送完毕后发送正常的 TCP 连接终止序列。</p><p>父进程关闭己连接套接字只是导致相应描述符的引用数值减 1 ，如果引用计数值仍大于 0，则这个 close 调用并不引发 TCP 的终止序列。如果我们确实想在某个 TCP 连接发送一个 FIN 终止序列，那么可以改用 shutdown 函数。</p><h1 id="tcp-数据读写接口"><a class="markdownIt-Anchor" href="#tcp-数据读写接口"></a> TCP 数据读写接口</h1><h2 id="read-write-函数"><a class="markdownIt-Anchor" href="#read-write-函数"></a> read &amp; write 函数</h2><figure class="highlight c"><figcaption><span>read - read from a file descriptor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p>read 函数尝试从文件描述符 fd 读取最多 count 字节的数据到 buf 中。</p><ul><li>成功：返回读取字节数</li><li>失败：返回 -1</li><li>到达文件末尾：返回 0</li></ul><figure class="highlight c"><figcaption><span>write - write to a file descriptor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p>read 函数尝试向文件描述符 fd 读取最多 count 字节的数据到 buf 中。</p><p>write 函数尝试从 buf 缓冲区提取最多 count 字节的数据写入到文件描述符 fd 中。</p><ul><li>成功：返回写入字节数</li><li>失败：返回 -1</li></ul><div class="note info">            <p>read/write 的返回值和 count 不相等并不是一个错误，这个现象的原因在于内核中用于套接宇的缓冲区可能已达到极限，这时候需要多次调用 read/wirte 函数才能读写剩余的字节。</p>          </div><h2 id="readn-writen-函数"><a class="markdownIt-Anchor" href="#readn-writen-函数"></a> readn &amp; writen 函数</h2><p>为了解决 read 和 write 的潜在问题，可以通过自己定义的函数来确保每次都读取 n 个字节数据。</p><figure class="highlight angelscript"><figcaption><span>Read n bytes from a descriptor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ssize_t readn(<span class="built_in">int</span> fd, <span class="built_in">void</span> *vptr, size_t n) &#123;</span><br><span class="line">    size_t nleft;</span><br><span class="line">    ssize_t nread;</span><br><span class="line">    char *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                nread = <span class="number">0</span>; <span class="comment">/* and call read() again */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line"></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft); <span class="comment">/* return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><figcaption><span>Write n bytes to a descriptor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ssize_t writen(<span class="built_in">int</span> fd, <span class="keyword">const</span> <span class="built_in">void</span> *vptr, size_t n) &#123;</span><br><span class="line">    size_t nleft;</span><br><span class="line">    ssize_t nwritten;</span><br><span class="line">    <span class="keyword">const</span> char *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">                nwritten = <span class="number">0</span>; <span class="comment">/* and call write() again */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="number">-1</span>); <span class="comment">/* error */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        ptr += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="tcp-客户服务器示例"><a class="markdownIt-Anchor" href="#tcp-客户服务器示例"></a> TCP 客户/服务器示例</h1><h2 id="基本-tcp-服务器"><a class="markdownIt-Anchor" href="#基本-tcp-服务器"></a> 基本 TCP 服务器</h2><p>服务端每次只和一个客户端进行连接，接收客户端消息，并将消息再<strong>原封不动</strong>发送回去，然后断开客户端连接，并准备下一次连接。</p><figure class="highlight c"><figcaption><span>Basic TCP Echo Server</span><a href="/downloads/code/socket/tcpserv01.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *msg)</span> </span>{</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> listenfd;                  <span class="comment">/* listening socket */</span></span><br><span class="line">    <span class="keyword">int</span> connfd;                    <span class="comment">/* connection socket */</span></span><br><span class="line">    <span class="keyword">int</span> portno;                    <span class="comment">/* port to listen on */</span></span><br><span class="line">    <span class="keyword">int</span> clientlen;                 <span class="comment">/* byte size of client's address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span> <span class="comment">/* server's addr */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span> <span class="comment">/* client addr */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostp</span>;</span>         <span class="comment">/* client host info */</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];             <span class="comment">/* message buffer */</span></span><br><span class="line">    <span class="keyword">char</span> *hostaddrp;               <span class="comment">/* dotted decimal host addr string */</span></span><br><span class="line">    <span class="keyword">int</span> optval;                    <span class="comment">/* flag value for setsockopt */</span></span><br><span class="line">    <span class="keyword">int</span> n;                         <span class="comment">/* message byte size */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check command line args */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    portno = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* socket: create a socket */</span></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>) error(<span class="string">"ERROR opening socket"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setsockopt: Handy debugging trick that lets</span></span><br><span class="line"><span class="comment">     * us rerun the server immediately after we kill it;</span></span><br><span class="line"><span class="comment">     * otherwise we have to wait about 20 secs.</span></span><br><span class="line"><span class="comment">     * Eliminates "ERROR on binding: Address already in use" error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    optval = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;optval,</span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* build the server's internet address */</span></span><br><span class="line">    bzero((<span class="keyword">char</span> *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;         <span class="comment">/* we are using the Internet */</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* accept reqs to any IP addr */</span></span><br><span class="line">    serveraddr.sin_port = htons((<span class="keyword">unsigned</span> <span class="keyword">short</span>)portno); <span class="comment">/* port to listen on */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind: associate the listening socket with a port */</span></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        error(<span class="string">"ERROR on binding"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* listen: make it a listening socket ready to accept connection requests */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">5</span>) &lt; <span class="number">0</span>) <span class="comment">/* allow 5 requests to queue up */</span></span><br><span class="line">        error(<span class="string">"ERROR on listen"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* main loop: wait for a connection request, echo input line,</span></span><br><span class="line"><span class="comment">       then close connection. */</span></span><br><span class="line">    clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">/* accept: wait for a connection request */</span></span><br><span class="line">        connfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) error(<span class="string">"ERROR on accept"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* gethostbyaddr: determine who sent the message */</span></span><br><span class="line">        hostp = gethostbyaddr((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;clientaddr.sin_addr.s_addr,</span><br><span class="line">                              <span class="keyword">sizeof</span>(clientaddr.sin_addr.s_addr), AF_INET);</span><br><span class="line">        <span class="keyword">if</span> (hostp == <span class="literal">NULL</span>) error(<span class="string">"ERROR on gethostbyaddr"</span>);</span><br><span class="line">        hostaddrp = inet_ntoa(clientaddr.sin_addr);</span><br><span class="line">        <span class="keyword">if</span> (hostaddrp == <span class="literal">NULL</span>) error(<span class="string">"ERROR on inet_ntoa\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server established connection with %s (%s)\n"</span>, hostp-&gt;h_name,</span><br><span class="line">               hostaddrp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read: read input string from the client */</span></span><br><span class="line">        bzero(buf, BUFSIZE);</span><br><span class="line">        n = read(connfd, buf, BUFSIZE);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) error(<span class="string">"ERROR reading from socket"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server received %d bytes: %s"</span>, n, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* write: echo the input string back to the client */</span></span><br><span class="line">        n = write(connfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) error(<span class="string">"ERROR writing to socket"</span>);</span><br><span class="line"></span><br><span class="line">        close(connfd);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>客户端从标准输入接收一个字符串，发送给服务器，并将服务器的回复进行打印。</p><figure class="highlight c"><figcaption><span>Basic TCP Echo Client</span><a href="/downloads/code/socket/tcpcli01.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * echoclient.c - A simple connection-based client</span></span><br><span class="line"><span class="comment"> * usage: echoclient &lt;host&gt; &lt;port&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * error - wrapper for perror</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *msg)</span> </span>{</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sockfd, portno, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">server</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *hostname;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check command line arguments */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;hostname&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    hostname = argv[<span class="number">1</span>];</span><br><span class="line">    portno = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* socket: create the socket */</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) error(<span class="string">"ERROR opening socket"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* gethostbyname: get the server's DNS entry */</span></span><br><span class="line">    server = gethostbyname(hostname);</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR, no such host as %s\n"</span>, hostname);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* build the server's Internet address */</span></span><br><span class="line">    bzero((<span class="keyword">char</span> *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    bcopy((<span class="keyword">char</span> *)server-&gt;h_addr, (<span class="keyword">char</span> *)&amp;serveraddr.sin_addr.s_addr,</span><br><span class="line">          server-&gt;h_length);</span><br><span class="line">    serveraddr.sin_port = htons(portno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* connect: create a connection with the server */</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        error(<span class="string">"ERROR connecting"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get message line from the user */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter msg: "</span>);</span><br><span class="line">    bzero(buf, BUFSIZE);</span><br><span class="line">    fgets(buf, BUFSIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write: send the message line to the server */</span></span><br><span class="line">    n = write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) error(<span class="string">"ERROR writing to socket"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read: print the server's reply */</span></span><br><span class="line">    bzero(buf, BUFSIZE);</span><br><span class="line">    n = read(sockfd, buf, BUFSIZE);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) error(<span class="string">"ERROR reading from socket"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Echo from server: %s"</span>, buf);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="并发服务器"><a class="markdownIt-Anchor" href="#并发服务器"></a> 并发服务器</h2><p>待补充…</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li>man page</li><li>UNP</li><li><a href="https://github.com/unpbook/unpv13e" target="_blank" rel="noopener">https://github.com/unpbook/unpv13e</a></li><li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f00/www/class24code/" target="_blank" rel="noopener">http://www.cs.cmu.edu/afs/cs/academic/class/15213-f00/www/class24code/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Socket </tag>
            
            <tag> TCP </tag>
            
            <tag> I/O </tag>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O Multiplexing - Select vs Poll vs Epoll</title>
      <link href="/2020/07/24/network-io-multiplexing/"/>
      <url>/2020/07/24/network-io-multiplexing/</url>
      
        <content type="html"><![CDATA[<p>Linux (Unix) 有一条规则就是一切资源都可视为文件，每个进程都有一个文件描述符表，文件描述符可能指向文件、套接字、设备或其他对象。通常情况下系统需要处理众多 I/O 资源，因此会进行一个初始化阶段，然后进入一个等待模式，等待 IO 客户端的请求然后响应它。</p><p>由于 IO 通常是阻塞的，当我们等待一个 IO 的时候无法接收到其他 IO 的请求，简单的解决方案是通过多进程（线程）的方式为每一个 IO 客户端分配独立的进程（线程），该进程（线程）阻塞在某点保持阻塞状态，直到该客户端发来一个请求，才读取并回复它。这对于少量 IO 客户端来说是可以的，但是如果我们想将其扩展到数百个客户端，为每个客户端创建一个进程（线程）可不是一个好主意。</p><a id="more"></a><h1 id="io-多路复用-multiplexing"><a class="markdownIt-Anchor" href="#io-多路复用-multiplexing"></a> IO 多路复用 (Multiplexing)</h1><p>IO 多路复用（或简称 IO 复用）是一种内核提供的对文件描述符进行轮询的机制，这是一种基于事件并发的思想。当内核一旦发现进程指定的一个或多个 IO 条件就绪（输入已经准备好读取，或者描述符已经能够承接更多输出），他就通知进程。IO 多路复用技术通过以下三组系统调用支持：</p><ul><li>select(2)</li><li>poll(2)</li><li>epoll</li></ul><p>IO 复用在以下典型的网络应用场合都发挥了巨大的作用：</p><ul><li>客户处理多个描述符，通常是交互式输入和网络套接字。</li><li>一个 TCP 服务器既要处理监听套接字，又要处理已连接套接字。</li><li>一个服务器既要处理 TCP，又要处理 UDP。</li><li>一个服务器要处理多个服务或多个协议。</li></ul><h1 id="tcp-并发服务器"><a class="markdownIt-Anchor" href="#tcp-并发服务器"></a> TCP 并发服务器</h1><p>我们通过一个 TCP 并发的 Echo Server 来验证 IO 复用，其中：</p><ul><li>客户端负责发送报文</li><li>服务端接收报文并原封不动的将报文返回给客户端</li></ul><p>因此，需要一个程序来模拟多个客户端发送报文，这里采用多线程技术，每一个线程代表一个客户端。并且在所有线程发送完请求后，记录其中消耗的时间。</p><figure class="highlight c"><figcaption><span>Multi Client Simulation</span><a href="/downloads/code/socket/tcpcli11.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBUF 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_MSGS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *msg)</span> </span>{</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// A normal C function that is executed as a thread</span></span><br><span class="line"><span class="comment">// when its name is specified in pthread_create()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *vargp)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> msg[MAXBUF];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span> = {</span><span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create socket and connect to server */</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    connect(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="built_in">sprintf</span>(msg, <span class="string">"Message from client %ld"</span>, (<span class="keyword">long</span>)vargp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_MSGS; i++) {</span><br><span class="line">        <span class="comment">/* write: send the message line to the server */</span></span><br><span class="line">        n = write(sockfd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) error(<span class="string">"ERROR writing to socket"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read: print the server's reply */</span></span><br><span class="line">        bzero(msg, MAXBUF);</span><br><span class="line">        n = read(sockfd, msg, MAXBUF);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) error(<span class="string">"ERROR reading from socket"</span>);</span><br><span class="line">        <span class="comment">// printf("Echo from server: %s\n", msg);</span></span><br><span class="line">    }</span><br><span class="line">    close(sockfd);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    <span class="keyword">long</span> secs_used, micros_used;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; NUM_THREADS; t++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In main: creating thread #%ld\n"</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)t);</span><br><span class="line">        <span class="keyword">if</span> (rc) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() should do */</span></span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; NUM_THREADS; t++) {</span><br><span class="line">        pthread_join(threads[t], <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    secs_used =</span><br><span class="line">        (end.tv_sec - start.tv_sec);  <span class="comment">// avoid overflow by subtracting first</span></span><br><span class="line">    micros_used = ((secs_used * <span class="number">1000000</span>) + end.tv_usec) - (start.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d client send %d*%d messages: %ld micros used\n"</span>, NUM_THREADS,</span><br><span class="line">           NUM_THREADS, NUM_MSGS, micros_used);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="select-系统调用"><a class="markdownIt-Anchor" href="#select-系统调用"></a> Select 系统调用</h1><h2 id="select-函数"><a class="markdownIt-Anchor" href="#select-函数"></a> select 函数</h2><p>select 函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经过一段指定的时间后才唤醒它。</p><p>也就是一说，我们调用 select 告知内核对哪些描述符 (可读、可写或异常) 感兴趣以及超时等待多长时间。其中感兴趣的描述符不局限于套接字，任何描述符都可以使用 select 来测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>最后一个参数 timeout 指针用来设置<strong>超时时间</strong>，这可能有以下三种情况：</p><ul><li>NULL：永远等待，直到有一个描述符准备好后而返回。</li><li>设置一个结构体，其中包含一段时间：最多等待一段固定时间后返回，如果期间有描述符准备好则立即返回。</li><li>设置一个结构体，其中设置为 0：不等待。</li></ul><p>中间的三个参数用来让我们指定内核测试的条件，异常条件使用不多，主要是读写条件。</p><p>其中 fd_set 是一个文件描述符集，通常是一个整数数组，其中每个整数中的每一位对应一个描述符。形象的说，可以将 fd_set 看作是一个比特流，其中每一个比特位对应一个文件描述符：</p><ul><li>如果该比特位为 1，则表示将该位对应的文件描述符加入到这个描述符集。</li><li>如果该比特位为 0，则表示将该位对应的文件描述符移出这个描述符集。</li></ul><p>以下用到四个宏来实现对 fd_set 的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;            <span class="comment">/* clear all bits in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;     <span class="comment">/* turn on the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;     <span class="comment">/* turn off the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">/* is the bit for fd on in fdset? */</span></span><br></pre></td></tr></table></figure><p>nfds 参数指定待测试的描述符个数，通常设置为 <code>maxfd+1</code>，这是因为 select 要对 fd_set 的每一位进行检查，假设 fd_set 有 1024 位，但其实我们只有两个 fd，分别为 3 和 4，那么 select 不需要检测 1024 位，只需要检测 0-4 位即可，所以共 5 个。假设这两个 fd 分别为 100，200，那么很不幸，尽管我们只用到了两个 fd，但 0-200 描述符都需要被测试一遍！这是一个 O(n) 的算法。</p><p>调用 select 函数时，我们指定所关心的描述符在该函数返回时，结果将指示哪些描述符就绪，并且任何未就绪的描述符位都清成 0，因此该函数返i可后，我们使用F} }SE}'F-}测试fd-}t数据类)tj-中的描述符。<br>描述符集内任何一与未就绪描述符对应的位返回时均清成O。<br>我们都得再次把所有描述符集内所关心的位均置为l口</p><p>该函数的返回值表示跨所有描述符集的已就绪的总位数。</p><h2 id="服务器示例"><a class="markdownIt-Anchor" href="#服务器示例"></a> 服务器示例</h2><figure class="highlight c"><figcaption><span>Polling with select</span><a href="/downloads/code/socket/tcpserv_select.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBUF 1500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> buffer[MAXBUF];</span><br><span class="line">    <span class="keyword">int</span> nready, client[FD_SETSIZE];</span><br><span class="line">    <span class="keyword">int</span> i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    fd_set rset, allset;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen, peerlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>, <span class="title">peeraddr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    maxfd = listenfd;</span><br><span class="line">    maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) {</span><br><span class="line">        client[i] = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(listenfd, &amp;allset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        rset = allset;</span><br><span class="line">        nready = select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) {</span><br><span class="line">            addrlen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;addrlen);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client [%s:%d] connected\n"</span>, inet_ntoa(cliaddr.sin_addr),</span><br><span class="line">                   ntohs(((struct sockaddr_in *)&amp;cliaddr)-&gt;sin_port));</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) {  <span class="comment">// save descriptor</span></span><br><span class="line">                <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) {</span><br><span class="line">                    client[i] = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == FD_SETSIZE) {</span><br><span class="line">                perror(<span class="string">"too many clients."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;allset);  <span class="comment">// add new descriptor to set</span></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; maxfd) {</span><br><span class="line">                maxfd = connfd;  <span class="comment">// for select</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi) {</span><br><span class="line">                maxi = i;  <span class="comment">// max index in client[] array</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) {  <span class="comment">// no more readable descriptors</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) {  <span class="comment">// check all clients for data</span></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) {</span><br><span class="line">                peerlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">                getpeername(sockfd, (struct sockaddr *)&amp;peeraddr, &amp;peerlen);</span><br><span class="line">                <span class="keyword">if</span> ((n = read(sockfd, buffer, MAXBUF)) == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// connection closed by client</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client [%s:%d] closed\n"</span>,</span><br><span class="line">                           inet_ntoa(peeraddr.sin_addr),</span><br><span class="line">                           ntohs(((struct sockaddr_in *)&amp;peeraddr)-&gt;sin_port));</span><br><span class="line"></span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    FD_CLR(sockfd, &amp;allset);</span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client [%s:%d] send %ld bytes -&gt; %s\n"</span>,</span><br><span class="line">                           inet_ntoa(peeraddr.sin_addr),</span><br><span class="line">                           ntohs(((struct sockaddr_in *)&amp;peeraddr)-&gt;sin_port),</span><br><span class="line">                           n, buffer);</span><br><span class="line">                    write(sockfd, buffer, n);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="poll-系统调用"><a class="markdownIt-Anchor" href="#poll-系统调用"></a> Poll 系统调用</h1><h2 id="poll-函数"><a class="markdownIt-Anchor" href="#poll-函数"></a> poll 函数</h2><figure class="highlight c"><figcaption><span>wait for some event on a file descriptor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是指向一个结构数组第一个元素的指针。每个数组元素都是一个 pollfd 结构，用于测试每个描述符 fd 的条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;            <span class="comment">/* File descriptor to poll.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> events;  <span class="comment">/* Types of events poller cares about.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> revents; <span class="comment">/* Types of events that actually occurred.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要测试的条件由 events 成员指定，函数在相应的 revents 成员中返回该描述符的状态。</p><table><thead><tr><th>常值</th><th>可用于 events 设置</th><th>可用于 events 结果</th><th>解释</th></tr></thead><tbody><tr><td>POLLIN</td><td></td><td>√</td><td>√</td></tr><tr><td>POLLRDNORM</td><td>√</td><td>√</td><td>普通数据可读</td></tr><tr><td>POLLRDBAND</td><td>√</td><td>√</td><td>优先级带数据可读</td></tr><tr><td>POLLPRI</td><td>√</td><td>√</td><td>高优先级带数据可读</td></tr><tr><td>POLLOUT</td><td>√</td><td>√</td><td>普通数据可写</td></tr><tr><td>POLLRDNORM</td><td>√</td><td>√</td><td>普通数据可写</td></tr><tr><td>POLLRDBAND</td><td>√</td><td>√</td><td>优先级带数据可写</td></tr><tr><td>POLLERR</td><td></td><td>√</td><td>发生错误</td></tr><tr><td>POLLHUP</td><td></td><td>√</td><td>发生挂起</td></tr><tr><td>POLLNVAL</td><td></td><td>√</td><td>描述符不是一个打开的文件</td></tr></tbody></table><p>结构数组中元素的个数是 nfds 参数指定。</p><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight c"><figcaption><span>Polling with poll</span><a href="/downloads/code/socket/tcpserv_poll.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBUF 1500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *msg)</span> </span>{</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, maxi, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXBUF];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    listen(listenfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++) {</span><br><span class="line">        client[i].fd = <span class="number">-1</span>; <span class="comment">/* -1 indicates available entry */</span></span><br><span class="line">    }</span><br><span class="line">    maxi = <span class="number">0</span>; <span class="comment">/* max index into client[] array */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        nready = poll(client, maxi + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) { <span class="comment">/* new client connection */</span></span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client [%s:%d] connected\n"</span>, inet_ntoa(cliaddr.sin_addr),</span><br><span class="line">                   ntohs(((struct sockaddr_in *)&amp;cliaddr)-&gt;sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) {</span><br><span class="line">                    client[i].fd = connfd; <span class="comment">/* save descriptor */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (i == OPEN_MAX) error(<span class="string">"too many clients"</span>);</span><br><span class="line"></span><br><span class="line">            client[i].events = POLLRDNORM;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi) maxi = i; <span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* no more readable descriptors */</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) { <span class="comment">/* check all clients for data */</span></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) {</span><br><span class="line">                <span class="keyword">if</span> ((n = read(sockfd, buf, MAXBUF)) &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) { <span class="comment">/*4connection reset by client */</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        error(<span class="string">"read error"</span>);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) { <span class="comment">/*4connection closed by client */</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    write(sockfd, buf, n);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">/* no more readable descriptors */</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="epoll-系统调用"><a class="markdownIt-Anchor" href="#epoll-系统调用"></a> Epoll* 系统调用</h1><figure class="highlight c"><figcaption><span>epoll - I/O event notification facility</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; <span class="comment">// Since Linux 2.6.8, the size argument is ignored</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>调用 <code>epoll_create</code> 在内核中建立一个 epoll 对象（在 epoll 文件系统中为这个句柄对象分配资源）。</li><li>调用 <code>epoll_ctl</code> 向 epoll 对象中注册套接字，并设置监听的类型。</li><li>调用 <code>epoll_wait</code> 收集发生的事件的连接。</li></ul><h2 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h2><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><h2 id="功能总结"><a class="markdownIt-Anchor" href="#功能总结"></a> 功能总结</h2><table><thead><tr><th>复用方式</th><th>用户态将文件描述符传入内核的方式</th></tr></thead><tbody><tr><td>select</td><td>创建 3 个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。</td></tr><tr><td>poll</td><td>将传入的 struct pollfd 结构体数组拷贝到内核中进行监听。</td></tr><tr><td>epoll</td><td>执行 epoll_create 会在内核的高速 cache 区中建立一颗红黑树以及就绪链表 (该链表存储已经就绪的文件描述符)。接着用户执行的 epoll_ctl 函数添加文件描述符会在红黑树上增加相应的结点。</td></tr></tbody></table><table><thead><tr><th>复用方式</th><th>内核态检测文件描述符是否就绪</th></tr></thead><tbody><tr><td>select</td><td>采用轮询方式。遍历所有 fd 并返回一个描述符读写操作是否就绪的 mask 掩码，根据这个掩码给 fd_set 赋值。</td></tr><tr><td>poll</td><td>采用轮询方式。查询每个 fd 的状态，如果就绪则在等待队列中加入一项并继续遍历。</td></tr><tr><td>epoll</td><td>采用回调机制。在执行 epoll_ctl 的 add 操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。</td></tr></tbody></table><table><thead><tr><th>复用方式</th><th>用户态如何获取就绪的文件描述符</th></tr></thead><tbody><tr><td>select</td><td>将之前传入的 fd_set 拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</td></tr><tr><td>poll</td><td>将之前传入的 fd 数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</td></tr><tr><td>epoll</td><td>epoll_wait 只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过 mmap 让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。</td></tr></tbody></table><table><thead><tr><th>复用方式</th><th>继续监听的需要的动作</th></tr></thead><tbody><tr><td>select</td><td>将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。</td></tr><tr><td>poll</td><td>将新的 struct pollfd 结构体数组拷贝传入内核中，继续以上步骤。</td></tr><tr><td>epoll</td><td>无需重新构建红黑树，直接沿用已存在的即可。</td></tr></tbody></table><h2 id="性能比较"><a class="markdownIt-Anchor" href="#性能比较"></a> 性能比较</h2><p>经过功能总结的话，其实 select 和 poll 的方式是类似的，两者的区别在于：</p><ul><li>select 使用 3 个 fd_set 来指示描述符事件，并且 select 函数每次都会清空 fd_set 的值，而 poll 对于某个文件描述符有一个关联的结构，不需要每次都清空。</li><li>poll 没有文件描述符的数量限制。</li></ul><p>epoll 和 select/poll 主要区别在于：</p><ul><li>epoll 减少了用户态和内核态之间的文件描述符拷贝。</li><li>epoll 减少了对就绪文件描述符的遍历，若 n 为 文件描述符总量，则 epoll 的该过程复杂度为 <code>O(1)</code>，而 select/poll 复杂度为 <code>O(n)</code>。</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li>man page</li><li><a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll" target="_blank" rel="noopener">LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL</a></li><li><a href="https://blog.csdn.net/Move_now/article/details/71773965" target="_blank" rel="noopener">epoll 比 select 和 poll 高效的原因</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Concurrency </tag>
            
            <tag> Socket </tag>
            
            <tag> TCP </tag>
            
            <tag> I/O </tag>
            
            <tag> Networking </tag>
            
            <tag> Poll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netfilter 网络框架</title>
      <link href="/2020/07/19/linux-netfilter/"/>
      <url>/2020/07/19/linux-netfilter/</url>
      
        <content type="html"><![CDATA[<p>Netfilter 是 Linux 内核中的一个软件框架，用于管理网络数据包。不仅具有<strong>网络地址转换 (NAT)</strong> 的功能，也具备数据包<strong>内容修改</strong>以及数据包<strong>过滤</strong>等防火墙功能。Netfilter 在 Linux 网络堆栈中引入了五个挂载/钩子函数 (hook) 以在不同阶段执行数据包处理，内核模块可以向钩子注册回调函数，当数据流量经过这些钩子时候将会调用这些函数，从而完成对流量的控制。</p><a id="more"></a><h1 id="netfilteriptables"><a class="markdownIt-Anchor" href="#netfilteriptables"></a> Netfilter/iptables</h1><p>经典的 Netfilter 钩子系统的数据包过滤部分由 ip_tables、ip6_tables、arp_tables、ebtables 四个<strong>内核模块</strong>组成，它们提供了一个基于表的系统，用于定义可以过滤或转换数据包的防火墙规则。这些表可以被对应的<strong>用户空间 (user space)</strong> 的工具所管理，分别是 <code>iptables</code>、<code>ip6iptables</code>、<code>arptables</code>、<code>ebtables</code>。</p><p>最常使用的 <code>iptables</code> 防火墙软件通过与 Linux 内核中的 Netfilter hooks 交互来进行工作，就不用我们亲自编写内核模块来进行交互了，与 <code>iptables</code> 关联的内核模块在这些钩子处注册，以确保流量符合防火墙规则规定的条件。</p><p><code>nftables</code> 是从内核 3.13 版本引入的新的数据包过滤框架，旨在替代现用的 <code>iptables</code> 框架。<code>nftables</code> 引入了一个新的命令行工具 <code>nft</code>，取代了之前的 <code>iptables</code>、<code>ip6iptables</code>、<code>arptables</code>、<code>ebtables</code> 等各种工具。</p><p>综上所述，Netfilter 系统提供了内核模块和用户空间两个层次的管理方式，通常我们只需要利用 <code>iptables</code> 或者 <code>nftables</code> 命令行工具来管理规则，如果用户代码需要直接与内核模块通信的话，还需要利用 Netlink 套接字完成。</p><h1 id="钩子函数-hooks"><a class="markdownIt-Anchor" href="#钩子函数-hooks"></a> 钩子函数 (Hooks)</h1><p>Netfilter 共有五个钩子函数可以供程序注册，分别作用于不同的阶段，如下表所示。</p><table><thead><tr><th>钩子</th><th>触发时机</th></tr></thead><tbody><tr><td>NF_IP_PRE_ROUTING</td><td>所有经过完整性检查的 IP 包都会通过此钩子，在路由决策之前</td></tr><tr><td>NF_IP_LOCAL_IN</td><td>经过路由查找后，送往本机（目的地址在本地）的包会通过此钩子</td></tr><tr><td>NF_IP_FORWARD</td><td>不是本地产生的并且目的地不是本地的包（即转发的包）会通过此钩子</td></tr><tr><td>NF_IP_LOCAL_OUT</td><td>所有本地生成的发往其他机器的包会通过该钩子</td></tr><tr><td>NF_IP_POST_ROUTING</td><td>所有包在离开本机之前会通过该钩子，在路由决策之后</td></tr></tbody></table><p>钩子函数的大致结构如下图所示：</p><p><img src="index/netfilter-hooks.png" alt="netfilter-hooks"></p><h1 id="netfilter-架构"><a class="markdownIt-Anchor" href="#netfilter-架构"></a> Netfilter 架构</h1><p>通过钩子函数，我们可以大致的猜出数据包流向，数据包从端口进入，在路由查询时，如果是本机数据包，那么就交付给上层协议栈，如果需要转发并且开启转发，则会将数据包转发。那么 Netfilter 是如何将数据包的处理融合进这个过程的呢，Netfilter 框架主要包含以下概念：</p><ul><li>规则：包括匹配和处理两部分，是最小单元。</li><li>链：一系列规则匹配的阶段，链是对规则进行触发时间阶段的划分。</li><li>表：一系列具有相同目的的规则集合，表是对规则进行实现功能的划分。</li></ul><h2 id="表和链"><a class="markdownIt-Anchor" href="#表和链"></a> 表和链</h2><p>Netfilter 使用表 (tables) 来组织其规则 (rules)，这些表根据规则的类型对规则进行分类。Netfilter 提供了以下几种表：</p><ul><li>filter：用于过滤</li><li>nat：用于网络地址转换</li><li>mangle：用于对报文进行修改</li><li>raw：用于决定数据包是否被状态跟踪机制处理</li><li>security：用于根据安全策略处理数据包</li></ul><p>在表的内部，规则又被进一步组织为链 (chains)。表代表了它包含的规则的总体的目的，而链表示触发它们的 netfilter hooks，也即何时触发这些规则。</p><p>Netfilter 内置的五条链与五个钩子函数对应：</p><ul><li>PREROUTING: NF_IP_PRE_ROUTING</li><li>INPUT: NF_IP_LOCAL_IN</li><li>FORWARD: NF_IP_FORWARD</li><li>OUTPUT: NF_IP_LOCAL_OUT</li><li>POSTROUTING: NF_IP_POST_ROUTING</li></ul><p>那么表和链的关系又如何呢？每种表中包含了哪些链呢？</p><table><thead><tr><th style="text-align:center">Tables↓/Chains→</th><th style="text-align:center">PREROUTING</th><th style="text-align:center">INPUT</th><th style="text-align:center">FORWARD</th><th style="text-align:center">OUTPUT</th><th style="text-align:center">POSTROUTING</th></tr></thead><tbody><tr><td style="text-align:center">raw</td><td style="text-align:center">✓</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✓</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">mangle</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">nat (DNAT)</td><td style="text-align:center">✓</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✓</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">filter</td><td style="text-align:center"></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">security</td><td style="text-align:center"></td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">nat (SNAT)</td><td style="text-align:center"></td><td style="text-align:center">✓</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✓</td></tr></tbody></table><h2 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h2><p>所有链默认都是没有任何规则的，用户可以按需要添加规则。每条规则都包括<strong>匹配</strong>和<strong>动作</strong>两部分：</p><ul><li>匹配可以有多条，比如匹配端口、IP、数据包类型等。匹配还可以包括模块（如conntrack、recent等），实现更复杂的过滤。</li><li>动作只能有一个，通过 -j 指定，如 ACCEPT、DROP、RETURN、SNAT、DNAT 等。</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>基于以上的内容，Netfilter 总体的结构如下图所示：<br><a href="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg" alt></a></p><h1 id="iptables"><a class="markdownIt-Anchor" href="#iptables"></a> iptables</h1><p>以下是一些 iptables 的示例：</p><figure class="highlight routeros"><figcaption><span>查看规则列表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -nvL           # 如不指定表，则使用默认表<span class="built_in"> filter </span>表，其他操作同理。</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-nvL    # 显示<span class="built_in"> nat </span>表规则列表</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><figcaption><span>端口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport <span class="number">22</span> -j DROP   # 添加规则：禁止 TCP 目的端口 <span class="number">22</span> </span><br><span class="line">iptables -D INPUT -p tcp --dport <span class="number">22</span> -j DROP   # 删除规则：禁止 TCP 目的端口 <span class="number">22</span></span><br><span class="line">iptables -A INPUT -p tcp --dport <span class="number">22</span> -j ACCEPT   # 添加规则：允许 TCP 目的端口 <span class="number">22</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><figcaption><span>IP</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span> -j ACCEPT</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><figcaption><span>ping</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p <span class="keyword">icmp</span> --<span class="keyword">icmp</span>-<span class="keyword">type</span> echo-request -j DROP</span><br></pre></td></tr></table></figure><figure class="highlight pf"><figcaption><span>状态</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -m <span class="keyword">state</span> --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><figcaption><span>NAT</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -I INPUT   -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-I OUTPUT -d 55.55.55.55/32 -j DNAT --to-destination 10.0.0.30</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-I PREROUTING -d 55.55.55.55/32 -j DNAT --to-destination 10.0.0.30</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-I POSTROUTING -s 10.0.0.30/32 -j SNAT --to-source 55.55.55.55</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><figcaption><span>端口映射</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t<span class="built_in"> nat </span>-I OUTPUT -d 55.55.55.55/32 -p tcp -m tcp --dport 80 -j DNAT --to-destination 10.10.10.3:80</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-I POSTROUTING -m conntrack ! --ctstate DNAT -j ACCEPT</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-I PREROUTING -d 55.55.55.55/32 -p tcp -m tcp --dport 80 -j DNAT --to-destination 10.10.10.3:80</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><figcaption><span>重置规则（谨慎使用）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -F             # Delete all rules <span class="keyword">in</span> chain <span class="keyword">or</span> all chains</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-F</span><br><span class="line">iptables -t<span class="built_in"> mangle </span>-F</span><br><span class="line">iptables -X             # Delete a user-defined chain</span><br></pre></td></tr></table></figure><div class="note info">            <p>更多使用方式可以 <code>man iptables</code> 或 <code>iptables --help</code>。</p>          </div><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://tonydeng.github.io/sdn-handbook/" target="_blank" rel="noopener">SDN handbook</a></li><li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a></li><li><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture" target="_blank" rel="noopener">a-deep-dive-into-iptables-and-netfilter-architecture</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Linux </tag>
            
            <tag> Netfilter </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Virtual Server</title>
      <link href="/2020/07/18/linux-lvs/"/>
      <url>/2020/07/18/linux-lvs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux Virtual Server (LVS) is load balancing software for Linux kernel–based operating systems.</p></blockquote><p>LVS 是一个虚拟的服务器集群系统，用于 Linux 操作系统实现负载平衡。LVS 通过使用集群技术和 Linux 操作系统实现了一个高性能、高可用的服务器，其具备良好的可伸缩性、可靠性、可管理性。目前 LVS 已是 Linux 内核的一部分，通过 <code>ipvsadm</code> 来管理。</p><a id="more"></a><h1 id="术语表"><a class="markdownIt-Anchor" href="#术语表"></a> 术语表</h1><table><thead><tr><th style="text-align:center">术语/缩写</th><th>解释</th></tr></thead><tbody><tr><td style="text-align:center">Client Computer</td><td>请求服务的客户端</td></tr><tr><td style="text-align:center">LVS Director</td><td>负载均衡器接收客户端服务请求，并均衡到特定的“真实服务器”以处理请求。</td></tr><tr><td style="text-align:center">RS (Real Server)</td><td>负载均衡器背后用于代表该 LVS 集群提供服务的真实服务器。</td></tr><tr><td style="text-align:center">VIP (Virtual IP address)</td><td>Director 用于向客户端提供服务的 IP 地址</td></tr><tr><td style="text-align:center">RIP (Real IP address)</td><td>RS 的真实 IP 地址</td></tr><tr><td style="text-align:center">DIP (Director IP address)</td><td>Director 用于和 RS 通信的 IP 地址</td></tr><tr><td style="text-align:center">CIP (Client IP address)</td><td>客户端的 IP 地址</td></tr></tbody></table><h1 id="调度器-scheduler"><a class="markdownIt-Anchor" href="#调度器-scheduler"></a> 调度器 (Scheduler)</h1><p>LVS 实现了多种负载均衡调度器，常用的包括：</p><ul><li>Round-robin (ip_vs_rr.c)：轮询将收到的访问请求按照顺序轮流调度到不同的服务器上，不管后端真实服务器的实际连接数和系统负载。</li><li>Weighted round-robin (ip_vs_wrr.c)：加权轮询给 RS 设置权重，权重越高，那么分发的请求数越多，权重的取值范围0–100。根据每台服务器的性能，给每台服务器添加权值，如果 RS1 的权值为 1，RS2 的权值为 2，那么调度到 RS2 的请求会是 RS1 的 2 倍。权值越高的服务器，处理的请求越多。这种算法是对 rr 算法的一种优化和补充。</li><li>Least-connection (ip_vs_lc.c)：最少链接根据后端 RS 的连接数来决定把请求分发给谁，RS1 连接数比 RS2 连接数少，那么请求就优先发给 RS1。</li><li>Weighted least-connection (ip_vs_wlc.c)：上述的一种补充。</li></ul><p>其他算法包括：</p><ul><li>Locality-based least-connection (ip_vs_lblc.c)</li><li>Locality-based least-connection with replication (ip_vs_lblcr.c)</li><li>Destination hashing (ip_vs_dh.c)</li><li>Source hashing (ip_vs_sh.c)</li><li>Shortest expected delay (ip_vs_sed.c)</li><li>Never queue (ip_vs_nq.c)</li></ul><h1 id="转发模式"><a class="markdownIt-Anchor" href="#转发模式"></a> 转发模式</h1><p>LVS 可以基于多种方式工作，主要包括：</p><ul><li>直接路由 (DR)</li><li>网络地址转换 (NAT)</li><li>完全网络地址转换 (FullNAT)</li><li>IP 隧道 (IP Tunneling)</li></ul><p>LVS 不同的转发方式具有不同的网络架构，也导致了不同的性能。</p><h2 id="virtual-server-via-direct-routing"><a class="markdownIt-Anchor" href="#virtual-server-via-direct-routing"></a> Virtual Server via Direct Routing</h2><p>直接路由 (DR) 的特点是：LVS 和 RS 在同一个 LAN/VLAN，多个 RS 和 LVS 共用同一个 VIP，然后依据 MAC 地址来在 LVS 和多个 RS 之间转发。</p><p>具体流程为：入站请求走 LVS，LVS 修改目的 MAC，将其转发给真正的 RS，RS 的回复报文绕过 LVS 直接发给 Client。具体数据包流向如下图所示。其中 LVS 和 RS 虽然有虚线连接，但只表示逻辑上的连接，实际数据包是通过交换机转发的。</p><p><img src="lvs-dr.png" alt="lvs-dr"></p><p>由于大部分情况下都是请求包小，回复包大，LVS 不容易成为流量瓶颈，同时 LVS 只需要修改进来的包的 MAC 地址，因此 DR 模式性能很好。</p><p>但同时这种模式也具有明显的缺点：</p><ul><li>要求 LVS 和 RS 在同一个 LAN/VLAN，扩展性不够好。</li><li>RS 需要配置 VIP 同时特殊处理 ARP。</li><li>配置比较复杂（需要将 VIP 配置到 lo 接口，避免直接将请求发到 RS）。</li><li>不支持端口映射。</li></ul><h2 id="virtual-server-via-nat"><a class="markdownIt-Anchor" href="#virtual-server-via-nat"></a> Virtual Server via NAT</h2><p>NAT 模式基于 NAT 技术完成转发，类似于 NAT 路由器的功能，只不过多了负载均衡的过程，这种方式配置简单，支持端口映射（看名字就知道），并且 RIP 一般是私有地址。其数据包流向如下图所示：</p><p><img src="lvs-nat.png" alt="lvs-nat"></p><p>这种模式的缺点为：</p><ul><li>LVS 必须有一个接口和所有 RS 在同一个 LAN/VLAN。</li><li>进出流量都要走 LVS 转发，LVS 容易成为瓶颈。</li><li>一般而言需要将 LVS 配置成 RS 的网关。</li></ul><h2 id="virtual-server-via-fullnat"><a class="markdownIt-Anchor" href="#virtual-server-via-fullnat"></a> Virtual Server via FullNAT</h2><p>完全 NAT 模式是 NAT 模式的一个变种，与 NAT 模式不同，FullNAT 模式不仅将目的 IP 修改为 RIP，并且将源 IP 修改为 DIP，这样 DIP 和 RIP 不必非得在同一个二层网络之中，两者只需要 IP 互通即可。</p><p><img src="lvs-fullnat.png" alt="lvs-fullnat"></p><p>但这种模式也有缺点：</p><ul><li>RS 看不到 CIP（NAT 模式下可以看到）。</li><li>进出流量还是都走的 LVS，容易成为瓶颈（跟 NAT 一样都有这个问题）。</li></ul><div class="note info">            <p>因为 CIP 被修改掉了，RS 只能看到 LVS 的 DIP，可将 CIP 放入 TCP 包的 Option 中传递给 RS，RS 上一般部署自己写的模块来从 Options 中读取 CIP，这样 RS 能看到 CIP 了, 当然这不是一个开源的通用方案。</p>          </div><h2 id="virtual-server-via-ip-tunneling"><a class="markdownIt-Anchor" href="#virtual-server-via-ip-tunneling"></a> Virtual Server via IP Tunneling</h2><p>IP 隧道模式利用了 IP 隧道技术来打通 LVS 和 RS 之间的通信。当请求包到达 LVS 后，LVS 将请求包封装成一个新的 IP 报文，新的 IP 包的目的 IP 是某一 RS 的 IP，然后转发给 RS，RS 收到报文后 IPIP 内核模块解封装，取出用户的请求报文发现目的 IP 是 VIP，而自己的 tun 虚拟网卡上配置了这个 IP，从而愉快地处理请求并将结果直接发送给客户。</p><p>这种方式的运行过程十分类似于 DR 模式，只不过 DR 模式基于 MAC 转发，而 IP 隧道模式基于 IPIP 协议路由。</p><p><img src="lvs-tun.png" alt="lvs-tun"></p><p>这种方式的优点是：</p><ul><li>集群节点可以跨二层。</li><li>跟 DR 一样，响应报文直接发给 Client，LVS 没有性能瓶颈。</li></ul><p>同时也存在了一定的缺点：</p><ul><li>RS 上必须安装运行 IPIP 模块。</li><li>多增加了一个 IP 头，增加了开销。</li><li>LVS 和 RS 上的 tun 虚拟网卡上配置同一个 VIP（类似 DR）。</li></ul><h1 id="四层-lb-vs-七层-lb"><a class="markdownIt-Anchor" href="#四层-lb-vs-七层-lb"></a> 四层 LB vs 七层 LB</h1><p>LVS 通常用来实现四层负载均衡，通过发布虚拟 VIP 和四层的端口号，来决定哪些流量需要做负载均衡。</p><p>七层的负载均衡就是基于虚拟的 URL 或主机 IP 的负载均衡：在四层负载均衡的基础上，再考虑应用层的特征，比如同一个 Web 服务器的负载均衡，除了根据 VIP 加端口辨别是否需要处理的流量，还可根据七层的 URL、浏览器类别、语言来决定是否要进行负载均衡。</p><p>实现七层负载均衡的软件有：</p><ul><li>nginx：只在 http 协议和 mail 协议上功能比较好，性能与 haproxy 差不多。</li><li>tengine：阿里基于 nginx 的开源七层 LB。</li><li>haproxy</li><li>apache</li></ul><p>除此之外，还有二层负载均衡和三层负载均衡，由于应用程度不广泛，故不再讨论。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="http://www.linuxvirtualserver.org/Documents.html" target="_blank" rel="noopener">LVS Documentation</a></li><li><a href="https://en.wikipedia.org/wiki/Linux_Virtual_Server" target="_blank" rel="noopener">LVS wikepedia</a></li><li><a href="https://programmer.group/dr-mode-of-lvs-load-balancing-cluster-deployment.html" target="_blank" rel="noopener">DR mode of LVS load balancing cluster deployment</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Linux </tag>
            
            <tag> LVS </tag>
            
            <tag> LB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Namespace</title>
      <link href="/2020/06/21/linux-namespace/"/>
      <url>/2020/06/21/linux-namespace/</url>
      
        <content type="html"><![CDATA[<p>Linux Namespace (名称空间，命名空间) 是 Linux 提供的一种内核级别环境隔离的方法。该功能对内核资源进行分区，使得一组进程只能看到一组资源，而另一组进程看到另一组不同的资源。我们可以将 Namespace 视为一个盒子，这些盒子内有一些系统资源，具体含有哪些资源完全取决于盒子（命名空间）的类型。从内核版本 5.6 开始，存在 8 种 Namespace。分别为 <code>Cgroup</code>，<code>IPC</code>，<code>Network</code>，<code>Mount</code>，<code>PID</code>，<code>User</code>，<code>UTS</code>，<code>Time</code>。</p><a id="more"></a><div class="note info">            <p>Time Namespace 在 2020 年 3 月才被加入，在 Linux 内核 5.6 以上的版本才可以看到。因此在下面的例子中暂不讨论 Time Namespace 这种类型。</p>          </div><h1 id="进程与命名空间"><a class="markdownIt-Anchor" href="#进程与命名空间"></a> 进程与命名空间</h1><p>每个进程都与一个命名空间相关联，并且进程只能查看或使用与该命名空间以及后代命名空间相关的资源。在任何给定时刻，任何进程 P 都恰好属于每种 Namespace 类型的一个实例。这样每个进程（或其进程组）可以在每种类型的资源上拥有自己的视图，且只能查看和操作绑定在此命名空间实例的资源。</p><p>我们可以看到一个进程所属的 Namespace 实例是哪些，在典型的 Linux 发行版中，它们以文件的形式存在于 <code>/proc/$pid/ns</code> 目录下。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /proc/$$/ns</span><br><span class="line">total <span class="number">0</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> liyanjiu liyanjiu <span class="number">0</span> <span class="number">6</span>月  <span class="number">27</span> <span class="number">21</span>:<span class="number">00</span> cgroup -&gt; <span class="string">'cgroup:[4026531835]'</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> liyanjiu liyanjiu <span class="number">0</span> <span class="number">6</span>月  <span class="number">27</span> <span class="number">21</span>:<span class="number">00</span> ipc -&gt; <span class="string">'ipc:[4026531839]'</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> liyanjiu liyanjiu <span class="number">0</span> <span class="number">6</span>月  <span class="number">27</span> <span class="number">21</span>:<span class="number">00</span> mnt -&gt; <span class="string">'mnt:[4026531840]'</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> liyanjiu liyanjiu <span class="number">0</span> <span class="number">6</span>月  <span class="number">27</span> <span class="number">21</span>:<span class="number">00</span> net -&gt; <span class="string">'net:[4026531992]'</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> liyanjiu liyanjiu <span class="number">0</span> <span class="number">6</span>月  <span class="number">27</span> <span class="number">21</span>:<span class="number">00</span> pid -&gt; <span class="string">'pid:[4026531836]'</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> liyanjiu liyanjiu <span class="number">0</span> <span class="number">6</span>月  <span class="number">27</span> <span class="number">21</span>:<span class="number">00</span> user -&gt; <span class="string">'user:[4026531837]'</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> liyanjiu liyanjiu <span class="number">0</span> <span class="number">6</span>月  <span class="number">27</span> <span class="number">21</span>:<span class="number">00</span> uts -&gt; <span class="string">'uts:[4026531838]'</span></span><br></pre></td></tr></table></figure><p>如果打开第二个终端并运行相同的命令，则应该产生完全相同的输出。这是因为进程必须属于某个名称空间，除非我们明确指定哪个名称空间，否则 Linux 会将其添加为默认名称空间的成员。</p><h1 id="实现与系统调用"><a class="markdownIt-Anchor" href="#实现与系统调用"></a> 实现与系统调用</h1><p>命名空间的实现主要涉及三个系统调用：</p><ul><li>clone() – 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数设置命名空间。</li><li>unshare() – 使某进程脱离某个 Namespace，加入到新建的 Namespace 中。</li><li>setns() – 把某进程加入到某个已存在的 Namespace。</li></ul><p>其中 unshare() 函数有一个同名包装命令，因此用起来比较简单，下文中使用 <code>unshare</code> 命令来进行实验。</p><p>以下是各种命名空间</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">中文名称</th><th style="text-align:center">unshare 参数</th><th style="text-align:center">clone 参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">UTS (UNIX Time-sharing System)</td><td style="text-align:center">主机名和域名</td><td style="text-align:center">-u</td><td style="text-align:center">CLONE_NEWUTS</td><td style="text-align:center">使得子进程有独立的主机名和域名，使得该进程在网络上被视作一个独立的节点，而不仅仅是一个进程。</td></tr><tr><td style="text-align:center">User</td><td style="text-align:center">用户和组</td><td style="text-align:center">-U</td><td style="text-align:center">CLONE_NEWUSER</td><td style="text-align:center">使得子进程有独立的用户和组映射，用于权限管理。</td></tr><tr><td style="text-align:center">Mount</td><td style="text-align:center">挂载点</td><td style="text-align:center">-m</td><td style="text-align:center">CLONE_NEWNS</td><td style="text-align:center">使得子进程有独立的文件系统。</td></tr></tbody></table><p>PID</p><h2 id="clone-系统调用"><a class="markdownIt-Anchor" href="#clone-系统调用"></a> clone 系统调用</h2><p>clone() 系统调用的基本用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *child_stack,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">/* pid_t *ptid, void *newtls, pid_t *ctid */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>成功时，调用者的进程中将会返回子进程的 thread ID；失败时返回 -1，子进程将不会被创建，同时将会触发 ERROR。</p><p>clone() 创建新进程，其行为类似于 fork()，通常使用 glibc 库中的包装函数 clone()，该函数基于 clone 系统调用。与 fork 不同，clone 允许子进程与父进程共享部分执行上下文的参数，例如虚拟地址空间、文件描述符表、信号处理程序等。</p><p>fork 是标准的 Unix 系统调用，用来创建进程，而在 Linux 中 clone 可以根据传递的选项创建不同的执行线程，新的执行线程可以遵循 UNIX 进程、POSIX 线程、介于两者之间或完全不同的事物（例如不同的容器）的语义。<code>pthread_create()</code> 和 <code>fork()</code> 底层实现都使用了 <code>clone()</code>。</p><p>通过 clone() 创建的子进程，从调用指向的函数 fn() 开始执行，而 fork() 创建的子进程将会从 fork 的调用点开始执行。当 fn(arg) 函数返回，子进程结束，函数 fn 的返回值就是子进程的退出状态码，子进程同样可以通过调用 exit() 和收到结束信号而显式结束。</p><p>child_stack 参数指定了子进程使用的栈，子进程不可以与父进程共享栈空间，由于绝大部分 Linux 的处理器的栈都是向下生长的，因此该参数需要指向栈顶空间。</p><p>flags 的最低字节指定了当子进程结束时需要发送给父进程的结束信号。如果该信号不是 SIGCHLD，则父进程在调用 wait() 等待子进程时必须指定 <code>__WALL</code> 或 <code>__WCLONE</code> 选项；如果未指定，则子进程退出时父进程将不会收到任何信号。</p><p>flags 还可以与零个或多个常量进行按位或运算，以指定在调用进程和子进程之间共享的内容，具体的常量可以查看 man 文档。</p><h2 id="unshare-系统调用"><a class="markdownIt-Anchor" href="#unshare-系统调用"></a> unshare 系统调用</h2><p>TODO</p><h2 id="setns-系统调用"><a class="markdownIt-Anchor" href="#setns-系统调用"></a> setns 系统调用</h2><p>TODO</p><h1 id="uts-namespace"><a class="markdownIt-Anchor" href="#uts-namespace"></a> UTS Namespace</h1><h2 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h2><p>我们使用 <code>unshare</code> 命令在一个新的 Namespace 中运行一个 shell 进程。其中 -u 标志告诉它在新的 <code>UTS</code> 命名空间中运行 bash。请注意此时我们的新 bash 进程指向不同的 uts 文件，而其他所有文件都保持不变。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">Lenovo-XiaoXinPro<span class="number">-13</span></span><br><span class="line">$ sudo unshare -u bash  # run bash in a new UTS <span class="keyword">namespace</span>.</span><br><span class="line">$ ls -la /<span class="keyword">proc</span>/$$/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1<span class="title"> root</span> root 0 6月  27 21:07<span class="title"> cgroup</span> -&gt; 'cgroup:[4026531835]'</span><br><span class="line">lrwxrwxrwx 1<span class="title"> root</span> root 0 6月  27 21:07<span class="title"> ipc</span> -&gt; 'ipc:[4026531839]'</span><br><span class="line">lrwxrwxrwx 1<span class="title"> root</span> root 0 6月  27 21:07<span class="title"> mnt</span> -&gt; 'mnt:[4026531840]'</span><br><span class="line">lrwxrwxrwx 1<span class="title"> root</span> root 0 6月  27 21:07<span class="title"> net</span> -&gt; 'net:[4026531992]'</span><br><span class="line">lrwxrwxrwx 1<span class="title"> root</span> root 0 6月  27 21:07<span class="title"> pid</span> -&gt; 'pid:[4026531836]'</span><br><span class="line">lrwxrwxrwx 1<span class="title"> root</span> root 0 6月  27 21:07<span class="title"> user</span> -&gt; 'user:[4026531837]'</span><br><span class="line">lrwxrwxrwx 1<span class="title"> root</span> root 0 6月  27 21:07<span class="title"> uts</span> -&gt; 'uts:[4026533065]'</span><br><span class="line">$<span class="title"> hostname</span></span><br><span class="line"><span class="title">Lenovo-XiaoXinPro-13</span></span><br><span class="line"><span class="title">$</span> hostname<span class="title"> container</span></span><br><span class="line"><span class="title">$</span> hostname</span><br><span class="line">container</span><br><span class="line">$<span class="title"> exit</span> </span><br><span class="line">$<span class="title"> hostname</span>  </span><br><span class="line">Lenovo-XiaoXinPro-13</span><br></pre></td></tr></table></figure><p>我们在新的 UTS Namespace 中设置 hostname 为 container，并且不会影响系统中的任何其他进程。</p><p>现在我们来思考一个问题：什么是容器？简而言之，<strong>容器是普通的进程，其具有与其他进程不同的 Namespace</strong>。实际上，容器不必为每种类型都属于唯一的命名空间，它可以共享其中的一些。当 <code>docker run --net=host redis</code> 执行时，其实告诉docker 不要为 redis 进程创建新的 Network Namespace，并且如我们所见，Linux 将该进程添加为默认 Network Namespace 的成员，就像其他所有常规进程一样没有任何区别。</p><p>那么新的问题来了？如果一个容器，只有一种 Namespace 是私有的，而其余所有的 Namespace 都是和其他进程共享的，那么它还能称之为容器吗？笔者认为这个问题的答案是肯定的，但结果其实并不是那么重要。通常，容器通过 Namespace 实现<strong>隔离 (isolation)</strong> 的概念，进程共享的 Namespace 和资源的数量越少，则进程越隔离，这才是真正重要的。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight c"><figcaption><span>ns_uts.c</span><a href="/downloads/code/linux/namespace/ns_uts.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = {</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now in child process!\n"</span>);</span><br><span class="line">    sethostname(<span class="string">"container"</span>, <span class="number">12</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Program start...\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Already exit!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>程序的输出结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gcc ns_uts.c -o ns_uts</span><br><span class="line">$ sudo ./ns_uts </span><br><span class="line">Program start...</span><br><span class="line">Now <span class="keyword">in</span> child process!</span><br><span class="line">root@container:/home/liyanjiu/<span class="comment"># hostname</span></span><br><span class="line">container</span><br><span class="line">root@container:/home/liyanjiu/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">Already <span class="built_in">exit</span>!</span><br><span class="line">liyanjiu@Lenovo-XiaoXinPro-13:~$ hostname</span><br><span class="line">Lenovo-XiaoXinPro-13</span><br></pre></td></tr></table></figure><h1 id="user-namespace"><a class="markdownIt-Anchor" href="#user-namespace"></a> User Namespace</h1><h2 id="命令-2"><a class="markdownIt-Anchor" href="#命令-2"></a> 命令</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ unshare -U bash</span><br><span class="line">$ id</span><br><span class="line">uid=<span class="number">65534</span>(nobody) gid=<span class="number">65534</span>(nogroup) 组=<span class="number">65534</span>(nogroup)</span><br><span class="line">$ cat /proc/$$/uid_map  # no output</span><br><span class="line">         <span class="number">0</span>          <span class="number">0</span> <span class="number">4294967295</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>映射并没有带来权限的升级，它仅仅是作为一种子 Namespace 的授权。</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><h1 id="mount-namespace"><a class="markdownIt-Anchor" href="#mount-namespace"></a> Mount Namespace</h1><h1 id="pid-namespace"><a class="markdownIt-Anchor" href="#pid-namespace"></a> PID Namespace</h1><p>Linux 中的 <code>/proc</code> 目录通常用于暴露由 Linux 本身管理的特殊文件系统（称为 <code>proc</code> 文件系统）。Linux 使用它来公开有关系统中正在运行的所有进程的信息，以及设备、中断等其他系统信息。每当我们运行诸如 <code>ps</code> 之类的命令来访问有关系统中进程的信息时，它都会寻找该文件系统来获取信息。</p><p>换句话说，我们需要启动一个 <code>proc</code> 文件系统。</p><p>PID Namespace 隔离系统中的进程 ID。一种效果是在不同 PID 名称空间中运行的进程可以具有相同的进程 ID，而不会彼此冲突。</p><h1 id="network-namespace"><a class="markdownIt-Anchor" href="#network-namespace"></a> Network namespace</h1><p>使用 <code>iproute2</code> 包的 <code>ip</code> 命令可以创建 namespace，默认创建在 <code>/var/run/netns</code> 下，但实际上可以在任何地方，例如 <code>docker</code> 中的 namespace 在 <code>/var/run/docker/netns</code>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip netns <span class="builtin-name">add</span> ns1</span><br><span class="line">ip netns <span class="builtin-name">add</span> ns2</span><br><span class="line"></span><br><span class="line">tree /var/run/netns/</span><br><span class="line">/var/run/netns/</span><br><span class="line">├── ns1</span><br><span class="line">└── ns2</span><br></pre></td></tr></table></figure><p>创建 namespace 后，我们可以利用 <code>ip netns exec</code> 在其中执行一些命令来确认隔离性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 \</span><br><span class="line">       <span class="built_in"> ip address </span>show</span><br></pre></td></tr></table></figure><p>接下来创建 veth 对，将 namespace 连接起来</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link <span class="builtin-name">add</span> veth1<span class="built_in"> type </span>veth<span class="built_in"> peer </span>name br-veth1</span><br><span class="line">ip link <span class="builtin-name">add</span> veth2<span class="built_in"> type </span>veth<span class="built_in"> peer </span>name br-veth2</span><br><span class="line">s</span><br><span class="line">ip link <span class="builtin-name">set</span> veth1 netns ns1</span><br><span class="line">ip link <span class="builtin-name">set</span> veth2 netns ns2</span><br></pre></td></tr></table></figure><p>现在，namespace 具有另外的接口了，请检查它们是否确实存在：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 \</span><br><span class="line">       <span class="built_in"> ip address </span>show</span><br></pre></td></tr></table></figure><p>设置 IP 地址</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 \</span><br><span class="line">       <span class="built_in"> ip </span>addr <span class="builtin-name">add</span> 192.168.1.11/24 dev veth1</span><br><span class="line"></span><br><span class="line">ip netns exec ns2 \</span><br><span class="line">       <span class="built_in"> ip </span>addr <span class="builtin-name">add</span> 192.168.1.12/24 dev veth2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://en.wikipedia.org/wiki/Linux_namespace" target="_blank" rel="noopener">Linux Namespace, Wikipedia</a></li><li><a href="http://ifeanyi.co/posts/linux-namespaces-part-1" target="_blank" rel="noopener">A deep dive into Linux namespaces, UTS</a></li><li><a href="http://ifeanyi.co/posts/linux-namespaces-part-2" target="_blank" rel="noopener">A deep dive into Linux namespaces, User</a></li><li><a href="http://ifeanyi.co/posts/linux-namespaces-part-3" target="_blank" rel="noopener">A deep dive into Linux namespaces, Mount $ PID</a></li><li><a href="https://cizixs.com/2017/08/29/linux-namespace/" target="_blank" rel="noopener">docker 容器基础技术：linux namespace 简介</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Amazing Bitwise</title>
      <link href="/2020/04/08/algo-bitwise/"/>
      <url>/2020/04/08/algo-bitwise/</url>
      
        <content type="html"><![CDATA[<p>位运算的奇技淫巧总结，奇妙的知识增加了！</p><a id="more"></a><h1 id="位操作运算符-bitwise-operators"><a class="markdownIt-Anchor" href="#位操作运算符-bitwise-operators"></a> 位操作运算符 (Bitwise Operators)</h1><table><thead><tr><th>运算符</th><th>运算符元数</th><th style="text-align:center">编程语言</th><th>含义</th></tr></thead><tbody><tr><td>取反 (NOT)</td><td>一元运算符</td><td style="text-align:center"><code>~</code></td><td>对一个二进制数的每一位执行逻辑反操作, 1 变 0 ，0 变 1。</td></tr><tr><td>按位与 (AND)</td><td>二元运算符</td><td style="text-align:center"><code>&amp;</code></td><td>当两个等长的二进制数对应位<strong>都为 1</strong>，该位的结果值才为 1。</td></tr><tr><td>按位或 (OR)</td><td>二元运算符</td><td style="text-align:center"><code>|</code></td><td>当两个等长的二进制数对应位中<strong>只要有一个为 1</strong>，该位的结果值就为 1。</td></tr><tr><td>按位异或 (XOR)</td><td>二元运算符</td><td style="text-align:center"><code>^</code></td><td>当两个等长的二进制数对应位<strong>不同</strong>，该位的结果值为 1。</td></tr></tbody></table><div class="note info">            <p>编程语言指类 C 编程语言，例如 C/C++，Java 等。</p>          </div><h2 id="and"><a class="markdownIt-Anchor" href="#and"></a> AND</h2><p>按位与操作可以同时将二进制数的<strong>某些位设为 0</strong>，而不影响其他位。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0101</span>（十进制<span class="number">5</span>）</span><br><span class="line">AND <span class="number">0011</span>（十进制<span class="number">3</span>）</span><br><span class="line"> =  <span class="number">0001</span>（十进制<span class="number">1</span>）</span><br></pre></td></tr></table></figure><h2 id="or"><a class="markdownIt-Anchor" href="#or"></a> OR</h2><p>按位或操作可以同时将二进制数的<strong>某些位设为 1</strong>，而不影响其他位。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0101</span>（十进制<span class="number">5</span>）</span><br><span class="line">OR <span class="number">0011</span>（十进制<span class="number">3</span>）</span><br><span class="line"> = <span class="number">0111</span>（十进制<span class="number">7</span>）</span><br></pre></td></tr></table></figure><h2 id="xor"><a class="markdownIt-Anchor" href="#xor"></a> XOR</h2><p>按位异或操作可以同时将二进制数的<strong>某些位切换</strong>，而不影响其他位。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0010</span></span><br><span class="line">XOR <span class="number">1010</span></span><br><span class="line">  = <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>按位异或具有两条重要的性质：</p><ol><li>a XOR a = 0</li><li>a XOR 0 = a</li></ol><h1 id="移位-bit-shifts"><a class="markdownIt-Anchor" href="#移位-bit-shifts"></a> 移位 (Bit shifts)</h1><p>移位是一个<strong>二元运算符</strong>，用来将一个二进制数中的每一位全部都向一个方向移动指定位，<strong>溢出的部分将被舍弃，而空缺的部分填入一定的值</strong>。在类 C 语言中，左移使用两个小于符号 <code>&lt;&lt;</code> 表示，右移使用两个大于符号 <code>&gt;&gt;</code> 表示。</p><p>移位可以根据填入值的不同分为两种：</p><ul><li>算术移位 (Arithmetic shift) ：在算术移位中，左移右移情况不同。<ul><li>算术左移：右侧使用 0 补齐</li><li>算术右移：左侧使用符号位补齐</li></ul></li><li>逻辑移位 (Logical shift)：在逻辑移位中，均使用 0 补齐丢弃的位。</li></ul><p>因此，<strong>逻辑左移和算术左移是完全相同的</strong>，主要区别在于右移中算术右移可以保持负数在移位过程中符号不变。</p><div class="note info">            <p>C/C++ 语言中可以区分有符号数和无符号数，因此<strong>算术移位和逻辑移位复用同样的符号</strong>，具体是算术右移还是逻辑右移由编译器根据数据类型决定，其对应关系为：</p><ul><li>有符号数：算术右移</li><li>无符号数：逻辑右移</li></ul><p>如果需要对有符号数执行逻辑右移，那么需要做显式的类型转换才能得到想要的效果。</p>          </div><div class="note info">            <p>Java 中所有的整型都是有符号数，因此右移不能再复用，因此有三种移位操作符：</p><ul><li>算术左移/逻辑左移：<code>&lt;&lt;</code></li><li>算术右移：<code>&gt;&gt;</code></li><li>逻辑右移：<code>&gt;&gt;&gt;</code></li></ul>          </div><p>还有一种移位是循环移位 (Circular shift)，其中溢出的部分将不会被舍弃，而是填入另一端的空缺。C 系语言都没有默认的循环移位操作符，可以通过复合操作来实现。注意 C/C++ 需要考虑默认的 int 类型在不同平台的位宽不同。</p><div class="tabs" id="circular"><ul class="nav-tabs"><li class="tab active"><a href="#circular-1">C++</a></li><li class="tab"><a href="#circular-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="circular-1"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> x = ..., n = ...;</span><br><span class="line"><span class="keyword">uint32_t</span> y = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span> - n));  <span class="comment">// may cause undefined behavior when n == 0</span></span><br><span class="line"><span class="keyword">uint32_t</span> y = n ? (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span> - n)) : x;  <span class="comment">// correct but less efficient</span></span><br><span class="line"><span class="keyword">uint32_t</span> y = (x &lt;&lt; n) | (x &gt;&gt; (-n &amp; <span class="number">31</span>));         <span class="comment">// better and recommended</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="circular-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = ..., n = ...;</span><br><span class="line"><span class="keyword">int</span> y = (x &lt;&lt; n) | (x &gt;&gt;&gt; (<span class="number">32</span> - n));    <span class="comment">// rotate left</span></span><br><span class="line"><span class="keyword">int</span> y = (x &gt;&gt;&gt; n) | (x &lt;&lt; (<span class="number">32</span> - n));    <span class="comment">// rotate right</span></span><br></pre></td></tr></table></figure></div></div></div><h1 id="奇妙的操作"><a class="markdownIt-Anchor" href="#奇妙的操作"></a> 奇妙的操作</h1><p>奇怪的知识增加了！使用 Java 语言描述，大部分可以直接用于其他语言。</p><h2 id="数学运算"><a class="markdownIt-Anchor" href="#数学运算"></a> 数学运算</h2><figure class="highlight java"><figcaption><span>位操作实现乘除法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;  <span class="comment">// 可以是正数、负数或 0 </span></span><br><span class="line">a &lt;&lt; <span class="number">1</span>; <span class="comment">// 乘以 2</span></span><br><span class="line">a &gt;&gt; <span class="number">1</span>; <span class="comment">// 除以 2</span></span><br></pre></td></tr></table></figure><p>注意：正数和负数左移（乘法）都可能会溢出，从而改变符号位；正数右移最小为 0，负数右移最小为 -1。<strong>因此 -1 &gt;&gt; 1 = -1，而 -1 / 2 = 0。</strong></p><figure class="highlight java"><figcaption><span>位操作求两正数平均数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = ..., b = ...;</span><br><span class="line"><span class="keyword">int</span> avg = (a + b) &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>思路：对于两个正数的和，可能会使得符号位溢出变为负数，此时将该数看成无符号数，然后使用逻辑右移 1 位便可以求平均数。</p><figure class="highlight java"><figcaption><span>位操作求相反数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversal</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>位操作求绝对值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>位操作判断奇偶数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((a &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">//偶数 &#125;</span></span><br></pre></td></tr></table></figure><p>思路：只需判断最后一位即可。</p><h2 id="交换高低位"><a class="markdownIt-Anchor" href="#交换高低位"></a> 交换高低位</h2><figure class="highlight java"><figcaption><span>交换高低位</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">34520</span>;</span><br><span class="line">a = (a &gt;&gt;&gt; <span class="number">16</span>) | (a &lt;&lt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>思路：通过移位和按位或实现交换高低位，该过程可以进一步推广为求二进制逆序。</p><figure class="highlight java"><figcaption><span>二进制逆序</span><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于 Java 中的 Integer.reverse(n) </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    n = (n &gt;&gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消去最低位的-1"><a class="markdownIt-Anchor" href="#消去最低位的-1"></a> 消去最低位的 1</h2><figure class="highlight java"><figcaption><span>消去最低位的 1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = ...;</span><br><span class="line">n = n &amp; (n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>思路：n 可以保证低于最低位 1 的 0，按位与结果仍然是 0，保持不变；n - 1 使得最低位的 1 变为 0，而高于最低位 1 的位没有变化，所以按位与结果保持不变。因此 <code>n &amp;= n - 1</code> 消去了最低位的 1。</p><p>该思想可以应用于以下场景：</p><figure class="highlight java"><figcaption><span>无符号数二进制形式中位 1 的个数</span><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>思路：每次消去一个 1，统计消去了多少次即可。</p><figure class="highlight java"><figcaption><span>检测整数 n 是否是 2 的幂次</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp;= n - <span class="number">1</span>) == <span class="number">0</span> ? <span class="keyword">true</span>: <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：N 如果是 2 的幂次，则 N 满足两个条件：</p><ol><li>N &gt; 0</li><li>N 的二进制表示中只有一个 1</li></ol><figure class="highlight java"><figcaption><span>统计 A 变成 B 需要改变的比特位</span><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">convertInteger</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A ^ B;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：利用 A ^ B 找到不同的位数，将转化为位 1 的个数问题。</p><h2 id="按位异或"><a class="markdownIt-Anchor" href="#按位异或"></a> 按位异或</h2><figure class="highlight java"><figcaption><span>不使用额外空间交换两个值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;  <span class="comment">// b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a</span></span><br><span class="line">a = a ^ b;  <span class="comment">// a = (a ^ b) ^ a = b</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>数组中只有一个数出现一次，剩下都出现两次，找出出现一次的数</span><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>数组中只有一个数出现一次，剩下都出现三次，找出出现一次的数</span><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        ones = (ones ^ num) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ num) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode-题目"><a class="markdownIt-Anchor" href="#leetcode-题目"></a> LeetCode 题目</h1><p>这些题目一般不单单用到位操作，仅记录经典或进阶的题目，简单的题目会作为基础操作归类到前一章。</p><table><thead><tr><th>ID</th><th>题目</th><th>思路</th></tr></thead><tbody><tr><td>338</td><td>比特位计数</td><td>n &amp; (n-1) 加上动态规划 P(x)=P(x&amp;(x−1))+1;</td></tr></tbody></table><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://en.wikipedia.org/wiki/Bitwise_operation" target="_blank" rel="noopener">Bitwise Operator - Wikipedia</a></li><li><a href="https://www.zhihu.com/question/38206659" target="_blank" rel="noopener">位运算有什么奇技淫巧？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting Algorithms</title>
      <link href="/2020/03/17/algo-sort/"/>
      <url>/2020/03/17/algo-sort/</url>
      
        <content type="html"><![CDATA[<p>当我们在谈论排序算法时，我们在谈论什么？</p><a id="more"></a><h1 id="游戏规则"><a class="markdownIt-Anchor" href="#游戏规则"></a> 游戏规则</h1><p>排序就是将<strong>一组对象</strong>按照某种逻辑<strong>顺序</strong>重新排列的过程。</p><h2 id="排序的对象"><a class="markdownIt-Anchor" href="#排序的对象"></a> 排序的对象</h2><p>首先我们思考一下，<strong>排序的对象有哪些？</strong> 我首先想到的对象和场景是：</p><ul><li>整数排序：对成绩名次排序，对国家人口数量排序等。</li><li>浮点数排序：对学生的 GPA 进行排序，对国家的 GDP 进行排序。</li><li>字符串排序：按照名字排序，按照电话号码排序等。</li></ul><p>以上都可以算作<strong>基本数据类型</strong>，他们的共同之处在于<strong>他们都有一套天然的/公认的逻辑顺序</strong>。例如整型中 2 大于 1，-1 大于 -2；浮点型中 3.15 大于 3.14；字符串可能稍微复杂点，但是公认还是按照字符依次序比较，例如 “BA” 大于 “AB”、“BBC” 大于 “BB”。 如果更进一步，我们需要对<strong>自定义的数据结构对象</strong>进行排序，那么又该如何排序呢？一个显而易见的问题是，我们需要定义一个排序的逻辑，或者说比较的逻辑。例如，我的 Person 类里面，我可以定义为 Person 对象的顺序就是 age 的顺序，也可以定义为 Person 对象的顺序就是 name 的顺序。</p><figure class="highlight java"><figcaption><span>Person</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们思考第二个问题，<strong>使用何种数据结构来组织这组待排序的对象？</strong> 简单的说，用什么数据结构来容纳这些对象。最常用的一维容器恐怕就是数组和链表，考虑到数组基本是大部分编程语言原生支持的数据结构，并且数组的插入、删除、修改、查询操作都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间复杂度的，更便于在排序中移动或更改元素，因此数组可能是一种比较理想的容器。</p><p>综合以上两个角度，我们可以得出以下结论：排序关注的对象是<strong>数组元素 (array of items)</strong>，其中每个元素都有一个<strong>主键 (key)</strong>。我们的目标就是对元素的主键按照某种逻辑进行排序（例如大小或字符序），使得排序后数组中索引较大元素的主键都大于等于索引较小的元素的主键。</p><p>元素和主键的定义依据不同的应用可能相差甚远。</p><ul><li>对于基本类型：元素可以直接用主键表示，比较和交换都是直接对元素进行的。</li><li>对于自定义类型：我们会需要类似 item.key() 这样的操作来取出待排序的元素主键，经过对主键的比较后，将<strong>数组中该主键对应的元素本身进行交换</strong>，以此来达到目的。</li></ul><div class="note info">            <p>在 Java 中，元素通常都是对象，对于主键的抽象<strong>通过内置的 Comparable 接口</strong>完成。例如基本类型以及字符串等常用于主键的数据类型都实现了 Comparable 接口，因此可以对这些数据类型的数组进行排序。如果需要定义自己的数据类型，只需要实现 Comparable 接口即可，在实现该接口时通过主键来定义元素的比较规则，从而完成主键比较逻辑的抽象。</p>          </div><p>你可能已经发现，说到底我们还是对基本类型数据进行排序，对数据类型无感的排序算法称为通用排序算法，我们将<strong>主要关注通用排序算法</strong>。而另一些排序算法利用了整型或字符串数据类型自身的特点而设计，因此相比通用排序算法拥有更高的性能，基于此我们可以将排序算法分为：</p><ul><li><strong>通用排序算法</strong></li><li>整型排序算法</li><li>字符串排序算法</li></ul><h2 id="排序的策略"><a class="markdownIt-Anchor" href="#排序的策略"></a> 排序的策略</h2><p>想要赢得排序比赛的胜利，我们需要有哪些策略呢？</p><p>策略一：<strong>比较</strong>策略，即排序的结果是通过比较元素本身产生的。我们想象一下打扑克的过程，在摸牌的过程中大多数人都会将手上的牌按照顺序排列，以便于更好的出牌。在摸牌过程中，我们很可能会将一张新牌与手中已经有序的牌从左向右依次比较，然后为其找到合适的位置，然后插入它。</p><p>策略二：<strong>信息</strong>策略，即排序的结果是通过对信息整合而重新生成的。举个例子，现在要排列 <code>[1, 2, 2, 1, 2, 3, 4, 1, 2, 3]</code> 这个数组，我们可以很轻松的按照比较策略生成排序的答案，但现在我直接告诉你这堆数字中有 3 个 1，4 个 2，2 个 3，1 个 4，我相信你不会依次比较了，而是依据我给你的<strong>信息</strong>，不假思索的写出排序的答案，你会先写 3 个 1，然后跟着写 4 个 2，最后按照提示依次写完正确答案。那么如何得到这个信息呢，你可以找一个小本本，肉眼遍历一遍数组，同时记下来每个数字出现的次数。其实就是使用<strong>额外的空间代价</strong>找到了对于原数组的一个等价表示，而结果是从这个等价表示中“恢复”出来的。</p><div class="note info">            <p>哪种策略更好？信息策略好像可以更快的得到结果。然而天下没有免费的午餐，更快的运行也导致了更多的空间使用，更糟糕的是并不是任何排序场景都可以容易的找到其等价的信息表示的。这本质上是一个 time-space trade-off 问题，根据不同的场景，选择合适的策略才是最重要的。</p>          </div><p>以上两种策略，对应了排序算法的一种分类依据，排序算法可以依据其排序思想分为两类：</p><ul><li>比较排序 (Comparison sorts) 基于<strong>比较和交换</strong>操作来进行排序。</li><li>非比较排序 (Non-comparison sorts) 基于<strong>使用额外的内存空间</strong>来进行排序。</li></ul><p>两类算法的显著区别就是其<strong>渐进时间复杂度</strong>和<strong>渐进空间复杂度</strong>的不同，对应了性能评估中的算法运行时间和额外内存使用。</p><h2 id="排序的场景"><a class="markdownIt-Anchor" href="#排序的场景"></a> 排序的场景</h2><p>根据场景选择合适的策略是很重要的，然而更加重要的是，如何根据场景选择合适的排序算法，虽然我们还没有介绍任何一种排序算法（我才不会告诉你我们在扑克牌游戏中使用了插入排序，在写数字游戏中使用了计数排序），但是首先明确究竟有哪些排序的场景，场景中重要的因素包括：</p><ul><li>排序数据的<strong>存储位置</strong>：存储在本机内存（数组）中？还是存储在本机硬盘（文件）上？通过网络流实时接收？还是存储在异地分布式集群中？</li><li>排序<strong>数据量</strong>：若干个元素？KB 级数据量？MB 级？GB 级？TB 级？超过内存上限的数据量？超过本地硬盘上限的数据量？</li><li>排序<strong>数据特征</strong>：数据是随机的吗？数据集是否符合某种概率分布函数？是不是大部分数据已经基本有序？甚至数据是不是基本是逆序排列的？数据是否允许重复？数据的重复程度高吗？</li></ul><p><strong>最普遍的场景是：以数组的形式存储在内存中，并且数据量不超过内存的容量，数据特征是无法预料的</strong>。然而对于以上场景因素的排列组合，可能出现多种多样的场景，我们需要考量具体的算法策略。例如有的排序算法思路天生就不适合大数据量，却在小数据量中拔得头筹等等，有的排序算法对于数据量无感，有的排序算法在数据重复程度高的场景下有着糟糕的性能。</p><p>由于大部分情况下我们在内存中使用数组排序，所以排序方法可以简单分为：</p><ul><li><strong>内部排序</strong>：数据均存储于本机内存。</li><li>外部排序：数据存储于本机硬盘、分布式集群等</li></ul><h1 id="性能评估"><a class="markdownIt-Anchor" href="#性能评估"></a> 性能评估</h1><p>可以通过以下几个维度评价一个排序算法，只有熟悉了某种算法的性能之后，才能在特定的场景下选择出最佳的算法。</p><h2 id="运行时间"><a class="markdownIt-Anchor" href="#运行时间"></a> 运行时间</h2><p>运行时间时评估排序算法性能的重要参考指标。在研究排序算法时，</p><ul><li>对于基于比较和交换的算法，需要计算<strong>比较</strong>和<strong>交换</strong>的数量。</li><li>对于不交换元素的算法，需要计算<strong>访问数组的次数</strong>。</li></ul><h2 id="额外内存"><a class="markdownIt-Anchor" href="#额外内存"></a> 额外内存</h2><p>排序算法的额外内存开销和运行时间是同等重要的性能评估指标。排序算法可分为两类：</p><ul><li>原地 (in-place) 排序算法除了<strong>函数调用栈</strong>和<strong>固定数目的实例变量</strong>外无需额外的内存。</li><li>其他排序算法需要<strong>额外内存空间</strong>来存储数组副本。</li></ul><h2 id="稳定性"><a class="markdownIt-Anchor" href="#稳定性"></a> 稳定性</h2><p>稳定性 (Stability) 是排序算法中不太重要的评估因素。<strong>稳定的排序算法保持相等键的相对次序不变</strong>。不过在多角度排序的场景下，稳定性是需要保障的，例如一个已经按照时间顺序进行排序的订单列表，我们将每一笔订单其按照金额进行重新排序，并且希望相同金额订单的时间先后顺序不被打破。</p><h2 id="适应性"><a class="markdownIt-Anchor" href="#适应性"></a> 适应性</h2><p>适应性 (Adaptability) 提供了另一种角度的性能指标，即<strong>待排序数据的分布规律是否会影响其性能</strong>，主要体现在运行时间上。对于一个通用排序算法，我们无法预料到数据的分布规则，因此我们希望其具有一定的适应性，以便在大多数情况下都保持良好性能。</p><h1 id="通用比较排序算法"><a class="markdownIt-Anchor" href="#通用比较排序算法"></a> 通用比较排序算法</h1><p><strong>比较排序算法也是通用排序算法</strong>，只需主键具有比较逻辑即可应用，可以用于所有排序的场合。以下是几种常见的比较排序算法。</p><h2 id="冒泡排序-bubble"><a class="markdownIt-Anchor" href="#冒泡排序-bubble"></a> 冒泡排序 (Bubble)</h2><h2 id="选择排序-selection"><a class="markdownIt-Anchor" href="#选择排序-selection"></a> 选择排序 (Selection)</h2><p>找到数组中最小元素，与第一个位置元素交换。找到数组中第二小的元素，与第二个位置元素交换。以此类推，直到全部排序完成。</p><p>特点：</p><ul><li>运行时间和输入无关。</li><li>数据移动最少，仅使用 N 次交换。</li></ul><p>Worst-case Performance|Best-case performance|Average performance|Worst-case space complexity</p><p>О(n2) comparisons, О(n) swaps<br>Average performance</p><h2 id="插入排序-insertion"><a class="markdownIt-Anchor" href="#插入排序-insertion"></a> 插入排序 (Insertion)</h2><h2 id="希尔排序-shell"><a class="markdownIt-Anchor" href="#希尔排序-shell"></a> 希尔排序 (Shell)</h2><p>取决于间隔序列，最好为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mn>4</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">n^{4/3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">/</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="归并排序-merge"><a class="markdownIt-Anchor" href="#归并排序-merge"></a> 归并排序 (Merge)</h2><p>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 表示一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数组排序时所需要的比较次数，易得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C(0)=C(1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，对于递归的 sort() 方法可以得到比较次数上限的递推关系。其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 分别是归并所需要的最大和最小比较次数，因此：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>C</mi><mo stretchy="false">(</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo><mo>+</mo><mi>C</mi><mo stretchy="false">(</mo><mo stretchy="false">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">C(n) \le C(\lfloor n/2 \rfloor) + C(\lceil n/2 \rceil) + n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mopen">⌊</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mopen">⌈</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌉</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>C</mi><mo stretchy="false">(</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo><mo>+</mo><mi>C</mi><mo stretchy="false">(</mo><mo stretchy="false">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">C(n) \le C(\lfloor n/2 \rfloor) + C(\lceil n/2 \rceil) + n/2 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mopen">⌊</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mopen">⌈</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌉</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span></span></p><p>我们考虑最简单的一种情况，假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">n=2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo>=</mo><mo stretchy="false">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\lfloor n/2 \rfloor = \lceil n/2 \rceil = 2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，可以得到</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>C</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C(2^k) = 2C(2^{k-1}) + 2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span></p><p>两边同时除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，则</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>k</mi></msup><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C(2^k)/2^k = C(2^{k-1})/2^{k-1} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>不断重复带入上式，得到</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>k</mi></msup><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>0</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><mi>k</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">C(2^k)/2^k = C(2^{k-2})/2^{k-2} + 1 + 1 = C(2^0)/2^0 + k = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p><p>两边同时乘以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，则</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><msup><mn>2</mn><mi>k</mi></msup><mo>=</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>∗</mo><mi>n</mi><mo>=</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">C(n) = C(2^k) = k2^k = \log n * n = n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>对于一般的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 来说，得到的准确值更复杂，但渐进复杂度是相同的。归并排序的实质是将待排序数组构造成一棵二叉树，从而减少了不必要的比较次数。其结果中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 表示树高，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 表示每层的比较次数，其乘积便是归并排序的渐进时间复杂度。</p><h2 id="快速排序-quick"><a class="markdownIt-Anchor" href="#快速排序-quick"></a> 快速排序 (Quick)</h2><h3 id="基本算法"><a class="markdownIt-Anchor" href="#基本算法"></a> 基本算法</h3><ul><li>别越界</li><li>保持随机性</li><li>终止循环</li><li>处理重复值</li><li>终止递归</li></ul><h3 id="三向快排"><a class="markdownIt-Anchor" href="#三向快排"></a> 三向快排</h3><p>要点：</p><ul><li>递归结束条件：<code>lo &gt;= hi</code></li><li>选取随机数作为比较值，并进行一次交换 <code>exch(lo, rand)</code>，比较数总为 <code>a[lo]</code>。</li><li>指定三个游标，lt = lo, i = lo + 1, gt = hi</li><li>arr[i] &lt; v，则 exch(arr, i++, lt++);</li><li>arr[i] &gt; v，则 exch(arr, i, gt–);</li><li>arr[i] = v, 则 i++;</li><li><strong>结束时，<code>[lt, gt]</code> 为相等区间。</strong></li><li>递归 [lo, lt-1] 和 [gt+1, hi]。</li></ul><p>其中 lt 和 gt 的变化为：</p><ul><li>lt 永远记录了第一个元素（比较元素）的下标，因此它也是返回边界的左边界；</li><li>gt 记录了待比较的元素下标，最后一轮是 i == gt 的时候，这表明只剩最后一次了，因此循环退出的条件是 i &gt; gt，在最后一次比较时<ul><li>arr[i] == pivot，此时 gt == i 指向最后一个相等元素。然后 i++，退出循环；</li><li>arr[i] &lt; pivot，则 arr[lt] 交换过来成为最后一个相等元素，其下标为 gt。然后 i++，退出循环；</li><li>arr[i] &gt; pivot，则该元素自交换一次，然后 gt–，此时 gt 指向最后一个相等元素，然后退出循环。</li></ul></li></ul><h2 id="比较排序总结"><a class="markdownIt-Anchor" href="#比较排序总结"></a> 比较排序总结</h2><p>比较排序的平均性能不可能好于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。比较排序对应了一个<strong>决策树模型</strong>，该模型是一个二叉树，每个分支节点表示了一次比较，每一个叶子节点代表了一种排序结果。在唯一有序的那一种结果里面，该节点到根节点的路径数表示了该算法的最少比较次数。排序 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个元素一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>n</mi></msubsup><mo>=</mo><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">A_n^n = n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span> 种结果，对于一颗具有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span> 个叶节点的二叉树，树的高度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 最少为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">\log n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>，因此，最少也需要经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 次比较才能完成排序。由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>≤</mo><msup><mi>n</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n! \le n^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，容易证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">!</mo><mo>≤</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n! \le n \log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>，我们现在需要找到其下界，从而得到比较次数的下界，证明如下：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>≥</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>log</mi><mo>⁡</mo><mi>i</mi><mo>≥</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><mi>n</mi></munderover><mi>log</mi><mo>⁡</mo><mi>i</mi><mo>≥</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><mi>n</mi></munderover><mi>log</mi><mo>⁡</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>−</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mstyle></mstyle></mstyle></mrow><annotation encoding="application/x-tex">h \ge \log n! = \displaystyle\sum_{i=1}^n \log i \ge \displaystyle\sum_{i=\frac{n}{2}}^n \log i \ge \displaystyle\sum_{i=\frac{n}{2}}^n \log \frac{n}{2} = \displaystyle\sum_{i=\frac{n}{2}}^n (\log n - 1) = \frac{n}{2} \log n - \frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1922820000000005em;vertical-align:-1.540885em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8499149999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.540885em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1922820000000005em;vertical-align:-1.540885em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8499149999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.540885em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1922820000000005em;vertical-align:-1.540885em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8499149999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.540885em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>因此，基于比较的排序算法，平均情况下其时间渐进复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，这也是其性能的上限。当然具体的算法系数不同，同样是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 算法其执行时间也可能差距很大，当然这是另外一回事了。</p><p>以下是常用比较排序算法的总结：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Best</th><th style="text-align:center">Average</th><th style="text-align:center">Worst</th><th style="text-align:center">Memory</th><th style="text-align:center">Stable</th><th style="text-align:center">Method</th></tr></thead><tbody><tr><td style="text-align:center">Bubble</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>(var <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>)</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center">Yes</td><td style="text-align:center">Exchanging</td></tr><tr><td style="text-align:center">Selection</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center">No</td><td style="text-align:center">Selection</td></tr><tr><td style="text-align:center">Insertion</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center">Yes</td><td style="text-align:center">Insertion</td></tr><tr><td style="text-align:center">Shell</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">1</td><td style="text-align:center">No</td><td style="text-align:center">Insertion</td></tr><tr><td style="text-align:center">Merge</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td style="text-align:center">Yes</td><td style="text-align:center">Merging</td></tr><tr><td style="text-align:center">Quick</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>(var <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>)</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></td><td style="text-align:center">No(typical) Yes(exits)</td><td style="text-align:center">Partitioning</td></tr></tbody></table><ul><li><code>-</code> 代表特殊，将在下文中详细说明。</li><li>var 表示算法变种，通常做了一些优化。</li></ul><div class="note info">            <p>Best vs Average vs Worst：</p><ul><li>最好情况往往是针对特定数据集做了优化，或者说该算法特别适合某种数据集，因此一般不作为重点考量。</li><li>平均情况代表了该算法的性能，因此主要也是描述一个<strong>算法性能的主要指标</strong>。</li><li>最差情况常常和平均情况相同，但需要程序员特别注意，否则在某些时候会造成性能的急剧下降。</li></ul>          </div><h1 id="整数排序算法"><a class="markdownIt-Anchor" href="#整数排序算法"></a> 整数排序算法</h1><p>在计算机科学中，<a class="btn" href="https://en.wikipedia.org/wiki/Integer_sorting" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>整数排序          </a> 是用于元素本身或元素主键是整数的数据集进行排序的算法，属于<strong>非比较排序算法</strong>。这使得算法的性能不再受限于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ，对键执行整数算术的能力使整数排序算法在很多情况下比比较排序算法更快，这取决于计算模型中允许进行哪些运算的细节以及要排序的整数的大小。</p><p>只要额外做一点工作，<strong>整数排序也可以用于主键是浮点数、有理数或字符串的数据集</strong>。严格来讲非比较排序算法的范围远大于整数排序，但整数排序可以用于主键是整数、浮点数、有理数、字符串的情况，这几乎是最常见的主键类型，因此也可以近似的将整数排序与非比较排序划上等号。</p><p>常用的整数排序有：</p><ul><li>Bucket sort</li><li>Pigeonhole sort</li><li>Counting sort</li><li>Radix sort</li></ul><h2 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h2><h2 id="鸽巢排序"><a class="markdownIt-Anchor" href="#鸽巢排序"></a> 鸽巢排序</h2><h2 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h2><h2 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h2><h1 id="字符串排序算法"><a class="markdownIt-Anchor" href="#字符串排序算法"></a> 字符串排序算法</h1><p>对于许多应用，决定顺序的主键为字符串，如果能够利用字符串的特殊性质将字符串的键排序，将会获得比通用排序效率更高的算法。</p><p>什么叫做利用了“字符串的特殊性质”。让我们看一看通用算法中字符串的比较过程，字符串的比较逻辑是：自左向右逐个字符按照字符序（字符对应的二进制数表示）比较，若相等则继续比较下一位，否则返回比较的结果，直到较短的一个比较结束。以 Java 中字符串比较为例：</p><figure class="highlight java"><figcaption><span>String.compareTo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other, <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; lim; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value[k] != other[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getChar(value, k) - getChar(other, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用通用算法，<strong>每次比较都需要对两个字符串进行扫描比较</strong>，字符串排序本质上没有任何新的思想，其正是优化了这个过程。</p><p>以下是两种完全不同的字符串排序算法：</p><table><thead><tr><th>名称</th><th>解释</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>低位优先 (least-significant-digit, LSD)</td><td>从右向左检查键中的字符</td><td></td><td>仅适用于键的长度都相同的字符串排序</td></tr><tr><td>高位优先 (most-significant-digit, MSD)</td><td>从左向右检查键中的字符</td><td>不需要检查所有的输入就能完成排序</td><td></td></tr></tbody></table><h2 id="键索引计数"><a class="markdownIt-Anchor" href="#键索引计数"></a> 键索引计数</h2><p>数组 a[N] 保存了 N 个元素，每个元素的键范围为 [0, R-1]，使用计数数组 count[R+1]，暂存数组 aux[N]。</p><p>步骤：</p><ol><li>频率统计。<code>for i in N count[a[i].key() + 1]++</code></li><li>频率转索引。<code>for r in R count[r+1] += count[r]</code></li><li>元素排序。<code>for i in N aux[count[a[i].key()]++] = a[i]</code></li><li>回写。<code>for i in N a[i] = aux[i]</code></li></ol><h2 id="低位优先字符串排序"><a class="markdownIt-Anchor" href="#低位优先字符串排序"></a> 低位优先字符串排序</h2><p>LSD (Least significant digit)<br>需求：</p><ul><li>字符串长度相同为 W</li><li>键索引计数法是稳定的</li><li>从右向左使用键索引排序 W 次</li></ul><p>对于基于 R 个字符字母表的 N 个长度为 W 的字符串为键的元素，低位优先的字符串排序需要访问 7WN+3WR 次数组，由于实际中 R 远小于 N，因此算法总运行时间与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">WN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 成正比，使用的额外空间与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>+</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">N+R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 成正比。</p><h2 id="高位优先字符串排序"><a class="markdownIt-Anchor" href="#高位优先字符串排序"></a> 高位优先字符串排序</h2><p>优化策略：</p><ul><li>小型子数组 - 小数组改插入排序</li><li>等值键 -</li><li>额外空间 - aux 无妨，count 爆炸</li></ul><h2 id="三向字符串快速排序"><a class="markdownIt-Anchor" href="#三向字符串快速排序"></a> 三向字符串快速排序</h2><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">Algorithms, 4th Edition</a></li><li><a href="https://www.toptal.com/developers/sorting-algorithms" target="_blank" rel="noopener">Sorting Algorithms Animations</a></li><li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">Sorting Algorithm, wikipedia</a></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualization</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash Table</title>
      <link href="/2020/02/17/algo-hash-table/"/>
      <url>/2020/02/17/algo-hash-table/</url>
      
        <content type="html"><![CDATA[<p>散列表 (Hash Table) 是实现字典 (Dictionary/Map) 的一种有效数据结构。</p><a id="more"></a><h1 id="直接寻址表-direct-address-table"><a class="markdownIt-Anchor" href="#直接寻址表-direct-address-table"></a> 直接寻址表 (Direct-address Table)</h1><p>直接寻址表可以使用<strong>数组直接实现</strong>，数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mn>0..</mn><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T[0..m-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的每个位置（槽，slot）对应于全域中一个关键字，元素的值直接存放到数组的槽中。此时，数组的下标即元素的关键字，数组的内容即元素的值。</p><p><img src="array.png" alt="array"></p><p>采用这样的设计必须由某种方法来来确定某个槽是否为空，例如约定某个特殊值为空。更进一步，我们可以将元素（键值对）存放到表外的一个对象，再由表中某个槽的指针指向该对象。这样槽中的值都存储了一个指向表外元素的对象，因此可以使用 null 空指针来表示该槽为空。</p><p><img src="dat.png" alt="dat"></p><p>经过改造的直接寻址表不仅可以方便的表示槽空的情况，也统一了槽中的数据类型，即都是元素指针，因此也能表示更加丰富的值类型，例如字符串或者自定义数据类型等。但也付出了额外的空间来存储元素，通常不需要在元素中存储关键字域，因为通过对象在表中的下标就可以得到关键字。</p><p>直接寻址表的字典操作实现很简单，并且执行速度很快，只需 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间。但同时也很明显，直接寻址表具有两个显著的缺陷，这表现在</p><ol><li>关键字不一定是一个整型数字 (Integer)。</li><li>巨大的内存占用。</li></ol><h1 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h1><p>散列表是直接寻址表概念的推广，每个位置（槽）存储一个关键字。</p><ul><li>全域 <em>U</em> : 所有可能的关键字集合</li><li>实际域 <em>K</em> : 实际存储的关键字集合</li><li>位置数 <em>M</em> : 表中可存储关键字的最大数量</li></ul><p>在直接寻址表中 <em>U</em> = <em>K</em> = <em>M</em>，然而在散列表中，<em>U</em> 远远大于 <em>K</em>。</p><h2 id="预散列-pre-hash"><a class="markdownIt-Anchor" href="#预散列-pre-hash"></a> 预散列 (Pre-hash)</h2><p>对于关键字不一定是整型数字的问题，我们可以采用<strong>预散列 (prehash)</strong> 将关键字域映射为一个自然数集 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">N=\{0,1,2,...\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mclose">}</span></span></span></span>。通过预散列，每个关键字将会被解释为一个自然数（可能很大）。</p><p>这样的方式有很多，例如 Python 中内置的 hash() 函数就可以完成类似的过程 <code>hash(object) -&gt; integer</code>。Java 中的 Object 类也提供了 hashCode() 成员函数来完成将各种类型转换为整数，并且支持用户在定义自己的数据类型时重写 hashCode 方法。笔者认为 hashCode 是更好的名字，因为 hash 这个名字应该留给下一节的散列过程。</p><h2 id="散列-hashing"><a class="markdownIt-Anchor" href="#散列-hashing"></a> 散列 (hashing)</h2><p>对于第二个问题，我们注意到直接寻址表中开辟了大量的内存用以存放空指针，这是不需要的，因此我们设法将全域 <em>U</em> 缩减到一个合理的规模 <em>M</em>，这样表中只需 <em>M</em> 个空间即可。</p><p>很明显，在直接寻址方式下，具有关键字 <em>k</em> 的元素被存放在槽 <em>k</em> 中，但缩减后的表明显不再具有关键字和槽一一对应的特性，因此我们需要<strong>散列 (hashing)</strong> 来完成对应过程。在散列方式下，该元素存放在槽 <em>h(k)</em> 中，即利用<strong>散列函数 (hash function)</strong> <em>h</em>，由关键字 <em>k</em> 计算出槽的位置。实际上 <em>h</em> 是一种映射，它将关键字的全域 <em>U</em> 映射到散列表 <code>T[0..m-1]</code> 的槽位上。即:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>:</mo><mi>U</mi><mo>→</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">h:U\rightarrow\{0,1,...,m-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span></p><p><strong>散列函数的目的是缩小处理的规模，将需要处理的值从 <em>U</em> 缩减到 <em>m</em>，降低空间开销，并且结合预散列过程，将任意类型的关键字，尽量均匀地散列为数组的索引</strong>。</p><h2 id="碰撞-collision"><a class="markdownIt-Anchor" href="#碰撞-collision"></a> 碰撞 (collision)</h2><p>对于任意的 <em>k</em>，有确定的 <em>h(k)</em> 与之对应，这意味着相同的关键字将会得到完全相同的散列值，但不可避免的会产生另一个问题：两个关键字可能被映射到同一个槽中，称为<strong>碰撞 (collision)</strong>。即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><msub><mi>k</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(k_i)=h(k_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，但是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>≠</mo><msub><mi>k</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">k_i \not = k_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。<br><img src="hash.png" alt="hash"></p><p>我们可以精心设计散列函数来尽力避免碰撞的产生，散列函数 <em>h</em> 是确定的，某一给定输入 <em>k</em> 始终产生相同的结果 <em>h(k)</em>，但是由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>U</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">|U|&gt;m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，因此一定会有散列值相同的关键字，因此完全避免碰撞是不可能的。解决碰撞可以通过<strong>链接法</strong>或<strong>开放寻址法</strong>来解决，不同的方式也决定了散列表的具体实现。</p><h1 id="链接散列表-hashing-with-chaining"><a class="markdownIt-Anchor" href="#链接散列表-hashing-with-chaining"></a> 链接散列表 (Hashing with Chaining)</h1><p>链接法解决碰撞的思路十分简单：<strong>把散列到一个槽中的所有元素放入链表中</strong>。基于这种策略的散列表称为<strong>链接散列表</strong>。</p><p><img src="chain.png" alt="chain"></p><h2 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h2><p>在进行分析之前，假设散列函数具有<strong>简单均匀散列 (simple uniform hashing)</strong> 特性，即：任何元素散列到每个槽中的可能性是相同的，且与其他元素被散列到什么位置上是无关的。</p><p><strong>查找</strong>一个给定关键字的元素需要多长时间？显然，最坏的情况就是所有的元素都被散列到一个槽中，散列表退化为链表，此时查找时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。在简单均匀散列的条件下，对于 <em>n</em> 个元素，<em>m</em> 个槽位的散列表，每条链的平均长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">n/m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">m</span></span></span></span>，将其定义为<strong>装载因子 (load factor)</strong>，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 表示。因此，一次不成功的查找最多需要检查 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 个元素，因此期望时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1+\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>，但需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><p>我们知道<strong>插入</strong>和<strong>删除</strong>操作最坏情况下需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间，因此可以说<strong>全部的字典操作平均情况下都可以在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间完成</strong>。</p><h2 id="散列函数"><a class="markdownIt-Anchor" href="#散列函数"></a> 散列函数</h2><p>一个好的散列函数应当（近似地）满足简单均匀散列的假设。同时，由于预散列过程的存在，所有的关键字假定为自然数。</p><h3 id="除法散列法"><a class="markdownIt-Anchor" href="#除法散列法"></a> 除法散列法</h3><p>最简单散列就是除法散列，通过一次将 <em>k</em> 对 <em>m</em> 取余操作即可完成散列，速度很快，且可以保证散列值在 [0, m-1] 范围内。散列函数为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">h(k)=k\;mod\;m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p><p>注意，<em>m</em> 不应该是 2 的幂，因为如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">m=2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 就是 <em>k</em> 的 <em>p</em> 个最低位数字，这样使得关键字和散列值相关性很强，因此散列值的分布特性很差，从而影响性能。推荐的 <em>m</em> 取值为<strong>与 2 的整数幂不太接近的质数</strong>。</p><h3 id="乘法散列法"><a class="markdownIt-Anchor" href="#乘法散列法"></a> 乘法散列法</h3><p>乘法散列法的散列函数为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>a</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><msup><mn>2</mn><mi>w</mi></msup><mo stretchy="false">]</mo><mo>≫</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(k)=[(a*k)\;mod\;2^w] \gg (w-r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p><ul><li><em>w</em> 是 <em>k</em> 的二进制位数</li><li><em>a</em> 是与 <em>k</em> 具有相同位数的一个随机数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><msup><mn>2</mn><mi>w</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \le a \le 2^w - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li><em>r</em> 是 <em>m</em> 的二进制位数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><msup><mn>2</mn><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">m = 2^r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span></li></ul><p>以上公式图形化解释如下，最后得到蓝色区域为散列值。因为 <em>r</em> 是 <em>m</em> 的二进制位数，因此可以保证最后散列值在 [0, m-1] 范围内。</p><p><img src="multi-hash.png" alt="multi-hash"></p><h3 id="全域散列-universal-hashing"><a class="markdownIt-Anchor" href="#全域散列-universal-hashing"></a> 全域散列 (Universal Hashing)</h3><h2 id="数据结构实现"><a class="markdownIt-Anchor" href="#数据结构实现"></a> 数据结构实现</h2><p>首先，作为一个支持字典操作的数据结构，链接散列表至少需要支持字典操作：</p><ul><li>插入 Insert(key, value)</li><li>查找 Search(key) -&gt; value</li><li>删除 Delete(key)</li></ul><p>从数据结构的角度看，为了支持这些操作，在散列表内部必须实现散列函数 <code>hash(key) -&gt; int</code> 来支持散列操作，散列函数应当包括预散列和散列两个过程。</p><p>在性能分析中，我们知道如果要保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的性能，需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，另外也出于对空间的考虑，<em>m</em> 不应该是固定的，而是应该根据插入元素数据量的大小动态调节，因此应当支持 <code>resize()</code> 操作，使得散列表可以根据 <em>n</em> 的值调整 <em>m</em>，通过<strong>动态扩容和缩容</strong>达到一种占用空间和运行时间上的平衡。</p><h1 id="开放寻址散列表-hashing-with-open-addressing"><a class="markdownIt-Anchor" href="#开放寻址散列表-hashing-with-open-addressing"></a> 开放寻址散列表 (Hashing with Open Addressing)</h1><p>回想一下链接法实现的散列表，当表中仍有空位的时候，碰撞的值仍然会新开辟一个空间（链表中新增的节点）来存储碰撞的元素。开放寻址法的思路是：通过某种探测方式，利用数组中的空槽来存储碰撞的元素。基于这种策略的所有的方法被称为<strong>开放寻址(Open Addressing)</strong>。开放寻址法不使用链表存储元素，而直接使用数组存储元素，其中每个槽只存储一个元素，因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>≥</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \ge n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，负载因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha \le 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p><p>在开放寻址中，插入一个元素需要<strong>探查/探测 (probe)</strong> 散列表的各项，直到找到一个空槽来放置元素。</p><h2 id="探测方法-probing"><a class="markdownIt-Anchor" href="#探测方法-probing"></a> 探测方法 (Probing)</h2><p>给定一个普通的散列函数作为辅助散列函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo>:</mo><mi>U</mi><mo>→</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">h^{\prime}:U\rightarrow\{0,1,...,m-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></p><h3 id="线性探测-linear-probing"><a class="markdownIt-Anchor" href="#线性探测-linear-probing"></a> 线性探测 (Linear probing)</h3><p>线性探测采用的散列函数为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo stretchy="false">)</mo><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>m</mi><mo separator="true">,</mo><mspace width="1em"></mspace><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h(k,i) = (h^{\prime}(k) + i)\;mod\;m,\quad i = 0,1,...,m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><h3 id="二次探测-quadratic-probing"><a class="markdownIt-Anchor" href="#二次探测-quadratic-probing"></a> 二次探测 (Quadratic probing)</h3><p>二次探测采用的散列函数为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo>+</mo><mi>i</mi><mo stretchy="false">)</mo><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>m</mi><mo separator="true">,</mo><mspace width="1em"></mspace><mi>i</mi><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>q</mi><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mi>q</mi><mn>2</mn></msup><mo separator="true">,</mo><mi>q</mi><mo>&lt;</mo><mo>=</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(k,i) = (h^{\prime} + i)\;mod\;m,\quad i = 1^2, -1^2, 2^2, -2^2, ... , q^2, -q^2, q &lt;= m/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V2Ray</title>
      <link href="/2020/01/26/tool-v2ray/"/>
      <url>/2020/01/26/tool-v2ray/</url>
      
        <content type="html"><![CDATA[<p>通过 VPS 以及 V2Ray 让奇怪的知识增加！</p><a id="more"></a><h1 id="硬件vps"><a class="markdownIt-Anchor" href="#硬件vps"></a> 硬件：VPS</h1><p>首先，笔者选择了一台海外的 VPS 服务商 <a href="https://www.vultr.com/" target="_blank" rel="noopener">Vultr</a>，主要原因如下：</p><ol><li>牌子比较大，不用担心跑路问题。</li><li>新人注册优惠（不定期，注册赠送若干刀，但有使用期限，到期清除）。</li><li>海外免除备案。</li><li>支持支付宝、微信支付，对国内用户比较方便。</li><li>按时收费，意味着随时可以销毁服务器，更换套餐。</li></ol><p>如果不考虑海外因素的话，对于学生党来说<strong>阿里云和腾讯云每月 10 元的学生优惠服务器</strong>将是首选。</p><h1 id="软件project-v-v2ray"><a class="markdownIt-Anchor" href="#软件project-v-v2ray"></a> 软件：Project V (V2Ray)</h1><p>V2Ray 是 Project V 下的一个工具。Project V 是一个包含一系列构建特定网络环境工具的项目，而 V2Ray 属于最核心的一个。 官方中介绍Project V 提供了单一的内核和多种界面操作方式。内核（V2Ray）用于实际的网络交互、路由等针对网络数据的处理，而外围的用户界面程序提供了方便直接的操作流程。不过从时间上来说，先有 V2Ray 才有 Project V。 如果还是不理解，那么简单地说，V2Ray 是一个与 Shadowsocks 类似的代理软件，可以用来科学上网学习国外先进科学技术。</p><p>以下是用户可以参考的资源：</p><ul><li><a href="https://github.com/v2ray/v2ray-core" target="_blank" rel="noopener">V2Ray Github</a></li><li><a href="https://www.v2ray.com/" target="_blank" rel="noopener">Project V (V2Ray) Official</a></li><li><a href="https://guide.v2fly.org/" target="_blank" rel="noopener">官方小白教程</a></li></ul><p>本文为笔者对于以上官网教程的重点记录。如果有条件，请直接阅读上述教程。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>从软件上 V2Ray 不区分服务器版和客户端版，也就是说在服务器和客户端运行的 V2Ray 是同一个软件，区别只是配置文件的不同。因此，通常情况下配置为：</p><ul><li>服务器为 Linux VPS</li><li>客户端形式很多（例如 PC、手机、路由器、网关等），基本可以归结为以下几种：<ul><li>Windows PC （笔者的情况，）</li><li>Linux (同服务器)</li><li>macOS (同服务器)</li><li>iOS (APP Store下载)</li><li>Android (Github 或者 Google Play Store下载)</li></ul></li></ul><h3 id="服务器安装"><a class="markdownIt-Anchor" href="#服务器安装"></a> 服务器安装</h3><p>首先进行时间校准，对于 VPS (Linux) 可以执行命令 date -R 查看时间</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/localtime</span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>在 Linux 操作系统， V2Ray 的安装有脚本安装、手动安装、编译安装 3 种方式，<strong>请使用官方提供的脚本安装</strong>，大佬随意。该脚本由 V2Ray 官方提供。该脚本仅可以在 Debian 系列或者支持 Systemd 的 Linux 操作系统使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)   <span class="comment"># 使用脚本一步安装（使用 curl）</span></span><br><span class="line">systemctl start v2ray   <span class="comment"># 启动 V2Ray</span></span><br></pre></td></tr></table></figure><p>服务器端安装完毕后会生成配置文件 <code>/etc/v2ray/config.json</code>，默认的配置已经保证可用，可以根据需求决定是否更改。如果需要更新 V2Ray，重新安装即可。在更新过程中会自动重启 V2Ray，但配置文件保持不变。</p><div class="note info">            <p>安装脚本也可以使用 wget 完成：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://install.direct/go.sh</span><br><span class="line">sudo bash go.sh</span><br></pre></td></tr></table></figure>          </div><div class="note warning">            <p><strong>确保防火墙相应端口打开</strong><br>该一键脚本不会自动配置防护墙，这也是根据不同的 VPS 所不同，有的可以开启响应端口，有的不行，所以出现上述问题应该马上检测防火墙中响应的端口是否开启，例如所设置端口为 1000，那么使用下面的命令开启端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=1000/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=1000/udp --permanent</span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>          </div><h3 id="客户端安装"><a class="markdownIt-Anchor" href="#客户端安装"></a> 客户端安装</h3><p>点<a href="https://github.com/v2ray/v2ray-core/releases" target="_blank" rel="noopener">这里</a>下载 V2Ray 的 Windows 压缩包:</p><ul><li>如果是 32 位系统，下载 v2ray-windows-32.zip</li><li>如果是 64 位系统，下载 v2ray-windows-64.zip</li></ul><p>下载速度慢或无法下载请考虑挂已有的翻墙软件来下载，下载并且解压之后会有下面这些文件：</p><ul><li>v2ray.exe 运行 V2Ray 的程序文件</li><li>wv2ray.exe 同 v2ray.exe，区别在于wv2ray.exe是后台运行的，不像 v2ray.exe 会有类似于 cmd 控制台的窗口。运行 V2Ray 时从 v2ray.exe 和 wv2ray.exe 中任选一个即可</li><li>config.json V2Ray 的配置文件，后面我们对 V2Ray 进行配置其实就是修改这个文件</li><li>v2ctl.exe V2Ray 的工具，有多种功能，除特殊用途外，一般由 v2ray.exe 来调用，用户不用太关心</li><li>geosite.dat 用于路由的域名文件</li><li>geoip.dat 用于路由的 IP 文件</li><li>其他</li></ul><p>实际上双击 v2ray.exe （或wv2ray.exe） 就可以运行 V2Ray 了，V2Ray 会读取 config.json 中的配置与服务器连接。</p><p>也可以选择拥有 GUI 的第三方客户端。同时，由于通常情况下我们使用浏览器上网，因此还需要一个为浏览器设置代理。综上，笔者的客户端环境为：</p><ul><li>客户端：V2RayN (Windows)</li><li>浏览器：Google Chrome</li><li>SOCKS 代理插件：SwitchyOmega</li></ul><div class="note info">            <p>如果是 Linux 或 macOS 的系统，其安装方式同服务器端一模一样，只是配置文件不同。</p>          </div><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2><p>其实各种科学上网的原理都是隧道，通过加密中转完成的，只不过手段不同，V2Ray 也不例外。</p><p>V2Ray 没有使用常规代理软件的 C/S（即客户端/服务器）结构，它既可以当做服务器也可以作为客户端，V2Ray 使用 inbound (传入) 和 outbound (传出) 的结构，这样的结构非常清晰地体现了数据包的流动方向，同时也使得 V2Ray 功能强大复杂的同时而不混乱，清晰明了。</p><p><img src="v2ray-node.png" alt="v2ray-node"></p><ul><li>需要配置至少一个入站协议（Inbound）和一个出站协议（Outbound）才可以正常工作。<ul><li>入站协议负责与客户端（如浏览器）通信：<ul><li>入站协议通常可以配置用户认证，如 ID 和密码等；</li><li>入站协议收到数据之后，会交给分发器（Dispatcher）进行分发；</li></ul></li><li>出站协议负责将数据发给服务器，如另一台主机上的 V2Ray。</li></ul></li><li>当有多个出站协议时，可以配置路由（Routing）来指定某一类流量由某一个出站协议发出。<ul><li>路由会在必要时查询 DNS 以获取更多信息来进行判断。</li></ul></li></ul><p>在这样的架构中，可以认为每一个 V2Ray 都是一个节点，inbound 是关于如何与上一个节点连接的配置，outbound 是关于如何与下一个节点连接的配置。对于第一个节点，inbound 与浏览器连接；对于最后一个节点，outbound与目标网站连接。以这样的角度理解的话：</p><ul><li>V2Ray 做客户端时，作为第一个节点，inbound 与浏览器链接，接收来自浏览器数据，由 outbound 发出去下一个节点 (通常是发到 V2Ray 服务器)；</li><li>V2Ray 做服务器时，作为第二个节点，inbound 接收来自 V2Ray 客户端（上一个节点）的数据，outbound 与目标网站连接，因此数据由 outbound 发出去(通常是如 Google 等想要访问的目标网站)。</li></ul><p>综上所述，数据包的转发主要经过四部分：浏览器（含插件）、V2Ray 客户端、V2Ray 服务端、目标网站。其流程架构图如下所示：</p><p><img src="architecture.png" alt="architecture"></p><h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h2><p>V2Ray 的配置文件为 JSON 格式，JSON，全称 JavaScript Object Notation，简而言之是 Javascript 中的对象（Object）。一个 JSON 文件包含一个完整的对象，以大括号“{”开头，大括号“}”结束。</p><p><strong>一个 JSON 对象包含一系列的键值对（Key-Value Pair）</strong>，一个键是一个字符串（String），而值有多种类型，常见的有字符串（String）、数字（Number）、布尔（Bool）、数组（Array）和对象（Object）。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"stringValue"</span>: <span class="string">"This is a string."</span>,</span><br><span class="line">  <span class="attr">"numberValue"</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">"boolValue"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"arrayValue"</span>: [<span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"string"</span>, <span class="string">"array"</span>],</span><br><span class="line">  <span class="attr">"objectValue"</span>: &#123;</span><br><span class="line">    <span class="attr">"another"</span>: <span class="string">"object"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件格式"><a class="markdownIt-Anchor" href="#文件格式"></a> 文件格式</h3><p>V2Ray 的配置文件形式如下，客户端和服务器通用一种形式，只是实际的配置不一样。</p><figure class="highlight json"><figcaption><span>config.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"log"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"api"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"dns"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"stats"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"routing"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"policy"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"reverse"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"inbounds"</span>: [],</span><br><span class="line">  <span class="attr">"outbounds"</span>: [],</span><br><span class="line">  <span class="attr">"transport"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>配置项</th><th>含义</th></tr></thead><tbody><tr><td>log: LogObject</td><td>日志配置，表示 V2Ray 如何输出日志。</td></tr><tr><td>api: ApiObject</td><td>内置的远程控置 API，详见远程控制配置。</td></tr><tr><td>dns: DnsObject</td><td>内置的 DNS 服务器，若此项不存在，则默认使用本机的 DNS 设置。详见DNS 配置</td></tr><tr><td>routing: RoutingObject</td><td>路由配置</td></tr><tr><td>policy: PolicyObject</td><td>本地策略可进行一些权限相关的配置，详见本地策略</td></tr><tr><td>inbounds: [InboundObject]</td><td>一个数组，每个元素是一个入站连接配置。</td></tr><tr><td>outbounds: [OutboundObject]</td><td>一个数组，每个元素是一个出站连接配置。列表中的第一个元素作为主出站协议。当路由匹配不存在或没有匹配成功时，流量由主出站协议发出。</td></tr><tr><td>transport: TransportObject</td><td>用于配置 V2Ray 如何与其它服务器建立和使用网络连接。详见底层传输配置</td></tr><tr><td>stats: StatsObject</td><td>当此项存在时，开启统计信息。</td></tr><tr><td>reverse: ReverseObject</td><td>反向代理配置。</td></tr></tbody></table><div class="note info">            <p>其中，主要的配置项为 <strong>inbounds 和 outbounds</strong>。详细配置项参见 <a href="https://www.v2ray.com/chapter_02/" target="_blank" rel="noopener">https://www.v2ray.com/chapter_02/</a></p>          </div><h3 id="入站项-inboundobject"><a class="markdownIt-Anchor" href="#入站项-inboundobject"></a> 入站项 InboundObject</h3><p>入站连接用于接收从客户端（浏览器或上一级代理服务器）发来的数据，可用的协议请见协议列表。前四项比较重要，其中 setting 包含了该协议的细节配置项，是主要配置的对象。</p><figure class="highlight json"><figcaption><span>config.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"port"</span>: <span class="number">1080</span>,</span><br><span class="line">  <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="attr">"protocol"</span>: <span class="string">"协议名称"</span>,</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"streamSettings"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"tag"</span>: <span class="string">"标识"</span>,</span><br><span class="line">  <span class="attr">"sniffing"</span>: &#123;</span><br><span class="line">    <span class="attr">"enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"destOverride"</span>: [<span class="string">"http"</span>, <span class="string">"tls"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"allocate"</span>: &#123;</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="string">"always"</span>,</span><br><span class="line">    <span class="attr">"refresh"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"concurrency"</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出站项-outboundobject"><a class="markdownIt-Anchor" href="#出站项-outboundobject"></a> 出站项 OutboundObject</h3><p>出站连接用于向远程网站或下一级代理服务器发送数据，可用的协议请见协议列表。前三项比较重要，其中 setting 包含了该协议的细节配置项，是主要配置的对象。</p><figure class="highlight json"><figcaption><span>config.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sendThrough"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">  <span class="attr">"protocol"</span>: <span class="string">"协议名称"</span>,</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"tag"</span>: <span class="string">"标识"</span>,</span><br><span class="line">  <span class="attr">"streamSettings"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"proxySettings"</span>: &#123;</span><br><span class="line">    <span class="attr">"tag"</span>: <span class="string">"another-outbound-tag"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mux"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由-routingobject"><a class="markdownIt-Anchor" href="#路由-routingobject"></a> 路由 RoutingObject</h3><p>V2Ray 内建了一个简单的路由功能，可以将入站数据按需求由不同的出站连接发出，以达到按需代理的目的。这一功能的<strong>常见用法是分流国内外流量，V2Ray 可以通过内部机制判断不同地区的流量，然后将它们发送到不同的出站代理。</strong></p><h2 id="协议格式"><a class="markdownIt-Anchor" href="#协议格式"></a> 协议格式</h2><p>V2Ray 支持以下协议：</p><table><thead><tr><th>名称</th><th>类型</th><th>简述</th></tr></thead><tbody><tr><td>Dokodemo-door</td><td>入站</td><td>Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。</td></tr><tr><td><strong>Blackhole</strong></td><td>出站</td><td>Blackhole（黑洞）会阻碍所有数据的出站，配合路由（Routing）一起使用，可以达到禁止访问某些网站的效果。</td></tr><tr><td><strong>Freedom</strong></td><td>出站</td><td>Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。</td></tr><tr><td>DNS</td><td>出站</td><td>DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。此出站协议只能接收 DNS 流量，一般不需要配置。</td></tr><tr><td><strong>Socks</strong></td><td>入站/出站</td><td>标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。</td></tr><tr><td><strong>Shadowsocks</strong></td><td>入站/出站</td><td>Shadowsocks 协议，包含入站和出站两部分，兼容大部分其它版本的实现。</td></tr><tr><td><strong>VMess</strong></td><td>入站/出站</td><td>VMess 是一个加密传输协议，它分为入站和出站两部分，通常作为 V2Ray 客户端和服务器之间的桥梁。</td></tr><tr><td>HTTP</td><td>入站/出站</td><td>主要用作兼容，一般不用。</td></tr><tr><td>MTProto</td><td>入站/出站</td><td>MTProto 是一个 Telegram 专用的代理协议。在 V2Ray 中可使用一组入站出站代理来完成 Telegram 数据的代理任务。</td></tr></tbody></table><div class="note info">            <p>详细配置见 <a href="https://www.v2ray.com/chapter_02/02_protocols.html" target="_blank" rel="noopener">https://www.v2ray.com/chapter_02/02_protocols.html</a></p>          </div><h3 id="socks"><a class="markdownIt-Anchor" href="#socks"></a> Socks</h3><p>socks 协议没有对传输加密，不适宜经公网中传输。虽然 socks outbound 可以作为对外访问的配置，但 socks outbound 更有意义的用法是在特殊情况下，只能使用socks proxy对外访问内部网络中，作为为其他协议连接代理服务器的前置代理使用。</p><p><strong>socks inbound 主要用法是在局域网或本机环境下，为其他程序提供本地服务。</strong></p><h3 id="vmess"><a class="markdownIt-Anchor" href="#vmess"></a> VMess</h3><p>VMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，所有数据使用 TCP 传输。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。</p><p><strong>VMess 依赖于系统时间</strong>，请确保使用 V2Ray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。</p><p>VMess 协议使用用户ID来提供类似密码的功能。ID 等价于 UUID，是一个 16 字节长的随机数，它的作用相当于一个令牌（Token）。 一个 ID 形如：de305d54-75b4-431b-adb2-eb6b9e546014，几乎完全随机，可以使用任何的 UUID 生成器来生成。用户 ID 需在配置文件中指定。</p><h3 id="shadowsocks"><a class="markdownIt-Anchor" href="#shadowsocks"></a> Shadowsocks</h3><p>V2Ray 作为一个代理工具集合，集成有 Shadowsocks 模块。用 V2Ray 配置成 Shadowsocks 服务器或者 Shadowsocks 客户端都是可以的，兼容 Shadowsocks-libev, go-shadowsocks2 等基于 Shadowsocks 协议的客户端。</p><p>配置与 VMess 大同小异，客户端服务器端都要有入口和出口，只不过是协议 (protocol) 和相关设置 (settings) 不同，不再赘述。</p><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><p>以下提供一个基本且常用的配置思路。</p><h3 id="tcp-传输"><a class="markdownIt-Anchor" href="#tcp-传输"></a> TCP 传输</h3><div class="tabs" id="tcp"><ul class="nav-tabs"><li class="tab active"><a href="#tcp-1">客户端</a></li><li class="tab"><a href="#tcp-2">服务端 (45.45.45.45)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tcp-1"><ul><li>设置入站：socks 协议 + 客户端地址 (127.0.0.1:10808)</li><li>设置出站：<ul><li>proxy：vmess 协议 + vnext 地址 (45.45.45.45:19999) + UUID (eb3dc148-97fb-4946-afac-bfbc304d40b4)</li><li>direct：freedom 协议</li><li>block：blackhole 协议</li></ul></li><li>设置路由：<ul><li>局域网以及国内网站流量走 direct</li><li>广告网站流量走 block</li><li>其他走 proxy</li></ul></li></ul></div><div class="tab-pane" id="tcp-2"><ul><li>设置入站：<ul><li>协议：protocol (vmess)</li><li>端口地址：port (19999)</li><li>用户 ID：UUID (eb3dc148-97fb-4946-afac-bfbc304d40b4)</li></ul></li><li>设置出站：<ul><li>direct：freedom 协议</li><li>block：blackhole 协议</li></ul></li><li>设置路由<ul><li>局域网走 block</li><li>其他走 freedom</li></ul></li></ul><p>以下是默认配置：</p><figure class="highlight json"><figcaption><span>/etc/v2ray/config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"inbounds"</span>: [&#123;</span><br><span class="line">    <span class="attr">"port"</span>: xxxxx,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"xxxxx"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"clients"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="string">"xxxxxxxxxxxxxxxxxxxxxxx"</span>,</span><br><span class="line">          <span class="attr">"level"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">"outbounds"</span>: [&#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">"routing"</span>: &#123;</span><br><span class="line">    <span class="attr">"rules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="attr">"ip"</span>: [<span class="string">"geoip:private"</span>],</span><br><span class="line">        <span class="attr">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div><h3 id="tcp-tls-websocket"><a class="markdownIt-Anchor" href="#tcp-tls-websocket"></a> TCP + TLS + WebSocket</h3><div class="tabs" id="tls+ws"><ul class="nav-tabs"><li class="tab active"><a href="#tls+ws-1">客户端</a></li><li class="tab"><a href="#tls+ws-2">服务端</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tls+ws-1"><ul><li>设置入站：socks 协议 + 客户端地址 (127.0.0.1:10808)</li><li>设置出站：<ul><li>proxy：vmess 协议 + vnext 地址 (<a href="http://domain.me:443" target="_blank" rel="noopener">domain.me:443</a>) + users (UUID: eb3dc148-97fb-4946-afac-bfbc304d40b4) + tls + ws</li><li>direct：freedom 协议</li><li>block：blackhole 协议</li></ul></li><li>设置路由：<ul><li>局域网以及国内网站流量走 direct</li><li>广告网站流量走 block</li><li>其他走 proxy</li></ul></li></ul></div><div class="tab-pane" id="tls+ws-2"><ul><li>设置入站：vmess 协议 + 端口地址 (443) + clients (UUID: eb3dc148-97fb-4946-afac-bfbc304d40b4) + tls (证书＋密钥) + ws</li><li>设置出站：<ul><li>direct：freedom 协议</li><li>block：blackhole 协议</li></ul></li><li>设置路由<ul><li>局域网走 block</li><li>其他走 freedom</li></ul></li></ul></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> Vultr </tag>
            
            <tag> V2Ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search</title>
      <link href="/2019/11/12/algo-binary-search/"/>
      <url>/2019/11/12/algo-binary-search/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky …<br>没想到眉清目秀的二分查找，折磨人起来可是毫不含糊。</p>            <i class="fa fa-quote-right"></i>          </blockquote><a id="more"></a><p>以上是 Donald Ervin Knuth 对于二分查找 (Binary Search) 的看法。的确，二分查找确实是一个思路简单，细节爆炸的算法。</p><h1 id="二分查找模板-两分支"><a class="markdownIt-Anchor" href="#二分查找模板-两分支"></a> 二分查找模板 - 两分支</h1><p>以下这个模板是用于 Leetcode 中的二分查找的，使用 Java 语言编写。只讨论输入 array 是非降序 (non-descending order) 的情况。</p><figure class="highlight java"><figcaption><span>BinarySearchTemplate</span><a href="/downloads/code/algo/search/BinarySearchTemplate.java">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTemplate</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">        <span class="comment">// Pre-processing:</span></span><br><span class="line">        <span class="comment">// handle some corner case or edge case</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flexible selection of boundary conditions</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right){</span><br><span class="line">            <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">            <span class="comment">// int mid = (left + right) &gt;&gt;&gt; 1;</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) {</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                right = mid;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Post-processing:</span></span><br><span class="line">        <span class="comment">// End Condition: left == right</span></span><br><span class="line">        <span class="keyword">if</span>(left != nums.length &amp;&amp; nums[left] == target) {</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        }                                                                                                                                                           </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="前处理"><a class="markdownIt-Anchor" href="#前处理"></a> 前处理</h2><p>主要用于处理一定查找不存在的情况，直接返回 -1：</p><ol><li>未给出待查找数据集合</li><li>该数据集合为空</li></ol><h2 id="边界条件选取"><a class="markdownIt-Anchor" href="#边界条件选取"></a> 边界条件选取</h2><p>边界条件选取依赖于具体情况，对于数组来说，可能有两种情况比较常用：</p><ol><li>左闭右闭区间 [left, right]</li><li>左闭右开区间 [left, right)</li></ol><p>在我们的模板中，<strong>使用第二种情况</strong>，其中 right 一般取 array.length，这主要是因为：</p><ul><li>二分查找无结果时，默认返回待插入位置的下标。</li><li>right - left 正好是当前搜索范围的长度。</li></ul><h2 id="循环条件"><a class="markdownIt-Anchor" href="#循环条件"></a> 循环条件</h2><p>在其他的二分模板中，可能使用 left &lt;= right 作为判断条件，对应的分支会分别更新左边界和右边界，此时循环退出时，往往需要讨论 left 和 right 哪个才是真正需要的值。</p><p>在本模板中，<strong>使用 left &lt; right 作为循环判断条件</strong>，这样当循环退出的时候，<strong>一定有 left == right</strong>，避免了一些判断的情况，虽然避免了 left 和 right 的讨论问题，但由此产生了新的问题。当然我认为这些代价是值得的。</p><h2 id="主体代码"><a class="markdownIt-Anchor" href="#主体代码"></a> 主体代码</h2><p>二分的主体首先需要进行中位数的计算，中位数索引计算至少隐含了两方面的问题：</p><ol><li>mid 值是否会溢出？</li><li>对于偶数个元素的数据集合，会产生两个中位数。我们称之为<strong>左中位数和右中位数</strong>。到底选择哪一个？选择这个是任意的还是有条件的？</li></ol><p>对于第一个问题，显然当 left 和 right 值都较大时，其和值会产生整型溢出。因此我们可以写成</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (length) / <span class="number">2</span>;  // length = <span class="built_in">right</span> - <span class="built_in">left</span></span><br></pre></td></tr></table></figure><div class="note info">            <p><strong>不推荐的 tricky 写法</strong><br>在 Java 中可以使用无符号移位 <code>&gt;&gt;&gt;</code> 来代替除法，并且不需要考虑溢出问题，可以写为 <code>int mid = (left + right) &gt;&gt;&gt; 1;</code>。与有符号右移 <code>&gt;&gt;</code> 不同的是，无符号右移总是将高位补零，因此当溢出时，本来最高位为 1 的负数又会重新成为正数。而在 JDK 中也是这么写的。其他语言同理，也可以使用无符号右移运算符。</p>          </div><p>对于第二个问题，当数组的</p><ul><li>元素为奇数个时，有唯一的中位数。</li><li>元素为偶数个时，有两个可用的中位数：<ul><li>下标较小的称为下位中位数</li><li>下标较大的称为上位中位数</li></ul></li></ul><p>我们我们在实际情况中，一般采用 <code>mid = left + (right - left) / 2</code> 来计算中位值，对于 C，Java 等自动取整的语言，其返回的总是<strong>上位中位数</strong>。因此，对于两种中位数的表示为：</p><ul><li>下位中位数：lowerMid = left + (length - 1) / 2</li><li>上位中位数：upperMid = left + length / 2 （不用 -1，就它了）</li></ul><p><strong>由于这两个中位数都在区间 [left, right) 内，所以都可以采用</strong>。</p><p>二分搜索写法可以分为求上下界两种，并转化为以下等价写法，可以解决各种细节问题：</p><ol><li>求下界：找满足 <code>x &gt;= value</code> 或 <code>x &gt; value</code> 条件的最小 <code>x</code> 的位置。</li><li>求上界：找满足 <code>x &lt; value</code> 或 <code>x &lt;= value</code> 条件的最大 <code>x</code> 的位置。</li></ol><div class="tabs" id="bound"><ul class="nav-tabs"><li class="tab active"><a href="#bound-1">求下界</a></li><li class="tab"><a href="#bound-2">求上界</a></li></ul><div class="tab-content"><div class="tab-pane active" id="bound-1"><figure class="highlight java"><figcaption><span>lower_bound</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target) &#123;    <span class="comment">// mid 值小于目标值更新区间</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="bound-2"><figure class="highlight java"><figcaption><span>upper_bound</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr[mid] &lt;= target) &#123;   <span class="comment">// mid 值小于等于目标值就更新区间</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>两者的区别仅仅是 if 中的条件不同而已！因此在 [first, last) 范围内搜索 value 的话：</p><ul><li>lower_bound(value) 本身找的是 <code>x &gt;= value</code> 的下界，若为 last 则不存在；</li><li>upper_bound(value) 本身找的是 <code>x &gt; value</code> 的下界，若为 last 则不存在；</li></ul><p>因为区间是离散的，所以：</p><ul><li>lower_bound(value) - 1 即为 <code>x &lt; value</code> 的上界，若为 <code>first - 1</code> 则不存在；</li><li>upper_bound(value) - 1 即为 <code>x &lt;= value</code> 的上界，若为 <code>first - 1</code> 则不存在；</li></ul><p>综上，在 [first, last) 范围内搜索 value 的结果应该是：<strong>[lower_bound(value), upper_bound(value))</strong>。</p><h2 id="后处理"><a class="markdownIt-Anchor" href="#后处理"></a> 后处理</h2><p>这一部分不是必须的，需要结合具体情景思考一下。</p><ul><li>如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，<strong>无需再做判断</strong>；</li><li>如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 <code>nums[left]</code> 或者 <code>nums[right]</code> （此时 <code>nums[left]</code> == <code>nums[right]</code>）单独作一次判断，看它是不是你要找的数即可。</li></ul><p>对于搜索目标值问题，不能保证目标值一定会在区间内出现，因此需要如下后处理，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">{A}\cap{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span> &lt;==&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>∪</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A}\cup\overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，所以还可以写成相反的条件，但两种方式都是一样的。</p><p>以下对 [lower_bound(value), upper_bound(value) - 1] 结果中两个最值的后处理。</p><div class="tabs" id="style"><ul class="nav-tabs"><li class="tab active"><a href="#style-1">lower_bound(val)</a></li><li class="tab"><a href="#style-2">upper_bound(val)-1</a></li></ul><div class="tab-content"><div class="tab-pane active" id="style-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == nums.length || nums[left] != target) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="style-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == first || nums[left - <span class="number">1</span>] != target) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div></div></div><h2 id="亿点细节"><a class="markdownIt-Anchor" href="#亿点细节"></a> 亿点细节</h2><p>上述代码我们主要做了以下几件事：<br>0. 使用下界搜索模型：即在 [first, last) 范围中中搜索 value，且总是找到最小下标的那个 value。</p><ol><li>确定循环终止条件 <code>l &lt; r</code>；这样循环结束之时，l == r 总成立。</li><li>使用上位中位数：<code>mid = left + (right - left) / 2</code>。</li><li>编写两个分支，其中一个分支总是左边界强收紧（向右归约） <code>left = mid + 1</code>，而另一个一定为 <code>right = mid</code>。</li><li>最后根据实际情况判断是否需要后处理。</li></ol><h3 id="搜索范围"><a class="markdownIt-Anchor" href="#搜索范围"></a> 搜索范围</h3><p>是否可以使用两端闭区间？可以但不推荐。使用闭区间会使得上述公式计算中位数不再返回上位中位数，因此可能产生死循环问题。推荐做法是将题意转为 [first, last) 这样的范围。</p><p>或者直接使用三分支模板！</p><h3 id="三分支-or-两分支"><a class="markdownIt-Anchor" href="#三分支-or-两分支"></a> 三分支 OR 两分支</h3><p>分支的编写也比较自然，我们通常会写出三个分支，分别为中位值大于、小于、等于目标值。在本模板中，我们可以依照具体情况来决定我们编写的分支个数：</p><ul><li>大部分情况下忽略了等于分支，因为中位数直接命中的几率是随着剩余元素个数降低而逐渐升高的，很好理解，剩的越少，直接命中几率越大，所以我们的<strong>思路是每次排除一半左右的元素</strong>，等到只剩一个元素的时候，再测试该值是否命中。这种情况下，我们可以我们需要编写两个分支：<strong>其中一个分支需要排除该元素，另一个分支不需要排除该元素。</strong>，结果是即使有多个相等的目标值，也总是找到最小下标的那个 value。</li><li>当返回任意一个相等的元素即可时，不忽略等于分支，这样可以使二分更早结束。</li></ul><h3 id="中位数与分支"><a class="markdownIt-Anchor" href="#中位数与分支"></a> 中位数与分支</h3><p><strong>通常情况下，证明该元素不是我们需要的值的条件判断比较容易写出</strong>，因此可以首先编写排除元素的分支。如果我们可以完成排除分支的编写，那么对于不排除元素的分支，我们就直接 else 即可，不用再思考。因此可以写为以下两种中的一种：</p><div class="tabs" id="shrink"><ul class="nav-tabs"><li class="tab active"><a href="#shrink-1">左边界强收紧</a></li><li class="tab"><a href="#shrink-2">右边界强收紧</a></li></ul><div class="tab-content"><div class="tab-pane active" id="shrink-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="shrink-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>看起来是没什么问题，但我们在上文中，均强调<strong>一定要使用左边界强收紧</strong>的情况，为什么呢？</p><p>因为我们的范围是 [first, last)，求中位数时候从<strong>下界</strong> left（闭区间侧）出发：<code>mid = left + (right - left) / 2</code>。这样的话，假设区间长度为 1 时，<code>mid = left + 1 / 2 = left</code> 仍然在 [left, left + 1) 这个区间中，然后进入判断分支，无论进入那个分支，都会不溢出不死循环的结束循环体。</p><ul><li>如果 left = mid + 1 的话，那么下一次 left == mid + 1 == left + 1，正常结束。</li><li>如果 right = mid 的话，那么下一次 mid = mid，正常结束。</li></ul><p>假设写成了右边界收紧呢？当区间长度为 1 时，<code>mid = left + 1 / 2 = left</code></p><ul><li>如果 right = mid - 1 的话，那么下一次范围为：[left, left - 1)，导致越界。</li><li>如果 left = mid 的话，那么下一次范围为：[mid, left + 1]，导致死循环。</li></ul><div class="note info">            <p>当你使用右边界强收紧的写法时，应该是在 (first, last] 这样的区间去找。此时中位数也要从闭区间侧出发 <code>int mid = right - (right - left) / 2</code> 才对。这样的结果是搜索的结果总会返回下标较大的元素。</p>          </div><h1 id="二分查找模板-三分支"><a class="markdownIt-Anchor" href="#二分查找模板-三分支"></a> 二分查找模板 - 三分支</h1><p>既然有了两分支查找，为何还要三分支查找？</p><p>三分支查找和二分查找对比，具有如下特点：<br>0. 二分支的查找范围为 [l, r)，三分支查找范围为 [l, r]。</p><ol><li><p>二分支结束时（假设没有后处理过程）：</p><ul><li>若查找成功，下标为 l == r</li><li>若查找失败，下标为 l == r == 该 target 应该存在的位置 == 第一个不小于该 target 元素的位置。</li></ul></li><li><p>三分支结束时：</p></li><li><p>适合集合中不存在目标值时直接返回 -1 的场景；<strong>二分支需要进行最后一次判断</strong>。</p></li><li><p>不适合当集合中不存在目标值时需要返回适合插入位置的场景；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTemplate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Pre-processing:</span></span><br><span class="line">        <span class="comment">// handle some corner case or edge case</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flexible selection of boundary conditions</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;                                          </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转有序数组的二分查找"><a class="markdownIt-Anchor" href="#旋转有序数组的二分查找"></a> 旋转有序数组的二分查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) &gt;&gt;&gt; <span class="number">1</span>;     <span class="comment">// 下位中位数</span></span><br><span class="line">            <span class="keyword">if</span> (target == nums[m]) <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= nums[m]) &#123; <span class="comment">// 有序区间</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[l] &amp;&amp; target &lt; nums[m]) &#123; <span class="comment">// target 在区间 [n[l], n[m]]</span></span><br><span class="line">                    r = m - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = m + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 转折区间</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[m] &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = m + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = m - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode"><a class="markdownIt-Anchor" href="#leetcode"></a> LeetCode</h1><table><thead><tr><th>ID</th><th>题目</th><th>特点</th></tr></thead><tbody><tr><td>162</td><td>寻找峰值</td><td>非排序数组也可以二分</td></tr></tbody></table><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">十分好用的二分查找法模板</a></li><li><a href="https://www.zhihu.com/question/36132386" target="_blank" rel="noopener">二分查找有几种写法？它们的区别是什么？</a></li><li><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound" target="_blank" rel="noopener">Cpp STL lower_bound</a></li><li><a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound" target="_blank" rel="noopener">Cpp STL upper_bound</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 解析命令行参数</title>
      <link href="/2019/03/27/python-parse-args/"/>
      <url>/2019/03/27/python-parse-args/</url>
      
        <content type="html"><![CDATA[<p>在编写程序时，有时候需要从系统中传入一些信息 (变量) 给程序使用。在编写命令行程序时，可以通过<strong>解析 Python 解释器的命令行参数</strong>来实现，在编写图形界面程序 (或者一些命令行程序) 时，还可以通过<strong>与系统交互</strong>来传递信息，例如<strong>读写系统环境变量</strong>，<strong>读写 (配置) 文件</strong>等。本文总结了 Python 中解析命令行参数的几种方法。</p><a id="more"></a><h1 id="sysargv-simple"><a class="markdownIt-Anchor" href="#sysargv-simple"></a> sys.argv — Simple</h1><p><a href="https://docs.python.org/3/library/sys.html" target="_blank" rel="noopener">sys — System-specific parameters and functions</a> 是一个 Python 中与系统相关的常用库，如果想要解析简单的命令行参数，最简单的方法是直接使用 <code>sys.argv</code>，<code>sys.argv</code> 是一个列表，存储了由系统解析的 Python 脚本的命令行参数。</p><ul><li>argv[0] 一般为脚本名称</li><li>argv[1:] 为其他参数</li></ul><div class="note info">            <p>注意，解释器名称，如 python, sh 都不包含在 argv 中。</p>          </div><p>例如：创建一个 Python 脚本如下</p><figure class="highlight python"><figcaption><span>test_sysargv.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.argv, len(sys.argv))</span><br></pre></td></tr></table></figure><p>在命令行执行该文件，得到结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python test_sysargv<span class="selector-class">.py</span> arg1 arg2 </span><br><span class="line">[<span class="string">'test_sysargv.py'</span>, <span class="string">'arg1'</span>, <span class="string">'arg2'</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure><p>总结：使用 <code>sys.argv</code> 简单直接，但是如果参数逻辑复杂，后续还需要完成手动解析参数的步骤。</p><h1 id="getopt-c-style-parser-for-command-line-options"><a class="markdownIt-Anchor" href="#getopt-c-style-parser-for-command-line-options"></a> getopt — C-style parser for command line options</h1><p>Python 中的 <a class="btn" href="https://docs.python.org/3/library/getopt.html" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>getopt          </a> 作为一个 C 风格的解析库，其抽象程度略高于直接使用 <code>sys.argv</code>，但其用法和写法类似与 C 语言的 getopt() 函数，其对新人不友好，对比下一节提到的 argparse 库，书写代码也更加臃肿。经过笔者的一次使用之后，便决定放弃使用该库，并将之前项目用到的 getopt 替换为 argparse 库。</p><div class="note info">            <p>如果你考虑使用 Python 库来帮助你解析命令行参数，并且想要拥有更清晰的参数处理逻辑，写更少的代码，输出更漂亮的帮助信息，那么推荐使用下一节中提到的库。</p>          </div><h1 id="argparse-parser-for-command-line-options-arguments-and-sub-commands"><a class="markdownIt-Anchor" href="#argparse-parser-for-command-line-options-arguments-and-sub-commands"></a> argparse — Parser for command-line options, arguments and sub-commands</h1><p>相比于 getopt 的不友好，<a class="btn" href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>argparse          </a> 模块使得编写对用户友好的命令行接口更加容易，argparse 不仅会帮助我们解析 sys.argv，并且还自动生成了规范格式的 help 以及 usage 等附加信息。<strong>同时，argparse 也是 <a href="https://www.python.org/dev/peps/pep-0389/" target="_blank" rel="noopener">PEP 389 – argparse - New Command Line Parsing Module</a> 推荐的</strong>。</p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><p>使用 argparse 库非常简单，只需 5 步：</p><ol><li>通过 <code>import argparse</code> 导入库；</li><li>通过 <code>parser = argparse.ArgumentParser()</code> 创建参数解析器；</li><li>通过 <code>parser.add_argument()</code> 为解析器添加待解析的参数及其解析方式；</li><li>通过 <code>args = parser.parse_args()</code> 生成解析后的参数对象；</li><li>通过调用 args 的成员使用对应的参数值，例如 <code>args.foo</code> 为参数 foo 的值。</li></ol><p>下面是官网提供的简单强大的例子，稍后你会看到一个详细的解析命令行参数的脚本模板。</p><figure class="highlight python"><figcaption><span>prog.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure><p>使用方式如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python prog<span class="selector-class">.py</span> -h</span><br><span class="line">... 一段格式清晰的帮助（省略） ...</span><br><span class="line">$ python prog<span class="selector-class">.py</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">$ python prog<span class="selector-class">.py</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --sum</span><br><span class="line"><span class="number">10</span></span><br><span class="line">$ python prog<span class="selector-class">.py</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c</span><br><span class="line">usage: prog<span class="selector-class">.py</span> [-h] [--sum] N [N ...]</span><br><span class="line">prog<span class="selector-class">.py</span>: error: argument N: invalid int value: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><h2 id="creating-a-parser"><a class="markdownIt-Anchor" href="#creating-a-parser"></a> Creating a Parser</h2><p>使用 ArgumentParser 创建一个 parser 对象，同时可以指定一些参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'A brief description about your program.'</span>)</span><br></pre></td></tr></table></figure><p>以下是一些常用的参数，更多参数查阅 <a class="btn" href="https://docs.python.org/3/library/argparse.html#argumentparser-objects" target="_blank" rel="noopener">            <i class="fa fa-book fa-fw fa-lg"></i>ArgumentParser objects          </a> :</p><table><thead><tr><th>Parameters</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>prog</td><td>程序名</td><td><code>sys.argv[0]</code> 一般是 Python 文件名</td></tr><tr><td>usage</td><td>使用方法</td><td>依据添加参数自动生成</td></tr><tr><td>description</td><td>在参数 help 内容之前添加描述</td><td>None</td></tr><tr><td>epilog</td><td>在参数 help 之后添加的内容</td><td>None</td></tr><tr><td>add_help</td><td>自动添加 <code>-h/--help</code> 参数</td><td>True</td></tr><tr><td>allow_abbrev</td><td>在无歧义的情况下允许长选项省略</td><td>True</td></tr></tbody></table><h2 id="adding-arguments"><a class="markdownIt-Anchor" href="#adding-arguments"></a> Adding Arguments</h2><p>通过调用 add_argument() 方法添加参数，也就是告诉 ArgumentParser 如何将命令行的字符串转变为合适的对象。这也是最需要费心编写的部分。</p><h3 id="name-or-flags"><a class="markdownIt-Anchor" href="#name-or-flags"></a> Name or flags</h3><p>add_argument() 的第一个参数值必须为<strong>一个或一系列</strong>参数名称/标志，<strong>参数分为可选参数 (optional arguments) 以及必选参数 (positional arguments)</strong>。以短横杠或双短横杠开头的，如 <code>-f</code> 或 <code>--foo</code> 将被解析成可选参数 (可省略)，不加任何前缀的将会被解析成必选参数 (不可省略)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>) <span class="comment"># 添加一个可选参数</span></span><br><span class="line">parser.add_argument(<span class="string">'bar'</span>)         <span class="comment"># 添加一个必选参数</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>为什么称呼为名称或标志呢？有时候，我们想通过命令行参数传递一些值，并以键值对的形式存储，例如 <code>python prog.py --ip=10.0.0.1</code> 可以给 ip 参数传递一个值，这时候 ip 就成为参数的<strong>名称 (name)</strong>。有时候，我们希望通过命令行参数指定某些特性，并不明显的指定一个值 (或者说其实存储了一个布尔型的值)，例如 <code>python prog.py --feature</code> 使得程序中打开某项特性，这时候 feature 成为了一个<strong>标志位 (flag)</strong>。<br>但两者本质是相同的。</p>          </div><h3 id="action"><a class="markdownIt-Anchor" href="#action"></a> action</h3><p>ArgumentParser 对象将命令行参数与 action 相关联，action 关键字参数指定应如何处理命令行参数。以下为各种 action 类型：</p><ul><li><code>store</code>：该参数仅能存储一个值，也是<strong>默认行为</strong>。</li><li><code>store_const</code>：将 const 关键字指定的值存储到该参数。<strong>常用于指定具有某种固定值的可选参数</strong>。</li><li><code>store_true</code> and <code>store_false</code>：为 <code>store_const</code> 的特例，用来存储布尔值，默认分别为 True 和 False。<strong>常与 dest 关键字结合用于标志位的设定。</strong></li><li><code>append</code>：允许同一个多次参数叠加使用，并将参数值存储为一个列表，如 <code>--foo 1 --foo 2</code> 将解析为 <code>foo=['1', '2']</code>。</li><li><code>append_const</code>：允许同一个参数多次叠加使用，并将参数值存储为一个列表，但参数必须由 const 关键字指定。</li><li><code>count</code>：计算某个参数出现的次数。<strong>常用于指定某种参数的等级</strong>。例如 <code>-vvv</code> 将会解析为 <code>v=3</code>。</li><li><code>help</code>：生成 help，<strong>默认自动添加</strong>即可。</li><li><code>version</code>：常用于<strong>指定软件版本</strong>。例如 <code>parser.add_argument('--version', action='version', version='%(prog)s 2.0')</code>，当执行 <code>--version</code> 时会输出 <code>PROG 2.0</code> 并且退出程序。</li></ul><h3 id="nargs"><a class="markdownIt-Anchor" href="#nargs"></a> nargs</h3><p>通常一个命令行参数对应一个 action，也就是“一次匹配-赋值动作”，<code>nargs</code> 关键字将多个不同的命令行参数对应到一个 action。</p><ul><li><code>N</code> (一个整数)：</li><li><code>?</code>：0个或一个</li><li><code>*</code>：0个或多个</li><li><code>+</code>：1个或多个</li><li><code>argparse.REMAINDER</code>：其余全部</li></ul><h3 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h3><p>这是一个可选的关键字，默认为 None，与 <code>store_const</code> 和 <code>append_const</code> 结合使用。</p><h3 id="default"><a class="markdownIt-Anchor" href="#default"></a> default</h3><p>所有的可选参数以及部分必选参数可以省略，当这些参数省略的时候，为它们指定一个默认值。</p><figure class="highlight python"><figcaption><span>optional_args</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, default=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'2'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(foo=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>positional_args</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'?'</span>, default=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'a'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(foo=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><h3 id="type"><a class="markdownIt-Anchor" href="#type"></a> type</h3><p>通过 type 关键字指定参数类型。</p><h3 id="choices"><a class="markdownIt-Anchor" href="#choices"></a> choices</h3><p>一些命令行参数有一定的要求，应从一组限定的值中选择，这时候应该使用 choices 关键字，choices 的值可以是任何支持 in 操作符的对象，如果用户提供了不在集合中的值，将会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'choices'</span>, choices=[<span class="string">'choice1'</span>, <span class="string">'choice2'</span>, <span class="string">'choice3'</span>])</span><br><span class="line">parser.add_argument(<span class="string">'door'</span>, type=int, choices=range(<span class="number">1</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><h3 id="help"><a class="markdownIt-Anchor" href="#help"></a> help</h3><p>使用 help 关键字可以为该参数提供一个简短的解释，当用户使用 help 时，每个参数的帮助都会被显示。几乎总应该提供该关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo the bars'</span>)</span><br></pre></td></tr></table></figure><h3 id="metavar"><a class="markdownIt-Anchor" href="#metavar"></a> metavar</h3><p>当 ArgumentParser 生成帮助消息时，它需要某种方式来引用每个预期的参数。默认情况下，使用 dest 值作为每个对象的名字，其中必选参数的 dest 是和参数名称相同，可选参数的 dest 是参数名称的大写。</p><div class="note info">            <p>metavar 只会更改显示的名称，由 parse_args() 解析出的真正的属性名称仍然只由 dest 值决定。所以，该参数我们基本不用更改，保持使用默认值即可。</p>          </div><h3 id="dest"><a class="markdownIt-Anchor" href="#dest"></a> dest</h3><p>大多数 ArgumentParser 操作都会添加一些值作为 parse_args() 返回的对象的属性。此属性的名称由 dest 关键字参数确定。对于必选参数动作，dest 通常为第一个add_argument() 的第一个参数，也就是前文提到的 name or flag；对于可选参数，通常为 name 去掉最前面的 <code>-</code>，如果名称中含有 <code>-</code>，则使用 <code>_</code> 代替。<strong>dest 关键字只在自定义该值的时候使用，否则采用默认值即可</strong>。</p><h2 id="parsing-arguments"><a class="markdownIt-Anchor" href="#parsing-arguments"></a> Parsing Arguments</h2><p>ArgumentParser 通过 parse_args() 方法 parse 参数，无需指定参数，ArgumentParser 会自动根据 <code>sys.argv</code> 解析参数并返回一个包含所有参数情况的 Namespace 对象，在程序中可以使用这个对象进行参数判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br><span class="line">print(type(args))</span><br><span class="line">print(args)</span><br></pre></td></tr></table></figure><h2 id="template"><a class="markdownIt-Anchor" href="#template"></a> Template</h2><p>经过上文，我们已经了解了大部分用法，虽然关键字选项很多，但是其中一些关键字我们基本不会用到。在大多数情况下，仅仅设置较少关键字即可达到我们对于某参数的要求，所以经过总结，一个完整的模板如下：</p><figure class="highlight python"><figcaption><span>test_argparse</span><a href="/downloads/code/python/test_argparse.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># Creating a parser</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        prog=<span class="string">'myprogram'</span>,</span><br><span class="line">        description=<span class="string">'A brief description about your program.'</span>,</span><br><span class="line">        epilog=<span class="string">'A brief epilog about your program.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adding a simple positional argument.</span></span><br><span class="line">    parser.add_argument(<span class="string">'echo'</span>, help=<span class="string">"echo the string you use here"</span>, default=<span class="string">'hello world'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Adding a optional argument with both the short and long format of the name. </span></span><br><span class="line">    parser.add_argument(<span class="string">'-v'</span>, <span class="string">'--verbosity'</span>, help=<span class="string">'Display some details.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adding a argument with a const value or none if not specified. </span></span><br><span class="line">    parser.add_argument(<span class="string">'--flag'</span>, action=<span class="string">'store_const'</span>, const=<span class="number">42</span>, help=<span class="string">'Set flag to 42 if specified, otherwise remains none.'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Enable or disable some feature, the value of this feature will be false initially, </span></span><br><span class="line">    <span class="comment"># because the second store_false action sets the default value of this attribute to false.</span></span><br><span class="line">    parser.add_argument(<span class="string">'--feature'</span>, dest=<span class="string">'feature'</span>, action=<span class="string">'store_true'</span>, help=<span class="string">'Enable this feature.'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--no-feature'</span>, dest=<span class="string">'feature'</span>, action=<span class="string">'store_false'</span>, help=<span class="string">'Disable this feature.'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Adding a argument which can be set twice and each value will be appended.</span></span><br><span class="line">    parser.add_argument(<span class="string">'--append'</span>, action=<span class="string">'append'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adding a argument with count action</span></span><br><span class="line">    parser.add_argument(<span class="string">'--counter'</span>, <span class="string">'-c'</span>, action=<span class="string">'count'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adding version argument</span></span><br><span class="line">    parser.add_argument(<span class="string">'--version'</span>, action=<span class="string">'version'</span>, version=<span class="string">'%(prog)s 1.0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adding a argument with more values</span></span><br><span class="line">    parser.add_argument(<span class="string">'--one'</span>, nargs=<span class="number">1</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--two'</span>, nargs=<span class="number">2</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--zero-or-one'</span>, nargs=<span class="string">'?'</span>, const=<span class="string">'c'</span>, default=<span class="string">'d'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--zero-to-more'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--one-to-more'</span>, nargs=<span class="string">'+'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--other'</span>, nargs=argparse.REMAINDER)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a argument with a default value (of the specified type).</span></span><br><span class="line">    parser.add_argument(<span class="string">'pos-default1'</span>, nargs=<span class="string">'?'</span>, default=<span class="string">'positional1'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'pos-default2'</span>, nargs=<span class="string">'*'</span>, default=<span class="string">'positional2'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--none-default'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--any-default'</span>, default=<span class="string">'42'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--int-default'</span>, default=<span class="number">42</span>, type=int)</span><br><span class="line">    parser.add_argument(<span class="string">'--float-default'</span>, default=<span class="number">42.5</span>, type=float)</span><br><span class="line">    parser.add_argument(<span class="string">'--file-default'</span>, default=<span class="string">'test_argparse.py'</span>, type=open)</span><br><span class="line">    parser.add_argument(<span class="string">'--sup-default'</span>, default=argparse.SUPPRESS)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adding a argument with some choices.</span></span><br><span class="line">    parser.add_argument(<span class="string">'choices'</span>, choices=[<span class="string">'left'</span>, <span class="string">'mid'</span>, <span class="string">'right'</span>])</span><br><span class="line">    parser.add_argument(<span class="string">'--int-choice'</span>, type=int, choices=range(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Parsing arguments</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Dispaly args and its type.</span></span><br><span class="line">    print(<span class="string">'----------------------- Args ------------------------------'</span>)</span><br><span class="line">    print(type(args))</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display all args line by line.</span></span><br><span class="line">    print(<span class="string">'----------------------- More details ------------------------------'</span>)</span><br><span class="line">    args_dict = args.__dict__</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args_dict.keys():</span><br><span class="line">        print(arg, <span class="string">'='</span>, args_dict[arg], <span class="string">', type:'</span>, type(args_dict[arg]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ... do something with args[.ARGS] ...</span></span><br></pre></td></tr></table></figure><h1 id="see-also"><a class="markdownIt-Anchor" href="#see-also"></a> See Also</h1><ul><li><a href="https://docs.python.org/3/howto/argparse.html" target="_blank" rel="noopener">Argparse Tutorial</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenFlow Specification</title>
      <link href="/2019/02/23/sdn-openflow/"/>
      <url>/2019/02/23/sdn-openflow/</url>
      
        <content type="html"><![CDATA[<p>OpenFlow 是 SDN 中使用最广泛的协议，本文记录了笔者对于 OpenFlow 通信流程的理解，绝大部分内容参考 OpenFlow 协议规格书，例如 <a href="https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.5.1.pdf" target="_blank" rel="noopener">OpenFlow Switch Specification Version 1.5.1 ( Protocol version 0x06 )</a>。</p><a id="more"></a><h1 id="openflow-通信流程"><a class="markdownIt-Anchor" href="#openflow-通信流程"></a> OpenFlow 通信流程</h1><h2 id="建立-tcp-连接"><a class="markdownIt-Anchor" href="#建立-tcp-连接"></a> 建立 TCP 连接</h2><p>SDN 控制器和交换机进行常规 TCP 三次握手，建立连接。TCP 是 OpenFlow 底层的通信协议，是整一套系统的基础设施。</p><h2 id="互相问好-ofpt_hello"><a class="markdownIt-Anchor" href="#互相问好-ofpt_hello"></a> 互相问好 - OFPT_HELLO</h2><p>创建 TCP 连接之后：</p><ul><li>交换机首先向控制器发送 OFPT_HELLO 数据包。</li><li>随后控制器也会回复 OFPT_HELLO 数据包给交换机。</li></ul><p>Hello 过程中：</p><ul><li>目的：协议协商。</li><li>内容：本方支持的最高版本的协议。</li><li>成果：使用双方都支持的最低版本协议。</li><li>成功：建立连接。</li><li>失败：OFPT_ERROR (TYPE:OFPT_HELLO_FAILED,CODE =0),终止连接。</li></ul><h2 id="交换机信息交互-ofpt_features"><a class="markdownIt-Anchor" href="#交换机信息交互-ofpt_features"></a> 交换机信息交互 - OFPT_FEATURES</h2><p>完成 Hello 包交互之后：</p><ul><li>控制器向交换机发送 OFPT_FEATURES_REQUEST <strong>请求交换机信息</strong>。</li><li>交换机向控制器回复 OFPT_FEATURES_REPLY <strong>告知控制器信息</strong>。</li></ul><p>OFPT_FEATURES_REQUEST 包<strong>没有数据内容</strong>，如下图所示：</p><p><img src="OFPT_FEATURES_REQUEST.png" alt="OFPT_FEATURES_REQUEST"></p><p>OFPT_FEATURES_REPLY 包含了交换机自己的 features，回复给控制器之后，控制器就对交换机有了一个全面的了解，从而为后面的控制提供的控制信息。其中最主要的是 <strong>Datapath ID</strong>，即交换机的编号。</p><p><img src="OFPT_FEATURES_REPLY.png" alt="OFPT_FEATURES_REPLY"></p><ul><li>datapath id 数据通道标识符，用来表示交换机的身份。在每一个控制器中独一无二。</li><li>n_buffers 一次最多缓存的数据包数量，即交换机自己的缓存能力。</li><li>n_tables 表示交换机支持的流表数量。</li><li>capabilities 交换机端口所支持的功能.</li></ul><div class="note info">            <p>OpenFlow 1.0 的 OFPT_FEATURES 包含了交换机和端口的信息，由于在 1.3 及其以后，端口消息移到了 Multipart 中，因此无法看到端口信息。</p>          </div><h2 id="端口信息交互-ofpt_multipart"><a class="markdownIt-Anchor" href="#端口信息交互-ofpt_multipart"></a> 端口信息交互 - OFPT_MULTIPART</h2><p>OpenFlow 1.3协议将 stats 框架更名为 multipart 框架，并且将端口描述移植到 OFPT_MULTIPART 消息中。</p><p>当控制器获取到交换机的信息之后，开始获取端口信息：</p><ul><li>控制器通过 OFPT_MULTIPART_REQUEST 消息查询交换机的端口信息，消息体为：OFPMP_PORT_DESC</li><li>交换机通过 OFPT_MULTIPART_REPLY 回复控制器的查询，回复的内容包括交换机端口的性能，特性等。</li></ul><h2 id="控制器下发配置-ofpt_set_config"><a class="markdownIt-Anchor" href="#控制器下发配置-ofpt_set_config"></a> 控制器下发配置 - OFPT_SET_CONFIG</h2><p>控制器通过 OFPT_SET_CONFIG 消息下发配置，并且通过 OFPT_GET_CONFIG_REQUEST 获取交换机的配置，用来确保下发成功了。</p><p>现在有一个问题，我们默认数据下发的顺序不会在传输中发生变化，也就是交换机依次收到了两个消息，交换机先进行设置，然后构造 OFPT_GET_CONFIG_REPLY 来回复，假设此时交换机在还没有完成设置的情况下，便回复了 OFPT_GET_CONFIG_REPLY 消息，那么可能造成配置上报的不正确。</p><p>因此，当控制器要确保某消息的依赖操作已经在交换机完成，或要接收有关完成操作的通知时，它可以使用 OFPT_BARRIER_REQUEST 消息。该消息没有内容，交换机收到 OFPT_BARRIER_REQUEST 消息后，必须完成所有在 OFPT_BARRIER_REQUEST 之前接受到的消息的处理过程（包括发送相应的答复或错误消息），才能执行后续消息处理。</p><p>如下图所示，控制器直接下发了三条连续的 OpenFlow 消息，</p><p><img src="OFPT_GET_CONFIG_REQUEST.png" alt="OFPT_GET_CONFIG_REQUEST"></p><p>交换机在回复屏障消息之后，再回复查询配置消息。</p><p><img src="OFPT_GET_CONFIG_REPLY.png" alt="OFPT_GET_CONFIG_REPLY"></p><h2 id="保持连接状态-ofpt_echo"><a class="markdownIt-Anchor" href="#保持连接状态-ofpt_echo"></a> 保持连接状态 - OFPT_ECHO</h2><p>当没有其他的数据包进行交换时，为了确保通信通畅，控制器需要查询连接状态。</p><ul><li>控制器会定期循环给交换机发送 OFPT_ECHO_REQUEST。</li><li>交换机收到后回复 OFPT_ECHO_REPLY。</li></ul><p>如下图所示：</p><p><img src="OFPT_ECHO_REQUEST.png" alt="OFPT_ECHO_REQUEST"></p><p><img src="OFPT_ECHO_REPLY.png" alt="OFPT_ECHO_REPLY"></p><h1 id="数据包结构"><a class="markdownIt-Anchor" href="#数据包结构"></a> 数据包结构</h1><h2 id="openflow-包头-header"><a class="markdownIt-Anchor" href="#openflow-包头-header"></a> OpenFlow 包头 (Header)</h2><p>每个 OpenFlow 包/消息都以 OpenFlow Header 开始。</p><figure class="highlight c"><figcaption><span>OpenFlow Header</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header on all OpenFlow packets. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ofp_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> version; <span class="comment">/* OFP_VERSION. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> type; <span class="comment">/* One of the OFPT_ constants. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> length; <span class="comment">/* Length including this ofp_header. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> xid; <span class="comment">/* Transaction id associated with this packet. </span></span><br><span class="line"><span class="comment">                  Replies use the same id as was in the request to facilitate pairing. */</span></span><br><span class="line">&#125;;</span><br><span class="line">OFP_ASSERT(<span class="keyword">sizeof</span>(struct ofp_header) == <span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>version：OpenFlow 协议版本</li><li>type：表示该包/消息的类型，OpenFlow 协议中的消息按照通信的方式可以分为 <strong>Controller to Switch 消息，Asynchronous 消息，symmetric 消息</strong>三种。</li><li>length：数据包的总长度 (包含头部)，由于 header 最少为 8 字节，因此 length 最少为 8。</li><li>transaction id (xid)：事务 ID 其实就是数据包编号，<strong>请求包和回复包的事务 ID 是相同的，表示两者共同完成了一件事</strong>。</li></ul><p>头部中类型字段的值如下：</p><ul><li><strong>控制器/交换机消息由控制器发送</strong>，可能需要也可能不需要交换机的响应。</li><li><strong>异步消息无需征得控制器同意便可以由交换机发送</strong>，交换机将异步消息发送给控制器，表示数据包到达、交换机状态更改或错误。</li><li><strong>对称消息无需征得对方同意便可以双向发送</strong>，可以是交换机先发送，也可以是控制器先发送。</li></ul><figure class="highlight c"><figcaption><span>OpenFlow Message Type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ofp_type &#123;</span><br><span class="line">    <span class="comment">/* Immutable messages. */</span></span><br><span class="line">    OFPT_HELLO              = <span class="number">0</span>,  <span class="comment">/* Symmetric message */</span></span><br><span class="line">    OFPT_ERROR              = <span class="number">1</span>,  <span class="comment">/* Symmetric message */</span></span><br><span class="line">    OFPT_ECHO_REQUEST       = <span class="number">2</span>,  <span class="comment">/* Symmetric message */</span></span><br><span class="line">    OFPT_ECHO_REPLY         = <span class="number">3</span>,  <span class="comment">/* Symmetric message */</span></span><br><span class="line">    OFPT_EXPERIMENTER       = <span class="number">4</span>,  <span class="comment">/* Symmetric message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch configuration messages. */</span></span><br><span class="line">    OFPT_FEATURES_REQUEST   = <span class="number">5</span>,  <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_FEATURES_REPLY     = <span class="number">6</span>,  <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_GET_CONFIG_REQUEST = <span class="number">7</span>,  <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_GET_CONFIG_REPLY   = <span class="number">8</span>,  <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_SET_CONFIG         = <span class="number">9</span>,  <span class="comment">/* Controller/switch message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Asynchronous messages. */</span></span><br><span class="line">    OFPT_PACKET_IN          = <span class="number">10</span>, <span class="comment">/* Async message */</span></span><br><span class="line">    OFPT_FLOW_REMOVED       = <span class="number">11</span>, <span class="comment">/* Async message */</span></span><br><span class="line">    OFPT_PORT_STATUS        = <span class="number">12</span>, <span class="comment">/* Async message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Controller command messages. */</span></span><br><span class="line">    OFPT_PACKET_OUT         = <span class="number">13</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_FLOW_MOD           = <span class="number">14</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_GROUP_MOD          = <span class="number">15</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_PORT_MOD           = <span class="number">16</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_TABLE_MOD          = <span class="number">17</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Multipart messages. */</span></span><br><span class="line">    OFPT_MULTIPART_REQUEST      = <span class="number">18</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_MULTIPART_REPLY        = <span class="number">19</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Barrier messages. */</span></span><br><span class="line">    OFPT_BARRIER_REQUEST    = <span class="number">20</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_BARRIER_REPLY      = <span class="number">21</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Controller role change request messages. */</span></span><br><span class="line">    OFPT_ROLE_REQUEST       = <span class="number">24</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_ROLE_REPLY         = <span class="number">25</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Asynchronous message configuration. */</span></span><br><span class="line">    OFPT_GET_ASYNC_REQUEST  = <span class="number">26</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_GET_ASYNC_REPLY    = <span class="number">27</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_SET_ASYNC          = <span class="number">28</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Meters and rate limiters configuration messages. */</span></span><br><span class="line">    OFPT_METER_MOD          = <span class="number">29</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Controller role change event messages. */</span></span><br><span class="line">    OFPT_ROLE_STATUS        = <span class="number">30</span>, <span class="comment">/* Async message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Asynchronous messages. */</span></span><br><span class="line">    OFPT_TABLE_STATUS       = <span class="number">31</span>, <span class="comment">/* Async message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Request forwarding by the switch. */</span></span><br><span class="line">    OFPT_REQUESTFORWARD     = <span class="number">32</span>, <span class="comment">/* Async message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bundle operations (multiple messages as a single operation). */</span></span><br><span class="line">    OFPT_BUNDLE_CONTROL     = <span class="number">33</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line">    OFPT_BUNDLE_ADD_MESSAGE = <span class="number">34</span>, <span class="comment">/* Controller/switch message */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Controller Status async message. */</span></span><br><span class="line">    OFPT_CONTROLLER_STATUS  = <span class="number">35</span>, <span class="comment">/* Async message */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h1><p>本文描述了 OpenFlow 逻辑交换机的技术特性，包括交换机组成部分，基本功能，以及 OpenFlow 控制器如何通过 OpenFlow switch 协议管理交换机。其他关于 OpenFlow 协议和 SDN 的文档可以在 <a class="btn" href="https://www.opennetworking.org/" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>Open Networking Foundation website          </a> 找到。</p><p>一个 OpenFlow 交换机的主要组成部分如下图所示：<br><img src="switch-components.png" alt="switch-components"></p><h1 id="switch-components"><a class="markdownIt-Anchor" href="#switch-components"></a> Switch Components</h1><p>一个 OpenFlow 逻辑交换机包括：</p><ul><li>一个或多个流表 (one or more flow tables) 以及一个组表 (a group table)，它们用来实现包的查询，转发。</li><li>一个或多个 OpenFlow 通道 (one or more OpenFlow channels)，用来与外部控制器通信。</li></ul><p>通过 OpenFlow switch 协议，控制器可以主动的或被动的在 flow table 中加入、更新、删除 flow entries，每个 flow entry 都包含 match fields，counters，以及 a set of instructions 用来匹配包。</p><p>匹配从管线 pipline 中的第一个 flow table 开始，并且可能持续匹配多个 flow tables。在每个流表中，</p><h1 id="openflow-ports"><a class="markdownIt-Anchor" href="#openflow-ports"></a> OpenFlow Ports</h1><p>OpenFlow 端口 (port) 是传输包的网络接口，如同 Ethernet 端口一样，OpenFlow 交换机之间通过端口相连组成网络。</p><p>网络中的 OpenFlow 包从交换机的 <strong>输入端口 (ingress port)</strong> 进入，经过 pipline 处理，然后从 <strong>输出端口 (output port)</strong> 转发到网络中 (如果需要转发的话)。</p><p>OpenFlow 交换机必须支持三种类型的端口：</p><ol><li>物理端口 (physical ports)</li><li>逻辑端口 (logical ports)</li><li>保留端口 (reserved ports)</li></ol><h2 id="standard-ports"><a class="markdownIt-Anchor" href="#standard-ports"></a> Standard Ports</h2><p>OpenFlow 标准端口定义为物理端口，逻辑端口以及可选的 LOCAL 保留端口 (不包括其他的保留端口)。标准端口的含义是 OpenFlow-only 交换机所支持的端口。</p><h2 id="physical-ports"><a class="markdownIt-Anchor" href="#physical-ports"></a> Physical Ports</h2><p>物理端口是由交换机定义的端口，由交换机对应的硬件决定的。例如一个以太网交换机，物理端口和以太网接口是一一对应的。</p><p>在某些部署环境中，OpenFlow 交换机是虚拟于硬件之上的，在这种情况下，物理端口可能表示该交换机对应硬件接口的一个虚拟的切片 (a virtual slice of the corresponding hardware interface of the switch)。</p><h2 id="logical-ports"><a class="markdownIt-Anchor" href="#logical-ports"></a> Logical Ports</h2><p>OpenFlow 逻辑端口是交换机定义的端口，与交换机的硬件接口不直接对应。逻辑端口是更高级别的抽象，可以由交换机通过非OpenFlow 方法 (例如，链路聚合组、隧道、环回接口) 定义。逻辑端口可以包括包封装，并且可以映射到各种物理端口。</p><p>物理端口和逻辑端口之间的唯一区别是，与逻辑端口关联的数据包可能有一个称为 tunnel-ID 的额外管道字段与其关联，当逻辑端口上接收到的数据包发送到控制器时，其逻辑端口和对应的物理端口都会报告给控制器。</p><h2 id="reserved-ports"><a class="markdownIt-Anchor" href="#reserved-ports"></a> Reserved Ports</h2><p>保留端口是由协议所规定的，表示一类端口，用来指定通用的转发操作。一个交换机不需要支持所有的保留端口，以下需要支持的使用 required 标识：</p><ul><li>Required: ALL: 表示交换机可用于转发特定数据包的所有端口。</li><li>Required: CONTROLLER: 表示和控制器相连的控制通道端口。</li><li>Required: TABLE:</li><li>Required: IN_PORT: 表示包进入端口。只能用作输出端口，将包从进入端口转发出去。</li><li>Required: ANY: 用于一些 OpenFlow 请求中当没有指定端口时。</li><li>Required: UNSET:</li><li>Optional: LOCAL:</li><li>Optional: NORMAL:</li><li>Optional: FLOOD:</li></ul><h1 id="openflow-tables"><a class="markdownIt-Anchor" href="#openflow-tables"></a> OpenFlow Tables</h1><p>OpenFlow tables 包括三种表：</p><ol><li>Flow tables:</li><li>Group tables:</li><li>Meter tables:</li></ol><h2 id="pipeline-processing"><a class="markdownIt-Anchor" href="#pipeline-processing"></a> Pipeline Processing</h2><p><img src="packet-flow.png" alt="packet-flow"></p><h2 id="flow-tables-and-flow-entries"><a class="markdownIt-Anchor" href="#flow-tables-and-flow-entries"></a> Flow Tables and flow entries</h2><p><img src="flow-table-structure.png" alt="flow-table-structure"></p><h2 id="matching"><a class="markdownIt-Anchor" href="#matching"></a> Matching</h2><p><img src="packet-flow-detail.png" alt="packet-flow-detail"></p><h2 id="table-miss"><a class="markdownIt-Anchor" href="#table-miss"></a> Table-miss</h2><h2 id="group-table"><a class="markdownIt-Anchor" href="#group-table"></a> Group Table</h2><h2 id="meter-table"><a class="markdownIt-Anchor" href="#meter-table"></a> Meter Table</h2><h1 id="openflow-channel-and-control-channel"><a class="markdownIt-Anchor" href="#openflow-channel-and-control-channel"></a> OpenFlow Channel and Control Channel</h1><h1 id="the-openflow-switch-protocol"><a class="markdownIt-Anchor" href="#the-openflow-switch-protocol"></a> The OpenFlow Switch Protocol</h1><p>The heart of the OpenFlow switch specification is the set of structures used for OpenFlow Switch Protocol messages.</p><h2 id="protocol-basic-format"><a class="markdownIt-Anchor" href="#protocol-basic-format"></a> Protocol Basic Format</h2><h3 id="header"><a class="markdownIt-Anchor" href="#header"></a> Header</h3><h3 id="padding"><a class="markdownIt-Anchor" href="#padding"></a> Padding</h3><h3 id="reserved-and-unsupported-values-and-bit-positions"><a class="markdownIt-Anchor" href="#reserved-and-unsupported-values-and-bit-positions"></a> Reserved and unsupported values and bit positions</h3><h2 id="common-structure"><a class="markdownIt-Anchor" href="#common-structure"></a> Common Structure</h2><h3 id="port-structures"><a class="markdownIt-Anchor" href="#port-structures"></a> Port Structures</h3><h2 id="controller-to-switch-messages"><a class="markdownIt-Anchor" href="#controller-to-switch-messages"></a> Controller-to-Switch Messages</h2><h3 id="handshake"><a class="markdownIt-Anchor" href="#handshake"></a> Handshake</h3><p><img src="OFPT_FEATURES_REQUEST.png" alt="OFPT_FEATURES_REQUEST"><br><img src="OFPT_FEATURES_REPLY.png" alt="OFPT_FEATURES_REPLY"></p><h3 id="switch-configuration"><a class="markdownIt-Anchor" href="#switch-configuration"></a> Switch Configuration</h3><h2 id="asynchronous-message"><a class="markdownIt-Anchor" href="#asynchronous-message"></a> Asynchronous Message</h2><h2 id="symmetric-message"><a class="markdownIt-Anchor" href="#symmetric-message"></a> Symmetric Message</h2><h3 id="hello"><a class="markdownIt-Anchor" href="#hello"></a> Hello</h3><h3 id="echo-request"><a class="markdownIt-Anchor" href="#echo-request"></a> Echo Request</h3><h1 id="glossary"><a class="markdownIt-Anchor" href="#glossary"></a> Glossary</h1><ul><li><strong>Action</strong></li><li>List of Actions:</li><li><strong>Datapath</strong>: The datapath includes the pipeline of flow tables, the group table and the ports.</li><li><strong>Flow Table</strong>: a stage of the pipeline. It contains flow entries.</li><li><strong>Flow Entry</strong>: an element in a flow table used to match and process packets.</li><li><strong>Forwarding</strong>: Deciding the output port or set of output ports for a packet, and transfering that packet to those output ports.</li><li>Group:</li><li><strong>Header</strong>: control information embedded in a packet used by a switch to identify the packet and to inform the switch on how to process and forward the packet. The header typically includes various header fields to identify the source and destination of the packet, and how to interpret other headers and the payload.</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href></a></li><li><a href="https://www.cnblogs.com/goldsunshine/p/7262484.html" target="_blank" rel="noopener">OpenFlow协议1.0及1.3版本分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
            <tag> OpenFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP 网络寻址技术</title>
      <link href="/2019/01/01/network-addressing/"/>
      <url>/2019/01/01/network-addressing/</url>
      
        <content type="html"><![CDATA[<p>在 TCP/IP 网络中，为什么有各种各样的地址？为什么有了 MAC 地址，还需要 IP 地址？既然 有了 IP 地址，为什么还需要域名？他们之间有什么关系？其实，这些问题都可以总结为 <strong>TCP/IP 网络中的寻址 (addressing) 技术</strong>。</p><a id="more"></a><h1 id="从社交看地址多样化"><a class="markdownIt-Anchor" href="#从社交看地址多样化"></a> 从社交看地址多样化</h1><p>当你向你的国内朋友描述自己的位置的时候，你告诉他：“我的地址是北京邮电大学”，他会立刻知道你在哪里，这在你的大学生圈子里很常用，你在北邮，他在华科，大学的名字就是一种本地地址，在国内的你们很容易就知道对方的地址了。</p><p>当你向一个外国友人描述你的地址时，你和他说：“我的地址是北京邮电大学”，他肯定一脸懵逼。这时候，聪明的你立刻想到了经纬度，你自信的告诉他：“我的地址是 (39.96°N, 116.35°E)” 这是国际上都懂的位置表达方式，只要精度足够精确，那么一定能够准确的描述你的位置。相信我，如果你真的这么说了，恐怕外国小哥得费劲的查一查才能知道你在哪里。</p><p>经纬度是给机器用的，它足够精确但又非常不直观。相比于告诉外国小哥你的经纬度坐标，更好的方法就是告诉他你的地址是：“10 Xitucheng Rd, Beitaipingzhuang, Haidian District, Beijing, China.” 即使他不能准确的一下说出你的确切位置，但立刻就能对你的地址有一个感性的认知——你在中国北京海淀区的某个地方。事实上，这样的树形的层级表达方式正是今天人类社会普遍采用的寻址方式。</p><p>如果将国内社交比作局域网通信，将国际社交比作互联网通信，那么这些地址就有如下对应关系</p><table><thead><tr><th>社交地址</th><th>TCP/IP 地址</th><th>特点</th></tr></thead><tbody><tr><td>大学名</td><td>MAC 地址</td><td>在国内圈子里可以使用</td></tr><tr><td>经纬度</td><td>IP 地址</td><td>国际通用寻址规则，对人类不友好，适合机器使用。</td></tr><tr><td>层级地址</td><td>域名地址</td><td>国际通用寻址规则，对人类友好。</td></tr></tbody></table><p>这就是为什么 TCP/IP 网络中有这么多地址的原因！在感性的认识了地址之后，在后文笔者将会从专业的角度来阐述 TCP/IP 网络中的寻址技术。</p><h1 id="寻址的目的"><a class="markdownIt-Anchor" href="#寻址的目的"></a> 寻址的目的</h1><p>TCP/IP 寻址技术旨在解决以下问题：</p><ul><li><strong>协调使用不同类型地址</strong>：无论二层使用了什么局域网技术，只要都通过 TCP/IP 网络接入，那么就可以互相通信。</li><li><strong>确保地址唯一性</strong>：TCP/IP 网络中的任意一个通信结点，其地址应该具有全局唯一性。</li><li><strong>配置网络接口和网络应用程序</strong>：这意味着上层应用程序可以根据基于该地址配置软件，与其他节点进行通信。</li></ul><h1 id="地址的类型"><a class="markdownIt-Anchor" href="#地址的类型"></a> 地址的类型</h1><p>为了区分不同的网络接口，TCP/IP 网络使用以下三种地址：</p><ul><li>本地地址/硬件地址 (local/hardware addresses)</li><li>网络地址/IP 地址 (netwrok/IP addresses)</li><li>符号地址/域名 (DNS names)</li></ul><h2 id="本地地址"><a class="markdownIt-Anchor" href="#本地地址"></a> 本地地址</h2><p>大多数 LAN 技术，如<strong>以太网、FDDI以及令牌环</strong>使用 <strong>MAC 地址 (MAC addresses)</strong> 定义接口，但也有一些其他的技术使用不同的寻址机制，如 X.25、ATM和帧中继。这些寻址机制在相关技术组建的网络中使用<strong>唯一地址</strong>，<strong>这种自治的网络中使用排他的寻址系统来实现内部目标的唯一标识，以保证节点的连接性。</strong></p><p>然而，当这样的网络连接到其他不同网络时，这些地址就不能通用了。在 TCP/IP 中，这些地址成为上层网间技术的元素，它们所扮演的角色应该是相同的，所以无论是 MAC 地址或者是其他什么地址，都统一称为<strong>本地 (硬件) 地址 (local/hardware addresses)</strong>。</p><div class="note info">            <p>“本地”这一术语意味着<strong>该地址在组成网络而非整个互联网中有效</strong>。需要注意的是，组成网络可以同时建立在 WAN 技术 (X.25、帧中继等) 和 LAN 技术 (以太网、令牌环等) 上，术语“本地”也被用于 LAN 中，但这里有着一定的区别，这里代表着<strong>将网络局限在小范围内的技术特征</strong>。</p><p>“硬件”这一术语意味着<strong>通常本地地址是固化在硬件中的</strong>。例如 MAC 地址，一般不可以改变。</p>          </div><h2 id="ip-网络地址"><a class="markdownIt-Anchor" href="#ip-网络地址"></a> IP 网络地址</h2><p>为了完成网络互联的任务，TCP/IP 需要有自己的<strong>全局寻址系统</strong>，并且这个寻址系统不依赖于组成网络中的节点寻址方法。该寻址系统必须提供统一的方法来唯一的标识互联网上的每个接口。</p><p>很自然的一种方法是：唯一标识所有的网络，再唯一标识网路中的节点。这样<strong>网络地址由网络号和主机号组成</strong>。这正是 IPX/SPX 网络的编址思路，这看似是很高明的设计，因为本地地址在那个子网中天然就有唯一性，然而这却使得网络地址与本地地址紧耦合，使得网络地址依赖于本地技术，限制了适用领域。这也是 IPX/SPX 没有风靡的原因，不过，IPX/SPX 本来就是被设计成在某种特定的互联网中使用的。</p><p>在 TCP/IP 网络中，节点号使用<strong>与本地技术无关，但能唯一标识子网中该节点的数字串</strong>。这通用的多，也正是 TCP/IP 网络的特征。</p><h2 id="域名-domain-names"><a class="markdownIt-Anchor" href="#域名-domain-names"></a> 域名 (Domain names)</h2><p>TCP/IP 网络的硬件和软件根据 IP 地址识别计算机，但人类还是更倾向使用<strong>可读性更好的符号来识别计算机</strong>。因此，TCP/IP 网络必须有为主机提供符合名称以及将其映射为 IP 地址的机制。</p><p><strong>互联网的接口符号标示符依据层次建立</strong>。各个部分由小数点隔开，如<code>个人主机名称.主机组 (组织) 的名称.更大的组织名称.更高的域.[...].最高域</code>。是不是很像人类在邮政系统中使用的树形层级表达方式呢？</p><p>由于 IP 地址和符号间不存在依赖关系，因此，符号映射到 IP 的唯一方法就是<strong>使用表格</strong>。TCP/IP 使用特殊的分布式服务 —— 域名系统 (DNS) 来实现。网络管理员建立一张映射表实现 IP 地址到符合地址的映射。</p><h1 id="地址的联系"><a class="markdownIt-Anchor" href="#地址的联系"></a> 地址的联系</h1><p>北京邮电大学、(39.96°N, 116.35°E)、“10 Xitucheng Rd, Beitaipingzhuang, Haidian District, Beijing, China.” 其实表示的都是一个地址，三者可以通过某种方式互相转换，只是这种转换方式很难具体的表示出来。</p><p>类似的，MAC 地址、IP 地址、域名之间也有一个对应的转换关系，这种转换关系以标准<strong>网络协议</strong>的形式呈现，在 TCP/IP 网络中，主要涉及到以下两种协议：</p><ul><li>地址解析协议 (Address Resolution Protocol, ARP)：负责 MAC 和 IP 地址的互相转换。</li><li>域名系统 (Domain Name System, DNS)：负责 IP 地址到与域名的互相转化。</li></ul><p><img src="tcpip-addresses.png" alt="tcpip-addresses"></p><div class="note info">            <p>MAC 地址是二层地址，IP 地址是三层地址，而域名是七层地址，<strong>通常转换方向是自上而下</strong>的：即根据域名得到 IP 地址，根据 IP 地址得到 MAC 地址。</p>          </div><h1 id="ip-地址"><a class="markdownIt-Anchor" href="#ip-地址"></a> IP 地址</h1><p>我们已经知道，在 TCP/IP 网络中，节点 IP 地址使用与本地技术无关但能<strong>唯一标识该节点的数字串</strong>表示。这本应该是一个十分简单的定义过程，然而由于历史原因，却成为一个复杂而又丑陋的问题，其直接结果就是如今的 TCP/IP 网络中使用了两种 IP 地址：</p><ul><li>IPv4 (Internet Protocol version 4)</li><li>IPv6 (Internet Protocol version 6)</li></ul><p>1981 年，IETF 定义了 32 位 IP 地址的 IPv4，因为 IP 地址是唯一的，所以 32 位的 IPv4 地址最多可以表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>128</mn></msup></mrow><annotation encoding="application/x-tex">2^{128}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 个地址，约为 42.9 亿。这对于当时的互联网来说真是个天文数字，然而随着互联网的快速成长，IPv4 的 42 亿个地址最终于 2011 年 2 月 3 日用尽，用尽指的是 ICANN 将所有地址段分配给各个 ISP，但由于早期编码和分配上的问题，很多区域的编码实际上被空出或不能使用。</p><p>IPv6 是 IP 的最新版本，用作互联网的网络层协议。用它来取代 IPv4 主要是为了解决 IPv4 地址枯竭问题，同时它也在其他方面对于 IPv4 有许多改进。128 位的 IPv6 的 IP 地址数量最高可达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>128</mn></msup></mrow><annotation encoding="application/x-tex">2^{128}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>，约为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3.4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>38</mn></msup></mrow><annotation encoding="application/x-tex">3.4 × 10^{38}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 个，届时每个人家居中的每件电器，每件对象，甚至地球上每一粒沙子都可以拥有自己的 IP 地址。</p><div class="note info">            <p>IPv6 的设计目的是取代 IPv4，然而长期以来 IPv4 在互联网流量中仍占据主要地位。这是因为<strong>网络地址转换</strong>及<strong>无类别域间路由</strong>等技术可延缓了网络地址匮乏的现象，我们将在后文讨论这些技术是如何影响 IP 协议发展的，在本节我们首先关心的是基本的 IP 地址。</p>          </div><h2 id="ipv4-地址"><a class="markdownIt-Anchor" href="#ipv4-地址"></a> IPv4 地址</h2><p>IPv4 地址（以下简称 IP 地址）用 32 位二进制数表示，为便于使用，常以 <code>XXX.XXX.XXX.XXX</code> 形式表现，<code>XXX</code> 为一个十进制数字，其范围为 <code>[0, 255]</code>，该表示方法称为<strong>点分十进制</strong>。</p><p><a href="http://www.ipamworldwide.com/ipam/ipv4-rfcs.html" target="_blank" rel="noopener">Key IPv4 Addressing RFCs</a></p><ul><li><a href="https://tools.ietf.org/html/rfc791" target="_blank" rel="noopener">RFC 791 - INTERNET PROTOCOL</a></li></ul><h2 id="ipv6-地址"><a class="markdownIt-Anchor" href="#ipv6-地址"></a> IPv6 地址</h2><p>详细内容查看 <a href="https://tools.ietf.org/html/rfc2373" target="_blank" rel="noopener">RFC 2373 - IP Version 6 Addressing Architecture</a></p><h1 id="网络地址转换-nat"><a class="markdownIt-Anchor" href="#网络地址转换-nat"></a> 网络地址转换 - NAT</h1><p>网络地址转换 (Network address translation, NAT) 是一种在数据包经过流量路由设备传输时，通过修改数据包 IP 报头中的网络地址信息，将 IP 地址空间<strong>重新映射</strong>到另一个地址的方法。最初使用该技术是为了避免在网络移动或更换 ISP 时为每个主机分配一个新地址。后来面对 IPv4 地址耗尽的问题时，它成为一个节省公网地址的流行工具，NAT 网关的一个公网 IP 可以用于整个专用网络。</p><h2 id="基本-nat-one-to-one-nat"><a class="markdownIt-Anchor" href="#基本-nat-one-to-one-nat"></a> 基本 NAT (One-to-one NAT)</h2><p>In this type of NAT, only the IP addresses, IP header checksum and any higher level checksums that include the IP address are changed.</p><p>最简单的 NAT 类型提供 IP 地址的<strong>一对一转换</strong>。 <a href="https://tools.ietf.org/html/rfc2663" target="_blank" rel="noopener">RFC 2663 - IP Network Address Translator (NAT)</a> 将此类型的 NAT 称为基本 NAT，也成为一对一 NAT。</p><p>在这种类型的 NAT 中，仅 IP 地址、IP 头校验和以及包括该 IP 地址的所有更高级别的校验和更改。基本 NAT 可用于互连地址不兼容的两个 IP 网络。</p><p>以下是一个基本 NAT 转换的例子，NAT 设备中维护了一个NAT 映射表 (NAT Translation Table) 用来在转换时查询。</p><table><thead><tr><th style="text-align:center">内网 IP</th><th style="text-align:center">外网 IP</th></tr></thead><tbody><tr><td style="text-align:center">192.168.1.55</td><td style="text-align:center">219.152.168.222</td></tr><tr><td style="text-align:center">192.168.1.59</td><td style="text-align:center">219.152.168.223</td></tr><tr><td style="text-align:center">192.168.1.155</td><td style="text-align:center">219.152.168.224</td></tr></tbody></table><h2 id="动态-nat"><a class="markdownIt-Anchor" href="#动态-nat"></a> 动态 NAT</h2><p>动态 NAT 和静态 NAT 一样，在较小的网络中并不常见，但在具有复杂网络的大型公司中可以找到。动态 NAT 与静态 NAT 的不同之处在于，静态 NAT 提供内网到公网静态 IP 地址的一对一映射，而动态 NAT 通常使用一组可用的公共 IP 地址。</p><h2 id="napt-one-to-many-nat"><a class="markdownIt-Anchor" href="#napt-one-to-many-nat"></a> NAPT (One-to-many NAT)</h2><p>由于公网 IP 比较宝贵，大多数 NAT 将多个私网 IP 主机映射到一个公网 IP 地址。多个私网 IP 的主机流量在发出时源地址都会转换成公网 IP，然而为了能弄清楚回来的流量到底属于原来的哪个主机，需要更改更多的地方。由于大部分网络流量使用 TCP 协议和 UDP 协议，因此通过更改端口号来消除歧义，从而确定某个返回数据包属于私网中哪台主机的回复，由于更改了 IP 和端口号，这种类型的 NAT 称为 NAPT (Network Addresss and Port Translation)，其他的名字包括 PAT、IP 伪装、 多对一 NAT 等。事实上，由于使用的广泛性 NAPT 也逐渐成为了 NAT 的代名词。</p><p><img src="napt.jpg" alt="NAPT"></p><table><thead><tr><th style="text-align:center">内网 IP &amp; Port</th><th style="text-align:center">外网 IP &amp; Port</th></tr></thead><tbody><tr><td style="text-align:center">192.168.100.3:3855</td><td style="text-align:center">145.12.131.7:6282</td></tr><tr><td style="text-align:center">192.168.100.4:80</td><td style="text-align:center">145.12.131.7:9201</td></tr><tr><td style="text-align:center">192.168.100.5:4465</td><td style="text-align:center">145.12.131.7:9202</td></tr></tbody></table><div class="note info">            <p>IP 伪装 (IP masquerading) 是一种将整个 IP 地址空间（通常由私有 IP 地址组成）隐藏在一个公共地址空间的单个 IP 地址后面的技术，隐藏的地址被更改为单个（公共）IP 地址，作为传出 IP 数据包的源地址，因此它们看起来不是源自隐藏的主机，而是源自路由设备本身。现在 IP 伪装和 NAT 基本成为同义词。</p>          </div><div class="note info">            <p>一对多 NAT 是 IPv4 地址耗尽的实用解决方案，甚至大型网络也可以使用单个公共 IP 地址连接到 Internet。同时也正是由于这个原因，如今互联网上绝大多数服务器都静静的躺在 NAT 后面，大大节省了 IPv4 地址，因此使得 IPv6 的推广受到了巨大的阻碍。</p>          </div><h2 id="snat-dnat"><a class="markdownIt-Anchor" href="#snat-dnat"></a> SNAT &amp; DNAT</h2><h3 id="snat"><a class="markdownIt-Anchor" href="#snat"></a> SNAT</h3><p><strong>源网络地址转换 (Source NAT)</strong> 用于解决内网主机<strong>主动</strong>发起连接访问公网上的服务时的问题。NAT 将内部 IP <strong>源地址</strong>转换成公有 IP，并发送给公网上的服务；当公网上的服务返回时，NAT 会将回复数据包中的目的地址从公网 IP 转换为私网 IP，再发给发起连接的内网主机。</p><p>SNAT 与我们日常生活息息相关，是 NAT 的基本功能。</p><h3 id="dnat"><a class="markdownIt-Anchor" href="#dnat"></a> DNAT</h3><p><strong>目的网络地址转换 (Destination NAT)</strong> 用于解决公网主机<strong>主动</strong>发起连接访问私网上的服务时的问题。由于私网地址是不可路由的地址，因此公网主机只能请求路由器/网关的 IP 地址，如果该路由器配置了 DNAT，则 DNAT 将公网 IP <strong>目的地址</strong> 转换为私有 IP 并发给私网上的服务器，当私网服务器回复时，NAT 会将回复数据包的目的地址从私网 IP 转换为公网 IP，再发给发起连接的公网主机。</p><p>DNAT 通常用于在公共可访问 IP 地址上发布位于专用网络中的服务，也称为<strong>端口转发</strong>。当在整个服务器上使用 DNAT 时，该服务器将暴露于 WAN，也被称为 DMZ。</p><div class="note info">            <p>主动发起的公网主机可能是真正的公网主机，也可能是经过 NAT 之后拥有公网地址的私网主机，这两者是不可区分的。因此，从某种程度上来看，DNAT 的端口转发解决了<strong>公对私</strong>和<strong>私对私</strong>两种问题，下文中我们通过 NAT 穿透技术将会了解到更多解决私对私问题的方案。</p>          </div><h2 id="nat-穿透-nat-traversal"><a class="markdownIt-Anchor" href="#nat-穿透-nat-traversal"></a> NAT 穿透 (NAT Traversal)</h2><p>当位于不同 NAT 之后的两个对等方尝试进行通信时，会出现 NAT 穿透问题，解决此问题的一种方法是使用<strong>端口转发</strong>，另一种方法是使用各种 <strong>NAT 打孔技术 (NAT hole punching)</strong>。关于穿透技术请查看 <a href="https://en.wikipedia.org/wiki/NAT_traversal#Network_address_translation" target="_blank" rel="noopener">NAT Traversal</a>。</p><h2 id="nat-in-ipv6"><a class="markdownIt-Anchor" href="#nat-in-ipv6"></a> NAT in IPv6</h2><p>网络地址转换在 IPv6 中并不常用，因为 IPv6 的设计目标之一是恢复端到端网络连接，尽管仍然可行，但 IPv6 的大型寻址空间消除了私有地址的需要，并且可以为每个设备分配一个唯一的全局可路由地址，也就是说，结合使用唯一的本地地址和网络前缀转换可以达到类似 NAT 的结果。</p><h1 id="地址解析协议-arp"><a class="markdownIt-Anchor" href="#地址解析协议-arp"></a> 地址解析协议 - ARP</h1><p>地址解析协议 (Address Resolution Protocol, ARP) 是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在 IPv4 中极其重要，其 RFC 文档为 <a href="https://tools.ietf.org/html/rfc826" target="_blank" rel="noopener">RFC 826 -  An Ethernet Address Resolution Protocol</a>。ARP 是通过网络地址来定位 MAC 地址，在很多网路层和数据链接层之间得以实现，但最常用的还是将 IPv4 地址转换为 MAC 地址。</p><div class="note info">            <p>在 IPv6 中邻居发现协议（NDP）用于代替地址解析协议（ARP）。</p>          </div><h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2><p>在以太网协议中规定，<strong>同一局域网</strong>中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的 MAC 地址。而在 TCP/IP 协议中，网络层和传输层只关心目标主机的 IP 地址。这就导致在以太网中使用 IP 协议时，数据链路层的以太网协议接收到上层 IP 协议提供的数据中，只包含目的主机的 IP 地址。于是需要一种方法，根据目的主机的 IP 地址，获得其 MAC 地址。这就是 ARP 协议要做的事情。所谓<strong>地址解析就是主机在发送帧前将目标 IP 地址转换成目标 MAC 地址的过程</strong>。</p><p>当发送主机和目的主机<strong>不在同一个局域网</strong>中时，即便知道对方的 MAC 地址，两者也不能直接通信，必须经过<strong>路由转发</strong>才可以。所以此时，发送主机通过 ARP 协议获得的将不是目的主机的真实 MAC 地址，而是一台可以通往局域网外的路由器的 MAC 地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为<strong>委托 ARP</strong> 或 <strong>ARP 代理 (ARP Proxy)</strong>。</p><h2 id="数据包结构"><a class="markdownIt-Anchor" href="#数据包结构"></a> 数据包结构</h2><p>地址解析协议的消息格式很简单，仅包含单一的<strong>地址解析请求或响应</strong>。ARP 消息的长度取决于上下两层地址的大小：</p><ul><li>上层地址由所使用的网络协议类型决定（通常是 IPv4 地址）。</li><li>下层地址则由上层协议所使用的硬件或虚拟链路层的类型决定（通常是 MAC 地址）。</li></ul><p>消息的报头中包含了这两层地址的<strong>类型</strong>以及<strong>长度</strong>信息，此外还包含了表示请求（1）和应答（2）的<strong>操作码</strong>。数据包的<strong>有效载荷 (Payload)</strong> 为收发双方的硬件地址、协议地址，总计四个地址。数据包结构如下：</p><p><img src="arppacket.jpg" alt="arppacket"></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="arp-request.png" alt="arp-request"></div><div class="group-picture-column" style="width: 50%;"><img src="arp-reply.png" alt="arp-reply"></div></div></div></div><h2 id="传统-arp-流程"><a class="markdownIt-Anchor" href="#传统-arp-流程"></a> 传统 ARP 流程</h2><p>ARP 的核心解析流程非常简单，只有两个步骤：</p><ol><li>发送方发送 ARP Request 数据包获取接收方的 MAC 地址。请求数据包类型是<strong>广播</strong>，因此局域网中所有主机都可以收到该请求，但只有真正的接收方才会作出回应。</li><li>接收方回复 ARP Reply 数据包响应发送发。响应数据包类型是<strong>单播</strong>，将会单独回复给发送发。</li></ol><p><img src="traditional-arp-process.gif" alt="traditional-arp-process"></p><p>以下是使用 Wireshark 抓取的同一局域网中一台手机和一台电脑进行 ARP 的过程：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">XiaomiCo_91</span><span class="selector-pseudo">:5e</span><span class="selector-pseudo">:bc</span>       <span class="selector-tag">Broadcast</span>           <span class="selector-tag">Who</span> <span class="selector-tag">has</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.101</span>? <span class="selector-tag">Tell</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.103</span></span><br><span class="line"><span class="selector-tag">IntelCor_ac</span><span class="selector-pseudo">:a7</span><span class="selector-pseudo">:ab</span>       <span class="selector-tag">XiaomiCo_91</span><span class="selector-pseudo">:5e</span><span class="selector-pseudo">:bc</span>   192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.101</span> <span class="selector-tag">is</span> <span class="selector-tag">at</span> 0<span class="selector-tag">c</span><span class="selector-pseudo">:7a</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:ac</span><span class="selector-pseudo">:a7</span><span class="selector-pseudo">:ab</span></span><br></pre></td></tr></table></figure><h2 id="arp-缓存"><a class="markdownIt-Anchor" href="#arp-缓存"></a> ARP 缓存</h2><p>每次通信发送方都需要根据接收方 IP 地址将其 MAC 地址填写到发送数据帧中，那么每一次都需要地址解析吗？答案是否定的，在每台安装有 TCP/IP 协议的电脑或路由器里都有一个 <strong>ARP 缓存表</strong>，表里的 IP 地址与 MAC 地址是一对应的，可以通过 <code>arp -a</code> 命令来查看。</p><p>使用 ARP 缓存的好处至少有两个：</p><ul><li>对于本机来说，加快解析 MAC 地址速度。</li><li>对于本网络来说，减少 ARP 广播量，节省网络资源。</li></ul><p>因此，当主机 A 向主机 B 发送数据发送数据时，主机 A 会在自己的 ARP 缓存表中寻找是否有目标 IP 地址，如果找到就直接把目标 MAC 地址写入帧里面发送；如果未找到，就会发起一次对 B 主机的 ARP Request，当收到 B 主机的 ARP Reply 时，便把 IP-MAC 映射写入 ARP 缓存中，以便下次使用。</p><p>ARP 缓存可以包含<strong>动态条目</strong>和<strong>静态条目</strong>。</p><ul><li>动态条目随时间推移自动添加和删除，在一段时间内如果表中的某一行动态条目没有使用，就会被删除，这样可减少缓存表的长度，加快查询速度。</li><li>静态项目一直保留在缓存中，直到重新启动计算机为止。</li></ul><div class="note warning">            <p>接收到新的 ARP 应答数据包后，即使尚未过期的 ARP 缓存条目也将被覆盖，ARP 协议中没有任何方法可以使主机对另一方进行身份验证，因此也给 ARP 攻击提供了可乘之机。</p>          </div><h2 id="免费-arp"><a class="markdownIt-Anchor" href="#免费-arp"></a> 免费 ARP</h2><p>免费 ARP (Gratuitous ARP) 是一种<strong>不需要由 ARP 请求触发的 ARP 响应</strong>，免费 ARP 作为<strong>广播</strong>发送，作为节点宣布或更新其 IP-MAC 映射到整个网络的方式。</p><p>操作码设置为 2，表示响应，尽管该数据包的产生实际上并非是由一个请求引起的，这就是也是免费 ARP 名字的由来。发送 MAC 和发送 IP 包含启动程序正在通告的 ARP 映射，这两个是 ARP 数据包的重要部分。</p><p>目标 MAC 地址为 ffff.ffff.ffff，但实际上，该字段的内容无关紧要，在免费 ARP 中将其忽略，ARP的某些实现将在该字段中使用 0000.0000.0000。</p><p>免费 ARP 通常有三种作用：</p><ul><li>更新 ARP 映射</li><li>宣布节点存在</li><li>用于冗余备份</li></ul><h3 id="更新-arp-映射"><a class="markdownIt-Anchor" href="#更新-arp-映射"></a> 更新 ARP 映射</h3><p>第一个作用非常简单，如果节点的IP到MAC映射发生更改，则节点可以使用免费ARP更新网络上其他主机的ARP映射。<br>如果用户手动修改其MAC地址-他们保留了相同的IP地址，但是现在有了新的MAC地址，则可能会发生这种情况。<br>因此，必须更新与此用户通信的所有节点的ARP映射。<br>话虽如此，手动更改MAC地址的情况很少见。<br>但是，有时您会在冗余的云或虚拟环境中看到这种情况，在该环境中，特定的虚拟机（VM）会“跳转”到新的物理盒中-相同的VM的IP地址现在由另一台物理机提供。</p><h3 id="宣布节点存在"><a class="markdownIt-Anchor" href="#宣布节点存在"></a> 宣布节点存在</h3><p>免费 ARP 的第二个作用是主机刚加入网络时，它可以使用免费 ARP 向网络宣告它的存在。激发此操作的意图很有用，<strong>这是一种在不要求主机进行传统 ARP 过程的情况下，抢先填充相邻主机的 ARP 缓存的尝试</strong>。</p><p>但是，主机无权缓存每个收到的免费 ARP 中的 ARP 映射，结果使得这种作用几乎变得无用，但是它不会造成重大危害。因此不建议这种行为。</p><div class="note warning">            <p>该用例经常与尝试检测可能的重复 IP 地址混淆，但是此过程未使用免费ARP，为了检测 IP 地址冲突，主机将使用 ARP 探针和 ARP 公告，后文会描述这个过程。</p>          </div><h3 id="冗余-redundancy"><a class="markdownIt-Anchor" href="#冗余-redundancy"></a> 冗余 (Redundancy)</h3><p>在使用两个设备之间的冗余或故障转移的情况下，免费 ARP 的用例更为重要。</p><p>使用冗余，通常会遇到两种情况：</p><ul><li>两个设备共享一个 IP 地址，但是每个设备都有自己的 MAC 地址。</li><li>两个设备同时共享一个 IP 地址和一个 MAC 地址。</li></ul><p>在这两种情况下，免费 ARP 对于确保 IP 地址在两个冗余设备之间切换时的持续通信能力至关重要。</p><p><img src="gratuitous-arp-shared-ip.gif" alt="gratuitous-arp-shared-ip"></p><h2 id="arp-探针和-arp-公告"><a class="markdownIt-Anchor" href="#arp-探针和-arp-公告"></a> ARP 探针和 ARP 公告</h2><p>这两种方法都在<strong>重复地址检测 (Duplicate Address Detection)</strong> 的过程中使用。这个想法是：如果一台主机获得并使用了恰好在网络上正在使用的 IP 地址，将会导致这两台主机的网络连通性出现问题，因此对于主机来说，首先测试 IP 地址的唯一性是有益的。</p><p>确定是否正在使用 IP 地址的一种方法是使用 <strong>ARP 探针 (ARP Probe)</strong>，该过程非常简单，发送了一些 ARP 探针（通常为 3 个），如果没有人响应，就通过 <strong>ARP 公告 (ARP Announcement)</strong> 正式声明该 IP 地址。</p><p><img src="arp-probe-announcement.png" alt="arp-probe-announcement"></p><h3 id="arp-探针包结构"><a class="markdownIt-Anchor" href="#arp-探针包结构"></a> ARP 探针包结构</h3><p>ARP 探针用于轮询网络以<strong>确认 IP 地址尚未使用</strong>。发送时将 Opcode 字段设置为 1，表示 ARP 请求。这个想法是，如果所请求的 IP 地址已经被使用，则 ARP 探针的发起者将期望原始所有者的响应。因此，ARP 探针是一个可能引起响应的请求。</p><p><img src="arp-probe.png" alt="arp-probe"></p><ul><li>发送 MAC 地址设置为发起方的 MAC 地址</li><li>发送 IP 地址设置为 0.0.0.0。</li><li>目标 MAC 地址设置为 0000.0000.0000</li><li>目标 IP 地址设置为要探测的 IP 地址</li></ul><div class="note info">            <p><strong>探针数据包中没有提供完整的映射</strong><br>发送 IP 设置为全零，这意味着它无法映射到发送 MAC 地址。目标 MAC 地址全为零，这意味着它无法映射到目标 IP 地址。这是有意的，因为发送 ARP 探针的原因是为了防止 IP 冲突，如果目标 IP 地址已被使用，则网络上的其他主机基于ARP 探针的内容无意中更新其 ARP 缓存将是非常不可取的。</p><p>这也是 ARP 探针和免费 ARP 之间的主要区别。免费 ARP 旨在更新网络上的所有 ARP 缓存，而 ARP 探针则故意阻止更新ARP 缓存以继续保护 IP 地址免遭冲突。</p>          </div><h3 id="arp-公告包结构"><a class="markdownIt-Anchor" href="#arp-公告包结构"></a> ARP 公告包结构</h3><p>如果 ARP 探针包引起来自该 IP 的 ARP 响应，则发起主机将认为该 IP 地址是唯一的，并将发送 ARP 公告以<strong>正式在该网络中声明其 IP 地址</strong>。</p><p><img src="arp-announcement.png" alt="arp-announcement"></p><p>ARP 公告包结构与上述 ARP 探针包结构相同，<strong>不同之处在于公告包存在完整的映射</strong>。发送 MAC 地址和发送 IP 地址创建了完整的 ARP 映射，网络上的主机可以在其 ARP 表中使用这对映射。像免费 ARP 一样，目标 MAC 地址也被忽略，在此示例中为 0000.0000.0000，在某些实现中使用 ffff.ffff.ffff 代替。</p><p>ARP 公告与免费 ARP 非常相似，但有一个明显的例外就是两者<strong>操作码不同</strong>：ARP 公告中的操作码设置为 1，表示请求，而典型的免费 ARP 会将操作码设置为 2。</p><div class="note info">            <p>ARP 公告与免费 ARP 非常相似，唯一的区别是操作码字段，尽管从技术上讲它们是不同的构造，但它们通常都被简单地称为免费 ARP。对于日常网络话题交流来说，这是一个琐碎的错误用语，但是有时有些不准确之处确实可以省去冗长的解释。</p>          </div><h2 id="反向地址解析协议"><a class="markdownIt-Anchor" href="#反向地址解析协议"></a> 反向地址解析协议</h2><p>与 ARP 根据网络层（三层）地址获取 MAC 地址（二层）不同，反向地址解析协议 Inverse ARP (InARP) 执行相反的流程，其用于从数据链路层（第2层）地址获取其他节点的网络层地址（例如IP地址）。</p><p>还有一种反向地址解析协议 Reverse ARP (RARP) 与 InARP 类似，其区别在于：在 InARP 中，请求主机查询<strong>另一个主机</strong>的第三层地址，而 RARP 用于获取<strong>主机本身</strong>的第三层地址，以进行地址配置。</p><p>两种协议都很少被用到，其中 RARP 相关功能如今已被 DHCP 取代。</p><h2 id="arp-代理"><a class="markdownIt-Anchor" href="#arp-代理"></a> ARP 代理</h2><p>当发送主机 A 和目的主机B <strong>不在同一个局域网</strong>中时，A 和 B 经过<strong>网关</strong>（一般是 IP 路由器）中转进行通信。所以此时发送主机通过 ARP 协议获得的将不是目的主机的真实 MAC 地址，而是一台可以通往局域网外的路由器的 MAC 地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送，这种情况称为<strong>委托 ARP</strong> 或 <strong>ARP 代理 (ARP Proxy)</strong>。</p><h3 id="经典例子"><a class="markdownIt-Anchor" href="#经典例子"></a> 经典例子</h3><p>假设有一个如下的网络拓扑<br><img src="arp-media-proxy-arp-topology.png" alt="arp-media-proxy-arp-topology"></p><p>当 B 请求 D MAC 地址时，B 的 ARP 请求是完全正常的，但是 B 收到的 ARP 响应却与传统 ARP 响应包不同，其区别为代理 ARP 响应包的<strong>发送 MAC 地址是路由器的 MAC，发送 IP 地址是 D 的 IP 地址</strong>。路由器代理了对于 D 的请求。</p><p><img src="proxy-arp-process.gif" alt="proxy-arp-process"></p><div class="note info">            <p>ARP 代理只响应那些在自己的路由表里能找到的网段，而不是用自己的 MAC 地址响应主机所有的 ARP 请求。</p>          </div><p>我们大部分的流量不都是通过网关发出去的吗？难道只要是跨局域网通信都会用到代理 ARP 吗？事实上不是这样的，如果用 Wireshark 抓包，你会发现当你 Ping 外网地址的时候，并不会抓到路由器的代理 ARP 响应包，这是因为当<strong>主机配置默认路由</strong>时，该 ARP 请求直接请求的就是网关的 MAC 地址，并不涉及代理 ARP，在配置了网关的设备上是不会出现代理 ARP 问题的。</p><p>那什么情况下会用到 ARP 代理？注意我们的例子中主机 B 上的子网位数的配置，似乎只有在这种“怪异”的场合才会用到代理 ARP，B 和 D 通信，B 以为 D 在自己的子网内，便直接发 ARP 请求，路由器接到这个 ARP 请求，然后发现请求的 IP 地址在自己直连的网段中（在路由表中能找到），这样，就用 0053.ffff.9999 接口响应了这个 ARP 请求，完成了代理 ARP。</p><h3 id="nat-中的-arp-代理"><a class="markdownIt-Anchor" href="#nat-中的-arp-代理"></a> NAT 中的 ARP 代理</h3><p>前面我们讨论了代理 ARP 在未正确配置网关主机中的用例，如果主机正确配置了网关，那么几乎不会产生代理 ARP。但是，<strong>代理 ARP 有一个非常合法且必要的用例，它与网络地址转换 (NAT)有关</strong>。</p><p><img src="arp-media-proxy-arp-nat-topology.png" alt="arp-media-proxy-arp-nat-topology"></p><p>我们的防火墙在 72.3.4.0/24 网络中的 IP 地址为 72.3.4.2，同时还配置了静态 NAT，可将 IP 地址 72.3.4.55 转换为 10.3.4.55，这个 IP 地址属于主机 Y，Y 的内网 IP 地址为 10.3.4.55，主机 X 是使用 IP 66.7.8.9 在互联网另一端的某个主机。</p><p>如果主机 X 向主机 Y 发送了一个数据包（源 IP 66.7.8.9，目的 IP 72.3.4.55），该数据包通过 Internet 路由到达路由器 C。路由器 C 向 72.3.4.0/24 网络发起 ARP 请求以确定拥有 IP 地址 72.3.4.55 的 MAC 地址。</p><p>但是，防火墙已配置为将数据包从 72.3.4.55 转换为 10.3.4.55 的 NAT，它知道它必须接收发往 72.3.4.55 的数据包，以便将数据包传递到主机 Y。因此，<strong>防火墙将使用代理 ARP</strong> 代表主机 Y 响应路由器 C 对 IP 地址 72.3.4.55 的 ARP 请求。</p><p><img src="proxy-arp-nat.gif" alt="proxy-arp-nat"></p><div class="note info">            <p>在 10.3.4.0/24 网段上，从 NAT 接口 10.3.4.1 到 主机 Y 10.3.4.55 还会发生一次正常的 ARP 过程。</p>          </div><h2 id="arp-欺骗攻击"><a class="markdownIt-Anchor" href="#arp-欺骗攻击"></a> ARP 欺骗/攻击</h2><p>ARP 是一个简单的一问一答式协议，并且是无状态协议，网络主机将自动缓存它们收到的任何 ARP 答复，无论网络主机是否请求它们，接收到新的 ARP 应答数据包后，即使尚未过期的 ARP 条目也将被覆盖。同时由于缺乏任何安全验证措施，也使得坏人可以通过 ARP 欺骗/毒化/攻击  (ARP spoofing/poisoning/attack) 控制你的网络流量。</p><p>如果说 ARP 代理是网关欺骗了 ARP 请求的发送方，冒充了通信的接收方；那么 ARP 欺骗就是坏人欺骗了接收方，冒充了 ARP 请求的发送方，当接收方给发送方发数据时，可以将数据包转给发送方达到偷听效果，或是篡改数据包达到伤害效果，或是什么也不做，达到发送发断网效果。</p><p><img src="arp-spoofing.svg" alt="arp-spoofing"></p><p>攻击者聆听局域网上的 MAC 地址。它只要收到两台主机洪泛的 ARP Request，就可以进行欺骗活动。</p><ul><li>User、Gateway 都洪泛了ARP Request，攻击者现在有了两台主机的 IP、MAC 地址，开始攻击。</li><li>攻击者发送一个ARP Reply 给 Gateway，把此包的 Sender IP 设为 User IP ，Sender MAC 设为攻击者自己的 MAC 地址。</li><li>Gateway 收到 ARP Reply 后，更新它的 ARP 缓存，把缓存条目 (IP_User, MAC_User) 改为 (IP_User, MAC_Malicious)</li><li>当 Gateway 要发送数据包给 User 时，它根据 ARP 缓存来封装数据帧报头，把目的 MAC 地址设为 MAC_Malicious，而非 MAC_User。</li><li>当交换机收到 Gateway 发送给 User 的数据包时，根据此包的目的 MAC 地址 (MAC_Malicious) 而把数据包转发给攻击者。</li><li>攻击者收到数据包后，可以把它存起来后再发送给 User，达到偷听效果。攻击者也可以篡改数据后才发送数据包给 User，造成伤害。</li></ul><h1 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h1><h2 id="层次符号名称"><a class="markdownIt-Anchor" href="#层次符号名称"></a> 层次符号名称</h2><p>最初为 LAN 开发的操作系统 (NetBIOS, Microsoft Windows, IBM OS/2) 采用了<strong>平面符号名称</strong>，因为 LAN 中的计算机通常较少。为了建立符号名称到 MAC 地址的映射，采用了广播请求机制，与 ARP 类似。但对于采用 TCP/IP 栈的大型、地理分布广泛的网络，这样的方法是不行的。</p><p>TCP/IP 栈采用的是 DNS (Domain Name System) 域名系统，它是一种组织成<strong>域层次结构</strong>的计算机和网络服务命名系统。域名的层次与文件系统的文件名层次相类似，名称始于树根，用 <code>.</code> 表示</p><h2 id="基本功能-2"><a class="markdownIt-Anchor" href="#基本功能-2"></a> 基本功能</h2><p>DNS 作为一个分布式数据库，提供<strong>将主机名和域名转换为 IP 地址</strong>的服务，能够使人更方便的访问互联网。DNS 是一个应用层协议，使用 <strong>TCP/UDP 端口 53</strong>。</p><h2 id="dns-解析"><a class="markdownIt-Anchor" href="#dns-解析"></a> DNS 解析</h2><p><img src="dns-resolve.png" alt="dns-resolve"></p><h2 id="dns-缓存"><a class="markdownIt-Anchor" href="#dns-缓存"></a> DNS 缓存</h2><p>为了加速查询 IP 地址的过程， DNS 服务器为经过他们的所有响应广泛采用缓存机制，为了使 DNS 服务器及时地处理网络中发生的变化，响应只在短时间内被缓存，通常为几小时到几天。</p><p><img src="dns-cache.svg" alt="dns-cache"></p><h2 id="dns-over-tls"><a class="markdownIt-Anchor" href="#dns-over-tls"></a> DNS over TLS</h2><p><img src="dns-poisoning.png" alt="dns-poisoning"></p><p><a href="https://tools.ietf.org/html/rfc7858" target="_blank" rel="noopener">RFC 7858 - DNS over TLS</a> 可以解决这个问题。</p><h1 id="dhcp"><a class="markdownIt-Anchor" href="#dhcp"></a> DHCP</h1><p>动态主机设置协议 (Dynamic Host Configuration Protocol, DHCP) 是一个用于 IP 网络的网络协议，位于 OSI 模型的应用层，使用 <strong>UDP</strong> 协议工作，主要有两个用途：</p><ul><li>用于内部网或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网管理员对所有电脑作中央管理</li></ul><p>动态主机设置协议 DHCP 是一种使网络管理员能够集中管理和自动分配 IP 网络地址的通信协议。在 IP 网络中，每个连接 Internet 的设备都需要分配唯一的 IP 地址。DHCP 使网络管理员能从中心结点监控和分配 IP 地址。当某台计算机移到网络中的其它位置时，能自动收到新的 IP 地址。</p><p>DHCP 使用了租约的概念，或称为计算机 IP 地址的有效期。租用时间是不定的，主要取决于用户在某地连接 Internet 需要多久，这对于教育行业和其它用户频繁改变的环境是很实用的。透过较短的租期，DHCP 能够在一个计算机比可用 IP 地址多的环境中动态地重新配置网络。DHCP 支持为计算机分配静态地址，如需要永久性 IP 地址的 Web 服务器。</p><p><img src="dhcp-diag.jpg" alt="dhcp-diag.jpg"></p><p>详细解释参阅 <a href="https://docs.oracle.com/cd/E37838_01/html/E61005/dhcp-overview-3.html" target="_blank" rel="noopener">How DHCP Works</a></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol#ARP_spoofing_and_Proxy_ARP" target="_blank" rel="noopener">Address Resolution Protocol</a></li><li><a href="https://en.wikipedia.org/wiki/Network_address_translation#DNAT" target="_blank" rel="noopener">Network address translation</a></li><li><a href="https://en.wikipedia.org/wiki/NAT_traversal#Network_address_translation" target="_blank" rel="noopener">NAT Traversal</a></li><li><a href="https://en.wikipedia.org/wiki/ARP_spoofing" target="_blank" rel="noopener">ARP spoofing</a></li><li><a href="https://www.practicalnetworking.net/series/arp/traditional-arp/" target="_blank" rel="noopener">Traditional ARP</a></li><li><a href="https://www.practicalnetworking.net/series/arp/proxy-arp/" target="_blank" rel="noopener">Proxy ARP</a></li><li><a href="https://www.practicalnetworking.net/series/arp/gratuitous-arp/" target="_blank" rel="noopener">Gratuitous ARP</a></li><li><a href="https://www.practicalnetworking.net/series/arp/arp-probe-arp-announcement/" target="_blank" rel="noopener">ARP Probe and ARP Announcement</a></li><li><a href="https://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html" target="_blank" rel="noopener">ARP Use case</a></li><li><a href="https://aws.amazon.com/cn/route53/what-is-dns/" target="_blank" rel="noopener">DNS 解析流程</a></li><li><a href="https://www.incibe-cert.es/en/blog/protect-your-dns-requests-dns-over-tls" target="_blank" rel="noopener">Protect your DNS requests with DNS over TLS</a></li><li><a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener">Dynamic Host Configuration Protocol</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAC </tag>
            
            <tag> IP </tag>
            
            <tag> DNS </tag>
            
            <tag> ARP </tag>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络体系架构和标准</title>
      <link href="/2018/12/19/network-architecture-and-standardization/"/>
      <url>/2018/12/19/network-architecture-and-standardization/</url>
      
        <content type="html"><![CDATA[<p>网络体系结构将一个公共问题分解为一系列子问题，每一个问题通过一个网络部件来解决。OSI 模型的开发是计算机网络体系结构标准化过程的重大突破，<strong>提供了一种纵向分解计算机交互问题的方案</strong>，这一方案把任务交给通信协议来完成，通信协议的层次构成了一种层级结构，称之为<strong>协议栈 (protocol stack)</strong>，不同的协议栈都有其自己的特点，但都普遍反映了 OSI 模型的体系结构。</p><a id="more"></a><h2 id="分层-layering"><a class="markdownIt-Anchor" href="#分层-layering"></a> 分层 (Layering)</h2><p>任何复杂的工作都需要分解来完成，在计算机网络中，将一个复杂的问题划分成几个模块 (module)，每个模块可以看做是一个黑盒，这些模块根据层而组织，构成了层级结构。在进行交互时，每一层的模块有两类接口：</p><ol><li>本地层级的上层和下层有<strong>服务接口(service interface)</strong> 或<strong>层间接口 (interlayer interface)</strong>，其定义了下面一层对相邻上一层提供的服务。</li><li>对另一方交互工具的<strong>对等接口 (peer-to-peer interface)</strong>，这种类型的接口也称之为<strong>协议 (protocol)</strong>。</li></ol><p>下图描述了两个节点间通信的<strong>接口 (interface) 和协议 (protocol)</strong>：</p><p><img src="protocol-interface.png" alt="protocol-interface"></p><div class="note info">            <p>大体上来说，协议和接口表示同一样东西，即：<strong>两个物体间交互过程的标准化描述</strong>。但传统意义而言：协议定义了不同节点上运行的同一层模块的交互规则，而接口定义了在同一节点上相邻层模块间的交互规则。</p>          </div><p>一个能够实现网络节点交互的、层级化组织的协议集被称为<strong>协议栈 (protocol stack)</strong>，或称协议集 (protocol set)、协议族/簇 (protocol suite)。</p><p><strong>低层次 (media layers) 的协议通常由硬件和软件共同实现，更高层 (host layers) 的协议通常只由软件实现</strong>。这也就是为什么在学习计算机网络的过程中，网络层之上的层次感觉你会感觉十分清晰，而到了网络层及网络层以下，知识体系就变得有些杂乱。因为在 Internet 中，软件标准是开放的，而网络层及其以下层次涉及到具体硬件，出于历史发展和商业等因素，各个设备商之间的硬件架构，软件协议各有不同，因此显得杂乱一些。</p><h2 id="osi-模型-osi-model"><a class="markdownIt-Anchor" href="#osi-模型-osi-model"></a> OSI 模型 (OSI Model)</h2><p>在 20 世纪 80 年代，包括<strong>国际标准化组织 (International Organization for Standardization, ISO) 和 国际电信联盟电信部 (ITU Telecommunication Standardization Sector, ITU-T)</strong> 在内的几个国际标准化组织开发了<strong>开放系统互连 (Open Systems Interconnection, OSI) 模型</strong>，这一模型后来在计算机网络的发展中发挥了重要作用。</p><h3 id="osi-模型的特性"><a class="markdownIt-Anchor" href="#osi-模型的特性"></a> OSI 模型的特性</h3><p>那时候有大量的专用通信协议栈，<strong>OSI 模型不包含任何特定协议栈的描述</strong>，它的目的是描述一个通用的网络互联架构，因此，它常常被称为<strong>参考模型 (reference model)</strong>。OSI 模型定义了：</p><ul><li><strong>分组交换网络</strong>中系统各个层之间的通信</li><li>层的标准名称</li><li>每一层必须完成的功能</li></ul><p>OSI 模型将通信工具划分为七个层次，每一层处理严格定义了网络互连的一个方面。如下图所示：</p><p><img src="OSI-model.png" alt="ISO/OSI-model"></p><p>应用程序可以使用这套七层的系统工具，实现自己的交互协议。为了这一目的，<strong>应用程序编程接口 (Application Programming Interface, API)</strong> 被提供给程序员，通过使用 API，应用程序可以将它的请求发送给最高的层——应用层。<strong>但是，事实上，大多数通信协议栈提供给程序员直接调用底层服务，如 TCP/IP 中，我们可以直接通过 socket 编程操作运输层</strong>。</p><p>假设计算机 1 上的应用程序 A 要和计算机 2 上的应用程序 B 通信：</p><ol><li>应用程序 A 请求一个应用层服务，应用层软件以标准格式生成一个报文 (message)，并添加<strong>报文头部 (header)</strong>。</li><li>报文逐层向下传递，在每一层中，依据上一层的头部信息，完成自己层需要的动作，并添加自己的头部信息到报文中。</li><li>最后到达物理层，物理层将真正的比特流通过物理线路传送到目标机器。这时，报文携带所有层的头部。</li><li>在目标机器上，报文顺序逐层向上传递，完成每一层的指示，并删除头部，最后报文信息到达应用程序 B。</li></ol><div class="note info">            <p>在某些层的协议中，除了在报文的开始添加头部 (header) 之外，还会在报文的末端添加尾部 (trailer)。</p>          </div><p>不同层协议的数据交换单元有一个通用的名称——<strong>协议数据单元 (Protocol Data Unit, PDU)</strong>。专门的术语用来指示不同层的数据交换单元：<strong>帧 (frame)、分组 (packet)、数据报 (datagram) 以及数据段 (segment)</strong>。</p><p><img src="OSI-model-PDU.png" alt="ISO/OSI-model-PDU"></p><h3 id="物理层-physical-layer"><a class="markdownIt-Anchor" href="#物理层-physical-layer"></a> 物理层 (Physical Layer)</h3><p>物理层使用诸如同轴电缆、双绞线、光纤这样的物理链路，处理字节流的传输。物理层不关心它传输信息的意义，从它的角度看，这些信息是需要根据指定的时钟频率 (预定义的相邻比特间的间隔)，无损传输到目的地的比特流。</p><p>物理层的功能在<strong>所有连接到网络的设备中实现</strong>，就计算机而言，物理层的功能或是通过<strong>网络适配器</strong>完成，或是通过<strong>串口</strong>完成。</p><p>以太网的 10Base-T 标准是一个物理层协议的例子。这一标准定义了电缆为带有100欧姆阻抗的非屏蔽三类双绞线，<strong>RJ45</strong> 接口，最大段长度 100 米，线上数据表示为<strong>曼彻斯特编码</strong>，以及其他传输媒体和电信号的特点。</p><h3 id="数据链路层-data-link-layer"><a class="markdownIt-Anchor" href="#数据链路层-data-link-layer"></a> 数据链路层 (Data Link Layer)</h3><p>数据链路层的 PDU 通常称为<strong>帧 (frame)</strong>，对于局域网和广域网，数据链路层的功能相差很多，局域网和广域网的技术相差很多，因此数据链路层必须提供以下功能：</p><ul><li>在局域网中，保证<strong>任何两个网络节点</strong>间帧的传送。</li><li>在广域网中，保证<strong>两个通过单一链路连接的节点</strong>间帧的传送。</li></ul><div class="note info">            <p>对于互联局域网，或者广域网中任意两个节点间帧的传送，需要使用更高层的网络工具，我们将在下一节讨论。</p>          </div><p>数据链路层需要<strong>提供接口</strong>给下面物理层和上一次网络层。对于网络层来的分组，将其<strong>封装成帧</strong>。对于物理层来的比特，利用<strong>帧同步/帧定界</strong>技术来从二进制比特流中提取帧。</p><p><strong>差错检验</strong>是数据链路层的另一项任务，这是为了防止网卡软硬件 Bug、电缆不可靠、信号干扰而造成信号失真或数据错误，目前广泛通过添加<strong>帧校验序列 (FCS) 以及循环冗余校验算法 (CRC)</strong> 来实现。</p><p>如果使用共享介质网络，在将帧传送的物理层传输之前，数据链路层必须保证<strong>介质的可用性</strong>，这个功能往往被分为一个独立的子层——<strong>介质访问控制子层 (Medium Access Control, MAC)</strong>。</p><p>数据链路层的协议由计算机，网桥，交换机，路由器实现。在计算机中，数据链路层的功能由网络适配器和其驱动程序共同实现。</p><div class="note info">            <p>数据链路层地址通常在一个网络内传输帧，更高层的地址用来在网络间转发分组。也就是说，在局域网传输中，某些情况下，你可以直接将应用层架构在链路层上，没必要使用网络层和传输层的工具。然而，为了保证对于任何拓扑，网络中报文的高质量传输，仅仅使用数据链路层是不够的，对于 OSI 模型中，这些任务由网络层和传输层完成。</p>          </div><h3 id="网络层-network-layer"><a class="markdownIt-Anchor" href="#网络层-network-layer"></a> 网络层 (Network Layer)</h3><p>网络层将多个网络连接起来，创建了统一的运输系统，因此被称为<strong>互联网络 (internetwork)</strong>，或者简称为<strong>互联网 (internet)</strong>。</p><div class="note info">            <p>请不要将<strong>互联网 (internet)</strong> 与<strong>因特网 (Internet)</strong> 混淆，后者是建立在 TCP/IP 技术基础上，最著名的互联网的实现，这一网络覆盖全世界。</p>          </div><p>下图中有许多网络，每一个都使用了特定的数据链路层技术，例如以太网，令牌环，帧中继，ATM 等，基于这些技术，每个网络都可以在本地网络中将两个用户连接起来，<strong>但不可以传输数据到其他网络中</strong>。原因是非常明显的，因为这些网络拥有不同的编址方式，帧格式，协议运行逻辑。广域网和局域网的技术有更多差别，同样是分组交换技术，许多广域网采用了虚电路技术。</p><p><img src="network-layer.png" alt="network-layer"></p><p>连接这些技术相差甚远的网络，正是网络层的功能。网络层的功能由<strong>协议</strong>和<strong>称为路由器的特殊设备</strong>实现。</p><p>路由器 (router) 具有多个网络，每一个都连接到网络中，因此路由器的接口可以被认为是不同网络的接口。路由器的实现可以基于通用计算机，由软件模块来实现，但大部分基于专用的硬件电路。</p><p>与二层网络一样，在互联网络中，我们必须保证<strong>每个节点都有一个在整个互联网络范围中唯一的地址</strong>，这样的地址被称为<strong>网络地址 (network address) 或全局地址 (global address)</strong>。这样互联网络中的节点可能有两个地址，一个是本地/硬件地址，另一个是网络地址。网络层的分组必须标识网络地址，这是分组路由的依据。</p><p>路由 (routing) 是网络层的重要的任务，路由本质上是一个寻路的过程，即如何将网络分组从一个节点传输到另一个节点。路由器负责收集互联网络的拓扑信息，创建交换表，这里称为<strong>路由表 (route table)</strong>。</p><p>显而易见的是，不同网络可能帧格式不同，为了在下一个网络中传输分组，<strong>路由器需要将分组封装到新的帧</strong>。大致的过程为：路由器收到帧，提取分组，进行一些处理，然后将其封装到新帧的数据段中。</p><p><img src="internetwork.png" alt="internetwork"></p><p>总的来说，网络层有两类协议：</p><ol><li>可被路由的协议 (routed protocols)，它实现了在网络上进行分组转发的底层机制，例如 TCP/IP 网络中的 IPv4 协议。</li><li>路由协议 (routing protocols)，它是进行路由决策的协议，通常运行于路由器中，通常不被用户察觉，例如 TCP/IP 网络中的 RIP，OSPF 协议。</li></ol><h3 id="运输层-transport-layer"><a class="markdownIt-Anchor" href="#运输层-transport-layer"></a> 运输层 (Transport Layer)</h3><p>运输层为应用程序或上层提供了所需可靠性的数据传输服务。OSI 模型定义了五级运输服务，从 0 到 4 等级依次升高，根据它们提供的服务质量区别这些级别。</p><p><strong>所有的运输层及以上协议都由安装在网络终端节点的软件工具 —— 网络操作系统的部件实现。</strong></p><h3 id="会话层-session-layer"><a class="markdownIt-Anchor" href="#会话层-session-layer"></a> 会话层 (Session Layer)</h3><p>会话层保障了多个参与方之间交互的控制。事实上，使用会话层的应用程序并不多，这一层很少以<strong>独立协议</strong>的形式出现，而是和应用层结合在一起。</p><h3 id="表示层-presentation-layer"><a class="markdownIt-Anchor" href="#表示层-presentation-layer"></a> 表示层 (Presentation Layer)</h3><p>表示层处理通过网络传输的信息的表示形式，而不改变他们的内容。字符编码，数据压缩以及加密和解密在这一层完成，它们保证了应用服务数据交换的安全性，这类协议的一个例子是<strong>安全套接字层 (Secure Socket Layer, SSL)</strong>。</p><h3 id="应用层-application-layer"><a class="markdownIt-Anchor" href="#应用层-application-layer"></a> 应用层 (Application Layer)</h3><p>应用层实际上是用户用来访问共享网络资源 (例如文件、网页等) 的一系列协议。应用层的协议数据单元 (PDU) 通常被称为<strong>报文 (message)</strong>。目前著名的应用层协议包括：</p><ul><li>Web 使用的 HTTP、HTTPS 协议等</li><li>电子邮件使用的 SMTP 协议、POP 协议 等；</li><li>查询域名 IP 地址的 DNS 协议等；</li></ul><h2 id="网络标准"><a class="markdownIt-Anchor" href="#网络标准"></a> 网络标准</h2><h3 id="标准的类型"><a class="markdownIt-Anchor" href="#标准的类型"></a> 标准的类型</h3><ul><li>私有标准 (Proprietary standard)：公司或个人。</li><li>专门委员会标准 (Standards of special committee)：多个公司共同创立，如以太网联盟。</li><li>国家标准 (National standard)：包括不同国家的标准，主要说的还是美国国家标准。</li><li>国际标准 (International standard)：包括 ISO 和 ITU 开发的众多标准。</li></ul><p>标准在发展过程中可以从一个类别移到另一个类别。例如流行的、广泛使用的产品私有标准往往会变成事实上的国际标准。IBM PC 的成功，使得全世界的生产厂商都要兼容这些标准，因此，IBM 体系结构的私有标准实际上成了国际标准。</p><p>某些广为使用的私有标准，成为国家标准和国际标准的基础。例如，以太网 (Ethernet) 最初由 Digital Equipment、Intel、Xerox 公司研发，过了一段时间被采纳为 IEEE 802.3 国家标准，后来又成为 ISO 8802.3 国际标准。</p><div class="note info">            <p>虽然说 IEEE 已经由美国的组织逐渐演化成为了一个国际性的组织，但仍然由美国主导。因此说他是美国的国家标准也不为过。</p>          </div><h3 id="internet-标准"><a class="markdownIt-Anchor" href="#internet-标准"></a> Internet 标准</h3><p>Internet 因特网是开放系统最好的例子。全世界成千上万的，来自全世界不同的大学、科研机构、硬件、软件厂商等的 IT 工作者参与了这一标准的开发。定义 Internet 标准的文件被称为<strong>请求批注 (Request For Comment, RFC)</strong>。值得玩味的是，RFC 成了事实上的国际标准，大多数 RFC 也进入了 ISO 和 ITU-T 的标准。</p><p>多个组织负责开发这一标准，其中因特网工程特别任务组 (Internet Engineering Task Force, IETF) 比较重要，他们负责定义规范，这些规范最后经过 IAB 审批成为因特网标准，进入 RFC 文档。</p><div class="note info">            <p>根据 Internet 的开放原理，所有 RFC 文档都可以在 <a href="http://www.rfc-editor.org" target="_blank" rel="noopener">http://www.rfc-editor.org</a> 访问或免费下载，而 ISO 标准却不一样。</p>          </div><h2 id="通信协议的标准栈"><a class="markdownIt-Anchor" href="#通信协议的标准栈"></a> 通信协议的标准栈</h2><p>计算机网路领域，标准化最重要的方向是通信协议标准化。最著名的协议栈包括：</p><ul><li>OSI 协议栈</li><li>TCP/IP 协议栈</li><li>IPX/SPX 协议栈</li><li>NetBIOS/SMB 协议栈</li><li>DECnet 协议栈</li><li>SNA 协议栈</li></ul><p>经过数十年沉浮，<strong>目前 TCP/IP 协议栈具有垄断性的地位</strong>，所以非网络研究人员基本也不会接触其他的协议栈。这里简单讨论一下 OSI 协议栈，重点是 TCP/IP 协议栈。</p><h3 id="osi-协议栈"><a class="markdownIt-Anchor" href="#osi-协议栈"></a> OSI 协议栈</h3><p>OSI 协议栈和 OSI 模型不同：</p><ul><li>OSI 模型是开放互联系统之间交互的概念性描述，作为协议栈实现的参考。</li><li>OSI 协议栈是完全符合 OSI 模型的一系列特定的协议规范，是网络交换的具体实现。</li></ul><p>以下是 OSI 协议栈的一些定义，其中大部分也没有在真实世界中风靡过。<br><img src="protocol-stack-osi.png" alt="protocol-stack-osi"></p><h3 id="tcpip-协议栈"><a class="markdownIt-Anchor" href="#tcpip-协议栈"></a> TCP/IP 协议栈</h3><p>TCP/IP 协议栈由美国国防部发起，如今已随着 Internet 的发展成为<strong>全球最流行，最广为使用的协议栈</strong>。这也是我们如今学习的主要内容，在其他文章中，我们还将详细讨论。</p><p>以下是 TCP/IP 协议栈中的协议，是不是感觉熟悉多了。<br><img src="protocol-stack-tcpip.png" alt="protocol-stack-tcpip"></p><p>TCP/IP 栈的应用层将系统提供的服务和应用层结合起来。通过多年累计已经形成了大量的服务，包括 FTP，HTTP 等。</p><p>TCP/IP 栈的运输层为应用层提供了如下两类服务：</p><ul><li>保证递送 - 传输控制协议 (TCP)</li><li>尽力运输 - 用户数据报协议 (UDP)</li></ul><p>TCP/IP 栈的网络层也被称为互联网层，是整个体系的核心，他保证分组在互联网络中转发。IP 协议是网络层的主要协议，除此之外，还包括一些路由协议和辅助功能协议。</p><p>TCP/IP 栈的低层解决了一个更为简单的问题：<strong>只负责组织和其他网络技术的交互</strong>。TCP/IP 将互联网络中的任何网络视为路由传输的工具。因此，其任务被简化为：</p><ul><li>定义将 IP 分组封装为中间网络 PDU 的方法</li><li>定义将网络地址转化为中间网络技术使用的地址的方法</li></ul><p>简单的说就是：TCP/IP 协议栈不管你底层使用了什么数据链路层技术（是局域网还是广域网），甚至不管你底层是不是数据链路层（哪怕是另一个 IP 网络），只要你可以把你的数据包封装到 IP 包里面，并且提供网络地址转换的技术，就可以当作 IP 网络的底层承载网络。</p><p>这样开放的方式使得对于任何网络，只要开发特定的接口就可以将其纳入 TCP/IP 协议栈中，它支持所有流行的网络技术，因此它迅速的风靡了。<strong>特别的，TCP/IP 协议栈允许将网络包含进互联网络中，而无论这些网络层数有多少</strong>。这样可能造成一种网络协议工作在另一层网络协议之上，看似与 OSI 模型相违背，但对于 TCP/IP 栈来说，这是非常正常的，如今风靡的各种隧道技术，正是利用了这样层层套娃的特性。</p><p>每一种通信协议操作特定的所传输的数据单元，称为协议数据单元 (Protocol Data Unit, PDU)。</p><ul><li>流 (stream) -&gt; 段 (segment)</li><li>数据报 (datagram) 是无连接协议中常用的 PDU 名称，一般用于 UDP，但有时也用于 IP。</li><li>分组 (packet) 用于 IP 协议，称为 IP 分组。</li><li>帧 (frame) 是 IP 分组为了之后在网络上传输而被封装进去的任何技术的 PDU。<strong>以太网帧，ATM 信元，X.25 分组，都被 TCP/IP 栈认为是帧</strong>。</li></ul><p><img src="tcpip-pdu.png" alt="tcpip-pdu"></p><h3 id="tcpip-协议栈和-osi-模型"><a class="markdownIt-Anchor" href="#tcpip-协议栈和-osi-模型"></a> TCP/IP 协议栈和 OSI 模型</h3><p>如果经过的阅读，你会发现 OSI 模型是如此的优雅，每一层的功能十分清晰。上层请求下层，下层为上层提供服务，同一层的模块负责完成一个共同任务。在协议中，上层 PDU 被封装进下层 PDU 中。但大多数情况下，栈的开发者牺牲模块结构来加速栈的运行，这造成了协议栈和 OSI 模型的对应相当一般。</p><p>例如，在 TCP/IP 网络中，IP 用来转发分组，而 RIP 和 OSPF 是路由协议，理应属于同一层。然而 RIP 报文被封装到 UDP 数据报，OSPF 报文被封装到 IP 分组。</p><p>如今，大部分的网络学习者只会学习到 TCP/IP 协议栈，因此，我们应当按照功能模块去学习和认知网络，而不应该死板的按照每一层的协议去学习。例如，ARP 协议，IP 协议，DHCP 协议，DNS 协议，NAT 协议都是和地址相关的，但他们分别工作在各个层，融会起来学习就会明白 TCP/IP 中的编址技术，了解其后的历史和原理，也就会明白为什么需要硬件地址，网络地址，域名地址，以及这些地址是如何解决网络中的问题的。</p><h2 id="网络工程师-vs-程序员"><a class="markdownIt-Anchor" href="#网络工程师-vs-程序员"></a> 网络工程师 vs 程序员</h2><p>计算机网络服务可以被分为以下两类：</p><ul><li><strong>运输服务</strong>：只负责将信息从发送端传送到接收端，而不改变传送点信息。例如在电信网络中的电话服务。</li><li><strong>信息服务</strong>：包括提供新信息给用户。信息服务总是和数据处理操作相关，数据以某种方式存储，以所需要的方式呈现。包括编程，数据库，文件存储，万维网，电子邮件都被用来提供信息服务。</li></ul><p>在如今的计算机网络中，两种服务同样重要。这也导致了专业人员被分类为网络专业工作者和 IT 专业工作者。前者包括参与解决网络运输问题的工作者，他们更多与通信设备和通信链路打交道；而后者包括程序员，数据库开发，操作系统管理员，网站设计师等等，他们主要与计算机软件和硬件打交道。下图是各种协议栈部件的分布，也能说明两者工作的网络层次各有主次。</p><p><img src="protocol-distribution.png" alt="protocol-distribution"></p><p>不可否认的是，随着网络的逐渐完善，仅仅掌握网络运输服务的内容已经不足以使工程师拥有较高的议价权 (如今为 2019 年，对比 20 世纪初期而言)，用户对于信息的渴望已经超过对于运输的渴望，例如短视频，实时直播等。这得益于网络的性能已经比较优良，能满足大部分人的一般需求。如今，随着软件定义网络、虚拟化、云计算、分布式等系统的演进，两者交叉更加紧密，同时掌握网络和 IT 知识已经成为不可避免的趋势。</p><h2 id="参考-reference"><a class="markdownIt-Anchor" href="#参考-reference"></a> 参考 (Reference)</h2><ul><li><a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI model, wikipedia</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Users and Groups</title>
      <link href="/2018/11/17/linux-users-and-groups/"/>
      <url>/2018/11/17/linux-users-and-groups/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考文章为 <a href="https://wiki.archlinux.org/index.php/Users_and_groups" target="_blank" rel="noopener">Users and groups, ArchWiki</a> 。</p><p>新安装的 Linux 默认采用超级权限用户登录，也就是 <code>root</code>，长时间用 root 账户登录或是在 SSH 服务器上公开它是十分不安全的。Linux/Unix 是完全意义上的<strong>多用户多任务</strong>操作系统，所以推荐的做法是<strong>为大多数任务创建和使用非特权账户，而仅使用 root 账户进行系统管理</strong>。</p><p>用户 (Users) 和组 (Groups) 是一种 GNU/Linux 系统对文件、目录和外设访问控制 (access control) 的机制 (mechanism)，管理员可以微调组成员和权限，以授权和拒绝用户或服务对系统资源的访问。Linux 默认提供了相当简单粗暴的访问控制机制，所以，每一个 Linuxer 都应当十分熟悉用户和组的概念。:p</p><a id="more"></a><h2 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h2><p>用户就是计算机为每个使用者创建的名称，这个名称是一个人获得使用计算机的权限。当然，一个人 (individual)可以有多个账户/用户 (account/user)，只要名字不同即可。但有一些名字是保留的，不可以使用，例如 <code>root</code>。</p><p>多个用户 (users) 可以组合在一起形成组 (group)，一个组可以包含多个用户，一个用户也可以属于多个组，这是很自然的，因为人在社交中也在不同的场合中扮演不同的角色。</p><h2 id="权限和所属"><a class="markdownIt-Anchor" href="#权限和所属"></a> 权限和所属</h2><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>In Unix Everything is a file.<br>Unix 中一切皆文件。</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>这是很有趣的哲学，意味着**文件 (file)**这一模型，提供了对所有 I/O 资源访问的抽象，包括文档、目录、磁盘、CD-ROM、调制解调器、键盘、打印机、显示器和终端等等，甚至也包括了进程、网络之间的通信。所有文件都通过一致的 API 以提供访问，因此只用同一套简单的命令，就可以读写磁盘、键盘、文档以及网络设备。</p><p>GNU/Linux 系统中的每一个文件都从属一个用户（属主）和一个用户组（属组），这称为 <strong>ownership</strong> 机制。另外，还有三种类型的<strong>访问权限 (access permissions)</strong>：读（read）、写（write）、运行（execute）。**我们可以针对文件的属主、属组、而设置相应的访问权限。**用 <code>ls</code> 命令长格式看看吧：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ls -l /boot/</span><br><span class="line">total <span class="number">136492</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root  <span class="number">1537997</span> <span class="number">10</span>月 <span class="number">23</span> <span class="number">22</span>:<span class="number">44</span> abi<span class="number">-4.15</span><span class="number">.0</span><span class="number">-39</span>-generic</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root   <span class="number">217018</span> <span class="number">10</span>月 <span class="number">23</span> <span class="number">22</span>:<span class="number">44</span> config<span class="number">-4.15</span><span class="number">.0</span><span class="number">-39</span>-generic</span><br><span class="line">drwx------ <span class="number">3</span> root root    <span class="number">16384</span> <span class="number">1</span>月   <span class="number">1</span>  <span class="number">1970</span> efi</span><br><span class="line">drwxr-xr-x <span class="number">6</span> root root     <span class="number">4096</span> <span class="number">11</span>月 <span class="number">15</span> <span class="number">15</span>:<span class="number">37</span> grub</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">55501463</span> <span class="number">11</span>月 <span class="number">14</span> <span class="number">14</span>:<span class="number">16</span> initrd.img<span class="number">-4.15</span><span class="number">.0</span><span class="number">-39</span>-generic</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root   <span class="number">182704</span> <span class="number">1</span>月  <span class="number">28</span>  <span class="number">2016</span> memtest86+.bin</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root   <span class="number">184380</span> <span class="number">1</span>月  <span class="number">28</span>  <span class="number">2016</span> memtest86+.elf</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root   <span class="number">184840</span> <span class="number">1</span>月  <span class="number">28</span>  <span class="number">2016</span> memtest86+_multiboot.bin</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root        <span class="number">0</span> <span class="number">10</span>月 <span class="number">23</span> <span class="number">22</span>:<span class="number">44</span> retpoline<span class="number">-4.15</span><span class="number">.0</span><span class="number">-39</span>-generic</span><br><span class="line">-rw------- <span class="number">1</span> root root  <span class="number">4047147</span> <span class="number">10</span>月 <span class="number">23</span> <span class="number">22</span>:<span class="number">44</span> System.map<span class="number">-4.15</span><span class="number">.0</span><span class="number">-39</span>-generic</span><br><span class="line">-rw------- <span class="number">1</span> root root  <span class="number">8277752</span> <span class="number">10</span>月 <span class="number">23</span> <span class="number">22</span>:<span class="number">59</span> vmlinuz<span class="number">-4.15</span><span class="number">.0</span><span class="number">-39</span>-generic</span><br></pre></td></tr></table></figure><ul><li>第 1 列：文件访问权限<ul><li>文件类型（1）：目录为 <code>d</code>，文件为 <code>-</code>。</li><li>属主权限（3）</li><li>属组用户权限（3）</li><li>其他用户权限（3）</li></ul></li><li>第 3 列：属主</li><li>第 4 列：属组</li></ul><p>查看用户的属主、属组以及访问权限可以通过 <code>stat</code> 命令。例如：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ stat -<span class="keyword">c</span> <span class="symbol">%U</span> /media/liyj/Shared</span><br><span class="line">liyj</span><br><span class="line">➜  ~ stat -<span class="keyword">c</span> <span class="symbol">%G</span> /media/liyj/Shared</span><br><span class="line">liyj</span><br><span class="line">➜  ~ stat -<span class="keyword">c</span> <span class="symbol">%A</span> /media/liyj/Shared</span><br><span class="line">drwxrwxrwx</span><br></pre></td></tr></table></figure><div class="note info">            <p>stat - display file or file system status<br>stat 是用来显示文件（默认行为）或文件系统的命令，较常使用的有：</p><ul><li>直接使用 <code>stat FILE ...</code> 显示文件状态，输出使用较为详细的默认格式。</li><li>通过 <code>-c</code> 参数可以指定 format 从而改变 (<strong>c</strong>hange) 文件状态输出格式，format 参数见 manual 手册。</li><li>通过 <code>-f</code> 参数可以显示文件系统的状态。</li></ul><p>详细用法请查阅 manual 手册。</p>          </div><p>其中 rwx 分别代表了 可读，可写，可执行，有相应权限则写明字母，若无相应权限，则用 <code>-</code> 代替。如上述 <code>grub</code> 目录 root 用户有读、写、执行权限，而 root 组所有用户以及其他用户，均只有读、执行权限。</p><p>通过 find 命令可以查找属于某个用户或某个组的文件</p><ul><li>find / -grup <em>groupname</em></li><li>find / -group <em>groupnumber</em></li><li>find / -user <em>user</em></li></ul><p>文件的属主、属组可以通过 <code>chown</code> 命令更改。文件的权限可以通过 <code>chmod</code> 命令修改。</p><p>详情参见：<code>chown(1)</code>、<code>chmod(1)</code>、<a href="https://www.linux.com/learn/understanding-Linux-file-permissions" target="_blank" rel="noopener">Linux 文件权限</a>。</p><h2 id="信息存储"><a class="markdownIt-Anchor" href="#信息存储"></a> 信息存储</h2><table><thead><tr><th>File</th><th>Purpose</th><th>解释</th></tr></thead><tbody><tr><td><code>/etc/passwd</code></td><td>User account information</td><td>用户账户信息</td></tr><tr><td><code>/etc/shadow</code></td><td>Secure user account information</td><td>用户账户安全信息</td></tr><tr><td><code>/etc/group</code></td><td>Defines the groups to which users belong</td><td>群组账户信息</td></tr><tr><td><code>/etc/gshadow</code></td><td>Contains the shadowed information for group accounts</td><td>群组账户安全信息</td></tr><tr><td><code>/etc/sudoers</code></td><td>List of who can run what by sudo</td><td>可以运行 sudo 的用户</td></tr><tr><td><code>/home/*</code></td><td>Home directories</td><td>家目录</td></tr></tbody></table><h3 id="用户信息存储"><a class="markdownIt-Anchor" href="#用户信息存储"></a> 用户信息存储</h3><p>本地用户信息存储在 <code>/etc/passwd</code> 文件中，一行代表一个用户，每行分七个部分，用英文冒号“:”分开：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">account</span><span class="selector-pseudo">:password</span><span class="selector-pseudo">:UID</span><span class="selector-pseudo">:GID</span><span class="selector-pseudo">:GECOS</span><span class="selector-pseudo">:directory</span><span class="selector-pseudo">:shell</span></span><br></pre></td></tr></table></figure><ul><li><code>account</code> 是用户名，需要遵循标准 *Nix 命名准则。</li><li><code>password</code> 是用户密码。</li></ul><div class="note warning">            <p><code>/etc/passwd</code> 对所有人可读，存储密码（无论是否通过哈希运算等方式加密）是不安全的，因此在 password 字段，用一个占位符 <code>x</code> 代替，加密过的密码储存在 <code>/etc/shadow</code> 文件，该文件对普通用户限制访问，shadow 这个名字也表示了密码被阴影笼罩住了。:p</p>          </div><ul><li><code>UID</code> 是用户ID，在 Arch 中，第一个非 root 用户的默认 UID 是 1000，后续创建的用户 UID 也应大于1000。</li><li><code>GID</code> 是用户首要组的 ID，组的 ID 在 <code>/etc/group</code> 文件中。</li><li><code>GECOS</code> 是可选的注释字段，通常记录用户全名。</li><li><code>directory</code> 用于登录命令设置 <code>$HOME</code> 环境变量。</li><li><code>shell</code> 是用户默认登录的shell，通常是Bash。</li></ul><h3 id="群组信息存储"><a class="markdownIt-Anchor" href="#群组信息存储"></a> 群组信息存储</h3><p>本地群组信息存储在 <code>/etc/group</code> 文件中，一行代表一个群组，每行分四个部分，用英文冒号“:”分开：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">group</span><span class="selector-pseudo">:password</span><span class="selector-pseudo">:GID</span><span class="selector-pseudo">:user_list</span></span><br></pre></td></tr></table></figure><ul><li><code>group</code> 是群组名称。</li><li><code>password</code> 是群组密码，同用户安全信息机制相同，加密过的密码储存在 <code>/etc/gshadow</code> 文件中。</li><li><code>GID</code> 是群组 ID，是一个整数。</li><li><code>user_list</code> 是群组中的用户成员，用逗号分割，群组可能是该用户的首要组，也可能是附加组；若此项为空，则表示该群组成员仅有一个，且用户名同组名相同。</li></ul><h2 id="用户管理"><a class="markdownIt-Anchor" href="#用户管理"></a> 用户管理</h2><ul><li>使用 <code>who</code> 或 <code>users</code> 命令，可以查看目前已登陆的用户。</li><li>以 root 执行 <code>passwd -Sa</code>，可以查看系统上的用户。</li></ul><h3 id="useradd-创建用户"><a class="markdownIt-Anchor" href="#useradd-创建用户"></a> <code>useradd</code> 创建用户</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># useradd -m -g initial_group -G additional_groups -s login_shell username</span></span><br></pre></td></tr></table></figure><ul><li><code>-m/--create-home</code>：创建用户家目录 <code>/home/username</code>。</li><li><code>-g/--gid</code>：设置用户初始组的名称或数字 ID。<strong>如果设置此项，则组必须存在；如果不设置此项，将会根据<code>/etc/login.defs</code> 中的 <code>USERGROUPS_ENAB</code> 变量设置，默认行为是创建与用户名相同的组名，GID 等于 UID。</strong></li><li><code>-G/--groups</code>：该用户要加入的其他组列表，用逗号分割，不加空格。<strong>如果不设置，用户只加入初始组。</strong></li><li><code>-s/--shell</code>：用户默认登录 shell 的路径。默认为 sh 或 bash。有时候需要禁止某些用户执行登录动作，例如用来执行系统服务的用户。将 shell 设置成 <code>/usr/bin/nologin</code> 就可以禁止用户登录。</li></ul><div class="note warning">            <p>为了确保能够登录，shell 路径应当在 <code>/etc/shells</code> 列表中，否则 <code>pam_shell</code> 将会拒绝登录。也不要使用 <code>/usr/bin/bash</code> 来代替 <code>/bin/bash</code>，除非已经在 <code>/etc/shells</code> 中合理配置。</p><p>新创建的用户记得用 <code>passwd username</code> 来设置密码。</p>          </div><h4 id="示例添加登录用户"><a class="markdownIt-Anchor" href="#示例添加登录用户"></a> 示例：添加登录用户</h4><p>使用如下命令创建一个登录用户 test1，并设置密码。为该用户：创建用户目录 test1；默认创建同名群组 test1；默认不添加附加组；使用默认 shell。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># useradd -m test1 </span></span><br><span class="line"><span class="meta"># passwd test1</span></span><br></pre></td></tr></table></figure><p>查看创建的用户，验证以上参数的结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~ cat /etc/passwd | grep test1</span><br><span class="line">test1:x:1001:1001::/home/test1:/bin/sh</span><br><span class="line">~ cat /etc<span class="built_in">/group </span>| grep test1</span><br><span class="line">test1:x:1001:</span><br><span class="line">~ ls /home</span><br><span class="line">liyj  test1</span><br></pre></td></tr></table></figure><h4 id="示例添加系统用户"><a class="markdownIt-Anchor" href="#示例添加系统用户"></a> 示例：添加系统用户</h4><p>不同的系统用户可以为进程、守护进程提供更安全的管控目录及文件的访问。使用如下命令创建一个<strong>非登录，无 home 目录的系统用户。（可以加入 -U 参数创建一个和用户名相同的群组，并自动将用户加入它）</strong></p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># useradd -r -s /usr/bin/nologin username</span></span><br></pre></td></tr></table></figure><h3 id="usermod-更改用户信息"><a class="markdownIt-Anchor" href="#usermod-更改用户信息"></a> <code>usermod</code> 更改用户信息</h3><table><thead><tr><th>作用</th><th>命令</th><th>注释</th></tr></thead><tbody><tr><td>更改用户登录名称</td><td><code># usermod -l newname oldname</code></td><td>仅更改用户名字，不更改主目录名称，更不更改同步创建的组名</td></tr><tr><td>更改用户主目录</td><td><code># usermod -d /my/new/home -m username</code></td><td>自动创建新目录，并移动内容。</td></tr><tr><td>将用户加入群组</td><td><code># usermod -aG additional_groups username</code></td><td>支持加入多个群组，用逗号分隔。<strong>如果省略 <code>-a</code> 参数，该用户会离开没有列在群组的其它群组。</strong></td></tr><tr><td>设置注释</td><td><code># usermod -c &quot;Comment&quot; username</code></td><td>也可以使用 <code># chfn username</code> 启动交互式模式设置。</td></tr><tr><td>改变用户登录 shell</td><td><code># usermod -s /bin/bash username</code></td><td></td></tr></tbody></table><p>更具体内容，请参阅 <code>man usermod</code>。</p><h3 id="userdel-删除用户"><a class="markdownIt-Anchor" href="#userdel-删除用户"></a> <code>userdel</code> 删除用户</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># userdel -r username</span></span><br></pre></td></tr></table></figure><h2 id="群组管理"><a class="markdownIt-Anchor" href="#群组管理"></a> 群组管理</h2><ul><li>使用 <code>groups user</code> 查看用户群组关系，如果 user 省略，默认查看当前用户的群组关系。另外，通过 <code>id user</code> 可以看到更详细的信息，如 UID 和 GID。</li><li>列出系统上所有群组：<code>cat /etc/group</code></li></ul><h3 id="增删群组"><a class="markdownIt-Anchor" href="#增删群组"></a> 增删群组</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># groupadd group # 创建新的组</span><br><span class="line"># groupdel group # 删除用户组</span><br></pre></td></tr></table></figure><h3 id="gpasswd-增删群组成员"><a class="markdownIt-Anchor" href="#gpasswd-增删群组成员"></a> <code>gpasswd</code> 增删群组成员</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># gpasswd -a user group # 将用户添加到组</span><br><span class="line"># gpasswd -d user group # 将用户从组中移除</span><br></pre></td></tr></table></figure><h3 id="groupmod-更改信息"><a class="markdownIt-Anchor" href="#groupmod-更改信息"></a> <code>groupmod</code> 更改信息</h3><p>更改用户所属的组名，不变更GID：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># groupmod -n newname oldname</span></span><br></pre></td></tr></table></figure><h2 id="交互式脚本"><a class="markdownIt-Anchor" href="#交互式脚本"></a> 交互式脚本</h2><p>除了上述的命令，还有一些以交互方式执行的脚本，这些脚本后台调用上述命令，更加易用。这些脚本的命名方式采用<strong>动作＋对象</strong>，而不是<strong>对象＋动作</strong>，这些脚本包括：</p><ul><li><code>adduser</code>, <code>addgroup</code> - add a user or group to the system<ul><li>Add a normal user</li><li>Add a system user</li><li>Add a user group</li><li>Add a system group</li><li>Add an existing user to an existing group</li></ul></li><li><code>deluser</code>, <code>delgroup</code> - remove a user or group from the system<ul><li>Remove a normal user</li><li>Remove a group</li><li>Remove a user from a specific group</li></ul></li></ul><p>例如：使用 <code>adduser</code> 可以以交互的方式执行 <code>useradd</code>, <code>chfn</code> 和 <code>passwd</code>。</p><p>更多的使用方式查阅手册。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>Unix 系统中一切皆文件。</li><li>访问权限 (permission) 说的是文件 (files) 和用户 (users) 之间的联系。<ul><li>通过 <code>chown</code> 改变文件的属主和属组。</li><li>通过 <code>chmod</code> 改变文件对于属主用户，属组用户以及其他用户的访问权限。</li></ul></li><li>成员关系 (ownership) 说的是用户 (users) 和 群组 (groups) 之间的联系。一个用户可以属于多个群组，一个群组也可以包含多个用户。</li><li>用户和群组信息存储在 <code>/etc/{passwd, group}</code> 中，其中的加密信息以影子文件的形式存储在 <code>/etc/{shadow, gshadow}</code> 中。</li><li>用户和群组的管理可以用<strong>基础命令</strong>来管理，基础命令命名方式为<strong>对象＋动作</strong>，例如：<ul><li>useradd, groupadd</li><li>usermod, groupmod</li><li>userdel, groupdel</li></ul></li><li>为用户添加密码使用 <code>passwd</code>，为群组增减成员使用 <code>gpasswd</code>。</li><li>用户和群组的管理还可以用<strong>构建于基础命令上的脚本</strong>来管理，脚本的命名方式为<strong>动作＋对象</strong>，例如：<ul><li>adduser, addgroup</li><li>deluser, delgroup</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Command-line </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mininet Basics</title>
      <link href="/2018/10/31/sdn-mininet/"/>
      <url>/2018/10/31/sdn-mininet/</url>
      
        <content type="html"><![CDATA[<p>本文依据 <a href="http://mininet.org" target="_blank" rel="noopener">mininet.org</a> 写成，包含官方文档的三部分：</p><ol><li><a href="http://mininet.org/download" target="_blank" rel="noopener">Download/Get Started With Mininet</a></li><li><a href="http://mininet.org/sample-workflow" target="_blank" rel="noopener">Mininet Sample Workflow</a></li><li><a href="http://mininet.org/walkthrough" target="_blank" rel="noopener">Mininet Walkthrough</a></li></ol><a id="more"></a><h2 id="下载安装-download"><a class="markdownIt-Anchor" href="#下载安装-download"></a> 下载安装 (Download)</h2><p>官方提供了四种安装方式：</p><ul><li>Option 1: Mininet VM Installation (easy, recommended) | 虚拟机安装（简单，推荐）</li><li>Option 2: Native Installation from Source | 从源码安装</li><li>Option 3: Installation from Packages | 从包管理器安装</li><li>Option 4. Upgrading an existing Mininet Installation | 升级安装 mininet</li></ul><p>由于笔者手头有 Ubuntu 18.04 系统，因此<strong>直接选择了第二项使用源码方式实体安装</strong>；如若没有 ubuntu 环境，还是按照官方推荐的 VM 方式安装。</p><p>官方推荐的安装系统为：Ubuntu 和 Fedora 的较新发行版。安装方式也很简单，如下：</p><ol><li>下载官方源码：</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>://github.com/mininet/mininet</span><br></pre></td></tr></table></figure><ol start="2"><li>选择安装版本：</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd mininet</span><br><span class="line">git <span class="keyword">tag</span></span><br><span class="line">git checkout -b <span class="number">2.2</span>.<span class="number">1</span> <span class="comment"># 如果想安装某一个版本，使用对应的 git tag，否则，不执行此命令，默认安装最新版本。</span></span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><ol start="3"><li>执行安装脚本</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet<span class="regexp">/util/i</span>nstall.sh [<span class="keyword">options</span>]</span><br></pre></td></tr></table></figure><div class="note info">            <p>脚本参数包含：</p><ul><li><code>-a</code>：安装 Mininet VM 中的全部内容。包括一些其他依赖，如Open vSwitch，OpenFlow wireshark dissector 和 POX。以上软件默认安装到 home 目录。</li><li><code>-nfv</code>：安装 Mininet, the OpenFlow reference switch, and Open vSwitch</li><li><code>-s mydir</code>：自定义安装的目录，默认为家目录。<br>例如：</li><li>To install everything (using your home directory): <code>install.sh -a</code></li><li>To install everything (using another directory for build): <code>install.sh -s mydir -a</code></li><li>To install Mininet + user switch + OVS (using your home dir): <code>install.sh -nfv</code></li><li>To install Mininet + user switch + OVS (using another dir:) <code>install.sh -s mydir -nfv</code></li></ul><p>另外的参数可以通过 <code>install -h</code> 获取。</p>          </div><ol start="4"><li>测试<br>安装完成后，测试基本功能：</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn <span class="comment">--test pingall</span></span><br></pre></td></tr></table></figure><h2 id="工作流程-sample-workflow"><a class="markdownIt-Anchor" href="#工作流程-sample-workflow"></a> 工作流程 (Sample Workflow)</h2><p>通过 Mininet 可以快速创建，交互，自定义，分享 SDN 网络拓扑，或者部署到硬件。</p><h3 id="创建网络"><a class="markdownIt-Anchor" href="#创建网络"></a> 创建网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mn --switch ovs --controller ref --topo tree,depth=2,fanout=4 --<span class="built_in">test</span> pingall</span><br><span class="line"></span><br><span class="line">**以下为输出结果：**</span><br><span class="line">*** Creating network</span><br><span class="line">*** Adding controller</span><br><span class="line">*** Adding hosts:</span><br><span class="line">h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">*** Adding switches:</span><br><span class="line">s1 s2 s3 s4 s5 </span><br><span class="line">*** Adding links:</span><br><span class="line">(s1, s2) (s1, s3) (s1, s4) (s1, s5) (s2, h1) (s2, h2) (s2, h3) (s2, h4) (s3, h5) (s3, h6)</span><br><span class="line">(s3, h7) (s3, h8) (s4, h9) (s4, h10) (s4, h11) (s4, h12) (s5, h13) (s5, h14) (s5, h15) (s5, h16) </span><br><span class="line">*** Configuring hosts</span><br><span class="line">h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">*** Starting controller</span><br><span class="line">c0 </span><br><span class="line">*** Starting 5 switches</span><br><span class="line">s1 s2 s3 s4 s5 ...</span><br><span class="line">*** Waiting <span class="keyword">for</span> switches to connect</span><br><span class="line">s1 s2 s3 s4 s5 </span><br><span class="line">*** Ping: testing ping reachability</span><br><span class="line">h1 -&gt; h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h2 -&gt; h1 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h3 -&gt; h1 h2 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h4 -&gt; h1 h2 h3 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h5 -&gt; h1 h2 h3 h4 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h6 -&gt; h1 h2 h3 h4 h5 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h7 -&gt; h1 h2 h3 h4 h5 h6 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h8 -&gt; h1 h2 h3 h4 h5 h6 h7 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h9 -&gt; h1 h2 h3 h4 h5 h6 h7 h8 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h10 -&gt; h1 h2 h3 h4 h5 h6 h7 h8 h9 h11 h12 h13 h14 h15 h16 </span><br><span class="line">h11 -&gt; h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h12 h13 h14 h15 h16 </span><br><span class="line">h12 -&gt; h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h13 h14 h15 h16 </span><br><span class="line">h13 -&gt; h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h14 h15 h16 </span><br><span class="line">h14 -&gt; h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h15 h16 </span><br><span class="line">h15 -&gt; h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h16 </span><br><span class="line">h16 -&gt; h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 </span><br><span class="line">*** Results: 0% dropped (240/240 received)</span><br><span class="line">*** Stopping 1 controllers</span><br><span class="line">c0 </span><br><span class="line">*** Stopping 20 links</span><br><span class="line">....................</span><br><span class="line">*** Stopping 5 switches</span><br><span class="line">s1 s2 s3 s4 s5 </span><br><span class="line">*** Stopping 16 hosts</span><br><span class="line">h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 </span><br><span class="line">*** Done</span><br><span class="line">completed <span class="keyword">in</span> 15.003 seconds</span><br></pre></td></tr></table></figure><p>命令行参数相关解释如下：</p><ul><li>交换机 (<code>--switch ovs</code>)：Open vSwitch</li><li>控制器 (<code>--controller ref</code>)：OpenFlow/Stanford reference controller 标准参考控制器</li><li>拓扑 (<code>--topo tree,depth=2,fanout=4</code>)：a tree topology of depth 2 and fanout 4 (i.e. 16 hosts connected to 5 switches)</li><li>命令 (<code>--test pingall</code>)：测试连接，节点之间互相发送 ping 命令。</li></ul><div class="note info">            <p>ping 命令将会测试网络连接性，<strong>接着删除整个网络并退出 mininet 交互环境</strong>。如果不加任何命令，则进入 <strong>mininet 的命令行交互环境，等待用户执行 mininet 命令</strong>。</p>          </div><h3 id="网络交互"><a class="markdownIt-Anchor" href="#网络交互"></a> 网络交互</h3><p>Mininet 允许使用命令行交互，通过一个单独的 console，便可以控制和管理整个虚拟网络。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --switch ovs --controller ref --topo tree,depth=2,fanout=8</span><br><span class="line">*** Creating network ...</span><br><span class="line">*** Adding controller ...</span><br><span class="line">*** Adding hosts: ...</span><br><span class="line">*** Adding switches: ...</span><br><span class="line">*** Adding links: ...</span><br><span class="line">*** Configuring hosts ...</span><br><span class="line">*** Starting controller ...</span><br><span class="line">*** Starting 9 switches ...</span><br><span class="line">*** Starting CLI:</span><br><span class="line">mininet&gt; h2 ping h3</span><br><span class="line">PING 10.0.0.3 (10.0.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.3: icmp_seq=1 ttl=64 time=25.3 ms</span><br><span class="line">64 bytes from 10.0.0.3: icmp_seq=2 ttl=64 time=0.512 ms</span><br><span class="line">64 bytes from 10.0.0.3: icmp_seq=3 ttl=64 time=0.076 ms</span><br><span class="line">64 bytes from 10.0.0.3: icmp_seq=4 ttl=64 time=0.088 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上述命令是：主机 <code>h2</code> 执行 ping 主机 <code>h3</code> 的命令。不仅如此，<strong>任何可用的 Linux 命令或者程序都可以在虚拟主机上运行</strong>，只需要在开头指明主机名即可。例如在主机<code>h2</code> 上运行一个简单的 Web 服务器，并在主机<code>h3</code>上使用 <code>wget</code> 命令请求。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; h2 python -m SimpleHTTPServer <span class="number">80</span> &gt;&amp; /tmp/http.log &amp;</span><br><span class="line">mininet&gt; h3 wget -O - h2</span><br><span class="line">-<span class="number">-2018</span><span class="number">-11</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">20</span>--  http:<span class="comment">//10.0.0.2/</span></span><br><span class="line">Connecting to <span class="number">10.0</span><span class="number">.0</span><span class="number">.2</span>:<span class="number">80.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">200</span> OK</span><br></pre></td></tr></table></figure><h3 id="自定义网络"><a class="markdownIt-Anchor" href="#自定义网络"></a> 自定义网络</h3><p>Mininet 的 API 允许用户使用 Python 脚本创建自定义网络。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mininet.net <span class="keyword">import</span> Mininet</span><br><span class="line"><span class="keyword">from</span> mininet.topolib <span class="keyword">import</span> TreeTopo</span><br><span class="line">tree4 = TreeTopo(depth=<span class="number">2</span>,fanout=<span class="number">2</span>)</span><br><span class="line">net = Mininet(topo=tree4)</span><br><span class="line">net.start()</span><br><span class="line">h1, h4  = net.hosts[<span class="number">0</span>], net.hosts[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> h1.cmd(<span class="string">'ping -c1 %s'</span> % h4.IP())</span><br><span class="line">net.stop()</span><br></pre></td></tr></table></figure><p>上述脚本创建了一个小型网络（4个主机，3个交换机），并通过 主机<code>h1</code> ping 主机<code>h4</code>。</p><p>伴随 Mininet 一同发行的还有一些工具，可以帮助用户为自己的网络创建有用的应用。</p><h3 id="分享网络"><a class="markdownIt-Anchor" href="#分享网络"></a> 分享网络</h3><ul><li>通过 Mininet 的虚拟机镜像（VM Image）分享网络。</li><li>通过在系统上实体安装 Mininet 分享网络。</li></ul><h3 id="硬件部署"><a class="markdownIt-Anchor" href="#硬件部署"></a> 硬件部署</h3><p>一旦一个网络设计在 Mininet 上运行良好，便可以在真实的硬件上部署、测试和管理网络。<strong>但每个 Mininet 仿真组件必须和真实物理环境的组件对应</strong>。</p><ul><li>虚拟拓扑用真实物理拓扑取代。</li><li>虚拟以太网连接对用链路级以太网连接取代。</li><li>仿真主机用实际 OS 取代。</li><li>仿真 OpenFlow Switch 用真实交换机取代。</li><li><strong>控制器不需要改变</strong>。</li></ul><h2 id="官方攻略-mininet-walkthrough"><a class="markdownIt-Anchor" href="#官方攻略-mininet-walkthrough"></a> 官方攻略 (Mininet Walkthrough)</h2><p>通过前面两章的学习，我们已经安装了 Mininet，并进行了一些简单的用法介绍。在设计我们自己的网络之前，不如先学习一下官方提供的完整版攻略。</p><h3 id="mininet-启动选项参数-startup-options"><a class="markdownIt-Anchor" href="#mininet-启动选项参数-startup-options"></a> Mininet 启动选项参数 (Startup Options)</h3><h4 id="显示启动选项"><a class="markdownIt-Anchor" href="#显示启动选项"></a> 显示启动选项</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mn -h</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message <span class="literal">and</span> exit</span><br><span class="line">  <span class="attr">--switch=SWITCH</span>       default|ivs|lxbr|ovs|ovsbr|ovsk|user[,<span class="attr">param=value...]</span></span><br><span class="line">                        <span class="attr">ovs=OVSSwitch</span> <span class="attr">default=OVSSwitch</span> <span class="attr">ovsk=OVSSwitch</span></span><br><span class="line">                        <span class="attr">lxbr=LinuxBridge</span> <span class="attr">user=UserSwitch</span> <span class="attr">ivs=IVSSwitch</span></span><br><span class="line">                        <span class="attr">ovsbr=OVSBridge</span></span><br><span class="line">  <span class="attr">--host=HOST</span>           cfs|proc|rt[,<span class="attr">param=value...]</span></span><br><span class="line">                        <span class="attr">rt=CPULimitedHost&#123;'sched':</span> 'rt'&#125; <span class="attr">proc=Host</span></span><br><span class="line">                        <span class="attr">cfs=CPULimitedHost&#123;'sched':</span> 'cfs'&#125;</span><br><span class="line">  <span class="attr">--controller=CONTROLLER</span></span><br><span class="line">                        default|none|nox|ovsc|ref|remote|ryu[,<span class="attr">param=value...]</span></span><br><span class="line">                        <span class="attr">ovsc=OVSController</span> <span class="attr">none=NullController</span></span><br><span class="line">                        <span class="attr">remote=RemoteController</span> <span class="attr">default=DefaultController</span></span><br><span class="line">                        <span class="attr">nox=NOX</span> <span class="attr">ryu=Ryu</span> <span class="attr">ref=Controller</span></span><br><span class="line">  <span class="attr">--link=LINK</span>           default|ovs|tc|tcu[,<span class="attr">param=value...]</span> <span class="attr">default=Link</span></span><br><span class="line">                        <span class="attr">ovs=OVSLink</span> <span class="attr">tcu=TCULink</span> <span class="attr">tc=TCLink</span></span><br><span class="line">  <span class="attr">--topo=TOPO</span>           linear|minimal|reversed|single|torus|tree[,<span class="attr">param=value</span></span><br><span class="line">                        ...] <span class="attr">linear=LinearTopo</span> <span class="attr">torus=TorusTopo</span> <span class="attr">tree=TreeTopo</span></span><br><span class="line">                        <span class="attr">single=SingleSwitchTopo</span></span><br><span class="line">                        <span class="attr">reversed=SingleSwitchReversedTopo</span> <span class="attr">minimal=MinimalTopo</span></span><br><span class="line">  -c, --clean           clean <span class="literal">and</span> exit</span><br><span class="line">  <span class="attr">--custom=CUSTOM</span>       read custom classes <span class="literal">or</span> params from .py file(s)</span><br><span class="line">  <span class="attr">--test=TEST</span>           none|build|all|iperf|pingpair|iperfudp|pingall</span><br><span class="line">  -x, --xterms          spawn xterms for each node</span><br><span class="line">  -i IPBASE, <span class="attr">--ipbase=IPBASE</span></span><br><span class="line">                        base IP address for hosts</span><br><span class="line">  --mac                 automatically set host MACs</span><br><span class="line">  --arp                 set all-pairs ARP entries</span><br><span class="line">  -v VERBOSITY, <span class="attr">--verbosity=VERBOSITY</span></span><br><span class="line">                        info|warning|critical|error|debug|output</span><br><span class="line">  --innamespace         sw <span class="literal">and</span> ctrl <span class="keyword">in</span> namespace?</span><br><span class="line">  <span class="attr">--listenport=LISTENPORT</span></span><br><span class="line">                        base port for passive switch listening</span><br><span class="line">  --nolistenport        don't use passive listening port</span><br><span class="line">  <span class="attr">--pre=PRE</span>             CLI script to run before tests</span><br><span class="line">  <span class="attr">--post=POST</span>           CLI script to run after tests</span><br><span class="line">  --pin                 pin hosts to CPU cores (requires --host cfs <span class="literal">or</span> --host</span><br><span class="line">                        rt)</span><br><span class="line">  --nat                 [<span class="attr">option=val...]</span> adds a NAT to the topology that</span><br><span class="line">                        connects Mininet hosts to the physical network.</span><br><span class="line">                        Warning: This may route any traffic on the machine</span><br><span class="line">                        that uses Mininet's IP subnet into the Mininet</span><br><span class="line">                        network. If you need to change Mininet's IP subnet,</span><br><span class="line">                        see the --ipbase option.</span><br><span class="line">  --version             prints the version <span class="literal">and</span> exits</span><br><span class="line">  <span class="attr">--cluster=server1,server2...</span></span><br><span class="line">                        run on multiple servers (experimental!)</span><br><span class="line">  <span class="attr">--placement=block|random</span></span><br><span class="line">                        node placement for --cluster (experimental!)</span><br></pre></td></tr></table></figure><div class="note info">            <ul><li>一个大选项的参数 (param) 和 值 (value)对<strong>用空格分开</strong>，即每一个 <code>--</code> 符号前面应该有一个空格。</li><li>一个大选项后面如果有多个参数值对，每个参数值对间使用<strong>无空格的英文逗号 <code>,</code> 分开</strong>。即：<code>[,param=value...]</code></li></ul>          </div><h4 id="交换机-switchswitch"><a class="markdownIt-Anchor" href="#交换机-switchswitch"></a> 交换机 <code>--switch=SWITCH</code></h4><p><strong>指明建立网络所需交换机类型</strong>。可选参数有：<code>default|ivs|lxbr|ovs|ovsbr|ovsk|user</code>，其中主要使用，同时也是默认使用的是 OVSSwitch。</p><h4 id="主机-hosthost"><a class="markdownIt-Anchor" href="#主机-hosthost"></a> 主机 <code>--host=HOST</code></h4><p><strong>指明建立网络主机类型</strong>。一般不使用。</p><h4 id="控制器-controllercontroller"><a class="markdownIt-Anchor" href="#控制器-controllercontroller"></a> 控制器 <code>--controller=CONTROLLER</code></h4><p><strong>指明建立网络的控制器类型</strong>。 可选参数有：<code>default|none|nox|ovsc|ref|remote|ryu</code>，具体值见上述帮助，简单测试使用 <strong>ref</strong> 控制器即可。</p><p>特别的，如果是使用 <strong>remote</strong> 控制器，<strong>需要同时指明 IP 地址和端口号</strong>。例如，使用 floodlight 控制器时，参数应为：<code>--controller=remote,ip=127.0.0.1,port=6653</code>。</p><h4 id="链路-linklink"><a class="markdownIt-Anchor" href="#链路-linklink"></a> 链路 <code>--link=LINK</code></h4><p><strong>指明链路参数</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mn --link tc,bw=10,delay=10ms</span><br><span class="line"> mininet&gt; iperf</span><br><span class="line"> ...</span><br><span class="line"> mininet&gt; h1 ping -c10 h2</span><br></pre></td></tr></table></figure><p>如果每条链路的时延是 10ms，那么默认拓扑下，h1 和 h2 之间的 RTT 为 40ms。</p><div class="note info">            <p>可以通过 Mininet 的 Python API 自定义每条链路的参数。</p>          </div><h4 id="拓扑-topotopo"><a class="markdownIt-Anchor" href="#拓扑-topotopo"></a> 拓扑 <code>--topo=TOPO</code></h4><p><strong>指明网络拓扑类型</strong>。默认拓扑是<strong>一个交换机连接两个主机</strong>，可以使用 <code>--topo=TOPO</code> 参数更改拓扑类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --<span class="built_in">test</span> pingall --topo single,3  <span class="comment"># 一个交换机连接三台主机</span></span><br><span class="line">$ sudo mn --<span class="built_in">test</span> pingall --topo linear,4  <span class="comment"># 交换机连成一条线，每个交换机连接一台主机。</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>同 链路参数一样，除了默认拓扑，也可以可以通过 Mininet 的 Python API 自定义拓扑。</p>          </div><h4 id="测试-testtest"><a class="markdownIt-Anchor" href="#测试-testtest"></a> 测试 <code>--test=TEST</code></h4><p><strong>测试命令</strong>。执行 test 命令后，会自动停止网络并返回 Linux 系统 shell 环境，这主要是为了不进入 CLI 也可以进行测试。可选参数有：<code>none|build|all|iperf|pingpair|iperfudp|pingall</code>。</p><p>常常使用 <code>pingall</code> 测试网络连接性，使用 <code>iperf</code> 测试网络性能。</p><h4 id="自定义-customcustom"><a class="markdownIt-Anchor" href="#自定义-customcustom"></a> 自定义 <code>--custom=CUSTOM</code></h4><p><strong>自定义可以说是 mininet 最强有力的工具了，用户可以通过 mininet 的 Python API 自定义 Python 脚本，并从中读取类或参数用来自定义网络</strong>。可以自定义的参数包括网络拓扑，交换机，主机，控制器，或者链路参数，也可以自定义系统测试，甚至为 CLI 添加新的命令。</p><blockquote><ul><li>This allows you to use mn to invoke your own custom topology, switch, host, controller, or link classes.</li><li>You can also define and invoke your own <strong>system tests</strong>, and add new Mininet CLI commands.</li></ul></blockquote><p>自定义的方式如下：</p><table><thead><tr><th>option</th><th>dict name</th><th>key: value</th></tr></thead><tbody><tr><td><code>--topo</code></td><td><code>topos</code></td><td>‘short name’: <code>Topo</code> constructor</td></tr><tr><td><code>--switch</code></td><td><code>switches</code></td><td>‘short name’: <code>Switch</code> constructor</td></tr><tr><td><code>--host</code></td><td><code>hosts</code></td><td>‘short name’: <code>Host</code> constructor</td></tr><tr><td><code>--controller</code></td><td><code>controllers</code></td><td>‘short name’: <code>Controller</code> constructor</td></tr><tr><td><code>--link</code></td><td><code>links</code></td><td>‘short name’: <code>Link</code> constructor</td></tr><tr><td><code>--test</code></td><td><code>tests</code></td><td>‘short name’: test function to call with Mininet object</td></tr></tbody></table><p>例如，我们想使用 custom 文件夹中的 <code>topo-2sw-2host.py</code> 自定义拓扑并使用 floodlight 作为控制器，<strong>需要先指明自定义文件的地址，然后使用其中的类或参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --custom custom/topo-2sw-2host.py --topo=mytopo --controller=remote,ip=127.0.0.1,port=6653 --switch ovsk,protocols=OpenFlow13</span><br></pre></td></tr></table></figure><h4 id="自动-mac-mac"><a class="markdownIt-Anchor" href="#自动-mac-mac"></a> 自动 MAC <code>--mac</code></h4><p>默认情况下，hosts 随机分配 MAC 地址，这会增加调试的困难度，毕竟每次创建网络都是不一样的 MAC 地址，因此，可以使用 <code>--mac</code> 参数分配一个小，独一无二，且易读的 ID。例如：默认为 <code>HWaddr f6:9d:5a:7f:41:42</code>，使用 <code>--mac</code> 参数后变为 <code>HWaddr 00:00:00:00:00:01</code>。</p><h4 id="可选的输出-v-verbosity-verbosityverbosity"><a class="markdownIt-Anchor" href="#可选的输出-v-verbosity-verbosityverbosity"></a> 可选的输出 <code>-v VERBOSITY, --verbosity=VERBOSITY</code></h4><p>在进入 mininet 中有一些交互信息会列出，默认的详细度为 <code>info</code>，只会打印出启动和退出网络时 mininet 在做什么事情。可以通过 <code>-v</code> 参数指定交互信息的详细度，有 <code>info|warning|critical|error|debug|output</code> 几种等级可选。</p><p><code>debug</code> 选项会打印大量的信息，而 <code>output</code> 什么都没有。</p><h4 id="命名空间-innamespace-只用于-user-switch"><a class="markdownIt-Anchor" href="#命名空间-innamespace-只用于-user-switch"></a> 命名空间 <code>--innamespace</code> (只用于 user switch)</h4><p>默认情况下：<strong>hosts 有各自独立的命名空间，switches 和 controller 都在 root 命名空间中</strong>。如果要交换机使用独自的命名空间，可以使用 <code>--innamespace</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mn --innamespace --switch user</span><br></pre></td></tr></table></figure><p>虽然这个参数不太实用，但至少提供了一种隔离命名空间的方案。</p><h4 id="清除-c-clean"><a class="markdownIt-Anchor" href="#清除-c-clean"></a> 清除 <code>-c, --clean</code></h4><p>若 Mininet 崩溃，可以通过以下命令清除。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo mn -c <span class="comment"># 或者 sudo mn --clean</span></span><br></pre></td></tr></table></figure><h3 id="mininet-cli-命令-command-line-interface-commands"><a class="markdownIt-Anchor" href="#mininet-cli-命令-command-line-interface-commands"></a> Mininet CLI 命令 (Command-Line Interface Commands)</h3><p>通过上一节的学习，我们可以创建一个网络，甚至利用 mininet 的 Python API，我们可以随心所欲的自定义自己的网络。在这一节，我们继续学习创建网络之后的事情，在创建网络之后，会进入一个称为命令行接口的环境中，mininet 等待用户键入命令…</p><h4 id="cli-环境"><a class="markdownIt-Anchor" href="#cli-环境"></a> CLI 环境</h4><p>使用最小拓扑创建一个网络，并开始 CLI：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo mn</span><br></pre></td></tr></table></figure><p>默认拓扑是 <code>minimum</code> 拓扑，由四个实体组成，包括两个主机进程，一个交换机进程，一个基本控制器。同时，在 Wireshark 中，可以看到交换机连接到了控制器。</p><p>在 CLI 中，有<strong>全局命令和节点命令</strong>之分：</p><ul><li>通过 <code>mininet&gt; command {args}</code> 运行全局命令。</li><li>通过 <code>mininet&gt; &lt;node&gt; command {args}</code> 允许在某个 node 中使用命令，例如 <code>h1 ifconfig -a</code>。</li><li>某些面向字符的交互式命令需要 <code>noecho</code>，例如：<code>mininet&gt; noecho h2 vi foo.py</code>。当然，开启一个新的模拟终端程序是更好的选择，例如：<code>xterm h2</code>。</li></ul><div class="note info">            <p>如果第一个字符串指定了 Mininet <strong>主机</strong>，<strong>交换机</strong>或<strong>控制器</strong>的名字，那么命令将会在那个节点的进程中执行。不仅如此，<strong>任何可用的 Linux 命令或者程序都可以在虚拟主机上运行</strong>，只需要在开头指明主机名即可。</p>          </div> <h4 id="常用全局命令"><a class="markdownIt-Anchor" href="#常用全局命令"></a> 常用全局命令</h4><p>下表列出了常用的全局命令：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>help {command}</code></td><td>显示所有 Mininet CLI 命令或某个命令的用法</td></tr><tr><td><code>quit</code>, <code>exit</code> or <code>EOF(Ctl+D)</code></td><td>退出 Mininet</td></tr><tr><td><code>nodes</code></td><td>显示所有网络节点</td></tr><tr><td><code>net</code></td><td>显示连接</td></tr><tr><td><code>dump</code></td><td>展示所有节点全部信息</td></tr><tr><td><code>py</code></td><td>执行一句 Python 表达式</td></tr><tr><td><code>px</code></td><td>执行一句 Python 语句</td></tr><tr><td><code>link</code></td><td>Link Up/Down</td></tr></tbody></table><h4 id="常用节点命令"><a class="markdownIt-Anchor" href="#常用节点命令"></a> 常用节点命令</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; h1 ifconfig -a</span><br><span class="line">h1-eth0: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span>  broadcast <span class="number">10.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">        inet6 fe80::<span class="number">908</span>c:b0ff:feae:dc45  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">        ...</span><br><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>当我们的主系统执行 <code>ifconfig</code> 命令时，<code>h1-eth0</code> 接口名称不会显示，因为它是 host 进程的网络命名空间特有的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; s1 ifconfig -a</span><br><span class="line">enp4s0: <span class="attribute">flags</span>=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500 <span class="built_in">..</span>.</span><br><span class="line">lo: <span class="attribute">flags</span>=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536 <span class="built_in">..</span>.</span><br><span class="line">ovs-system: <span class="attribute">flags</span>=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500 <span class="built_in">..</span>.  </span><br><span class="line">s1: <span class="attribute">flags</span>=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500 <span class="built_in">..</span>.    </span><br><span class="line">s1-eth1: <span class="attribute">flags</span>=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500 <span class="built_in">..</span>. </span><br><span class="line">s1-eth2: <span class="attribute">flags</span>=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500 <span class="built_in">..</span>.</span><br><span class="line">wlp5s0: <span class="attribute">flags</span>=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500 <span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>然而，switch 默认使用 root 网络命名空间，这将会显示交换机的网络接口加上主系统的网络接口。其他例子也可以证明 host 拥有独立的网络状态，可以在 <code>h1</code> 和 <code>s1</code> 上分别执行 <code>arp</code> 和 <code>route</code> 命令验证。</p><div class="note info">            <ul><li>可以让每个 host，switch，controller 都拥有独立的命名空间。但没必要这么做，除非是搭建多控制器网络。Mininet 不支持此特性，参见 <code>--innamespace</code> 选项。</li><li>只有网络是虚拟的，每个 host 进程其实可以看到所有的进程与目录。例如 <code>h1 ps -a</code> 与在 root 命名空间的 <code>s1 ps -a</code>一样，可以看到全部进程，比如我们在主系统中运行的 chrome 等进程。</li><li>通过 Linux 容器可以实现隔离的进程空间，但 Mininet 没有这么做，因为将所有进程运行在 root 的进程空间中方便调试。</li></ul>          </div><h4 id="测试主机连接"><a class="markdownIt-Anchor" href="#测试主机连接"></a> 测试主机连接</h4><p>为了测试连接性，我们 从 host1 ping host2。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; h1<span class="built_in"> ping </span>-c 1 h2 # 执行<span class="built_in"> ping </span>命令 1 次</span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.0.0.2: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=9.68 ms</span><br><span class="line"></span><br><span class="line">--- 10.0.0.2<span class="built_in"> ping </span>statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 9.689/9.689/9.689/0.000 ms</span><br></pre></td></tr></table></figure><p>执行以上命令，你将会看到 OpenFlow 控制流量：</p><ol><li>主机1请求主机2的 MAC 地址，主机1 向 控制器发送 <code>package_in</code> 数据包。</li><li>控制器发送 <code>package_out</code> 消息已将广播数据包泛洪到交换机其他接口。（这里就只有另一个接口了，即 <code>s1-eth2</code>）</li><li>主机2 看到 ARP 请求，并发送一个回复。</li><li>请求到达控制器，控制器将其发送到主机1 并下发 flow entry</li><li>主机1 知道了主机2 的 MAC 地址，发送 ICMP Echo Request。该请求包括主机2 的回复均到达控制器，并导致 flow entry 下发。</li></ol><p>重复运行上一条 <code>ping</code> 命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; h1<span class="built_in"> ping </span>-c 1 h2</span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 10.0.0.2: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.262 ms</span><br><span class="line"></span><br><span class="line">--- 10.0.0.2<span class="built_in"> ping </span>statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.262/0.262/0.262/0.000 ms</span><br></pre></td></tr></table></figure><p>我们发现，此时 <code>ping</code> 时间远远减小，因为 ICMP 的 flow entry 已经在交换机中存在，因此没有产生控制流量，ICMP 数据包立刻通过了交换机。</p><p>一个简单的方法是使用 Mininet 内置的 <code>pingall</code> 命令，这将会在所有节点上两两逐对运行 <code>ping</code> 命令。</p><h4 id="运行一个简单的-web-服务器和客户端"><a class="markdownIt-Anchor" href="#运行一个简单的-web-服务器和客户端"></a> 运行一个简单的 Web 服务器和客户端</h4><p>这部分比较简单，工作流程中已经展示，不再赘述。</p><h3 id="其他工具和命令"><a class="markdownIt-Anchor" href="#其他工具和命令"></a> 其他工具和命令</h3><h4 id="开启-wireshark"><a class="markdownIt-Anchor" href="#开启-wireshark"></a> 开启 Wireshark</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo wireshark &amp; <span class="comment"># 在后台开启 wireshark，用来查看网络流量。</span></span><br></pre></td></tr></table></figure><p>在 Wireshark 分析中，选择 <code>lo</code> 接口进行分析，便可以看到 OpenFlow 数据包。</p><h3 id="python-api-示例"><a class="markdownIt-Anchor" href="#python-api-示例"></a> Python API 示例</h3><p>在 mininet 的源码 <a href="https://github.com/mininet/mininet/tree/master/examples" target="_blank" rel="noopener">examples directory</a> 中提供了一些没有加入主代码，但却十分有用的 Python 脚本示例，展示了如何使用 Python API。</p><p>更多的 API 教程可以参考 <a href="https://github.com/mininet/mininet/wiki/Introduction-to-Mininet" target="_blank" rel="noopener">Introduction to Mininet</a>。</p><h2 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h2><p>除了上述提到的官方资料，以下几个是比较有参考价值的，其中所有的官方参考资料都可以在 Documentation 中找到。</p><ul><li><a href="https://github.com/mininet/mininet/wiki/Documentation" target="_blank" rel="noopener">Mininet Documentation</a></li><li><a href="http://mininet.org/api/annotated.html" target="_blank" rel="noopener">Mininet Python API Reference Manual</a></li><li><a href="https://github.com/mininet/openflow-tutorial/wiki" target="_blank" rel="noopener">OpenFlow Tutorial</a></li></ul><h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2><ol><li>Q：Mininet 连接控制器造成控制器频繁握手断开。</li></ol><ul><li>A：检查 sw 使用的 OpenFlow 协议版本，最好使用 1.3 版本。</li></ul><h2 id="参考-references"><a class="markdownIt-Anchor" href="#参考-references"></a> 参考 (References)</h2><ul><li><a href="http://sdnhub.org/tutorials/openflow-1-3/" target="_blank" rel="noopener">http://sdnhub.org/tutorials/openflow-1-3/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Networking </category>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
            <tag> Mininet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Archiving and Compression</title>
      <link href="/2018/10/26/linux-data-archiving-and-compression/"/>
      <url>/2018/10/26/linux-data-archiving-and-compression/</url>
      
        <content type="html"><![CDATA[<p>还记不住 tar 的各种选项吗？</p><a id="more"></a><p>Unix 程序设计的其中一条哲学为：一个程序应当只做一件事，并做好它。日常我们经常说的压缩文件其实包含了两个过程：</p><ol><li>建档 (Archiving)：将多个文件<strong>打包</strong>成一个档案/目录(archive file)，或将其<strong>拆包</strong>。例如 <code>tar</code> 。</li><li>压缩 (Compression)：将档案<strong>压缩</strong>成占用空间更小的文件，或将其<strong>解压</strong>。例如 <code>gzip</code>。</li></ol><p>所以，压缩过程实际上是：<strong>首先建立档案文件，然后压缩它</strong>。</p><h2 id="归档工具"><a class="markdownIt-Anchor" href="#归档工具"></a> 归档工具</h2><p>归档工具的作用是：只生成档案文件。归档工具有很多，如 <code>GNU tar</code>，<code>ar</code>等，这里仅仅介绍一下 tar ，因为在日常使用中，基本用它最多。</p><p>tar 的常用命令为：<code>tar cfv archive.tar /etc</code>，但我相信你第一次看肯定记不住，因为这条命令进行了高度简化，原命令可以写成：<code>tar --create --file archive.tar --verbose /etc</code>。它其实包含三个参数，可以按照如下方式记忆：</p><ul><li>c (create)：<strong>创建</strong></li><li>f (file)：<strong>文件</strong>（archive.tar），</li><li>v (verbose)：文件的<strong>详细</strong>内容为（/etc）。</li></ul><p>同理，解包命令 <code>tar xfv archive.tar</code> 也就很容易记忆了，其中 <code>x</code> 代表 e<strong>x</strong>tract 。</p><div class="note info">            <p>注意，上条命令代表将 archive.tar 文件解包到当前目录下，如果要将其解压到特定的目录下，需要加入 <code>-C</code> 参数，其意义为<strong>Change Directory</strong>。完整命令为：<code>tar xfv archive.tar -C /path/to/what/you/want</code>，更详细的用法参阅手册。</p>          </div><h2 id="压缩工具"><a class="markdownIt-Anchor" href="#压缩工具"></a> 压缩工具</h2><p>在 Unix 系统中，常用的三种压缩格式如下：</p><table><thead><tr><th>名称</th><th>拓展名</th><th>与 tar 连用时的拓展名</th></tr></thead><tbody><tr><td><code>bzip2</code></td><td><code>.bz2, .bz</code></td><td><code>.tbz2, .tbz, .tar.bz2</code></td></tr><tr><td><code>gzip</code></td><td><code>.gz, .z</code></td><td><code>.tgz, .taz, .tar.gz</code></td></tr><tr><td><code>xz</code></td><td><code>.xz, .lzma</code></td><td><code>.txz, .tlz, .tar.xz</code></td></tr></tbody></table><p><strong>使用方法也比较统一，默认执行压缩动作，通过 <code>-d</code> 指示解压动作。</strong></p><table><thead><tr><th>名称</th><th>压缩</th><th>解压</th><th>解压到标准输出设备</th></tr></thead><tbody><tr><td><code>bzip2</code></td><td><code>bzip2 file</code></td><td><code>bzip2 -d file.bz2</code></td><td><code>bzcat file.bz2</code></td></tr><tr><td><code>gzip</code></td><td><code>gzip file</code></td><td><code>gzip -d file.gz</code></td><td><code>zcat file.gz</code></td></tr><tr><td><code>xz</code></td><td><code>xz file</code></td><td><code>xz -d file.xz</code></td><td><code>xzcat file.xz</code></td></tr></tbody></table><h2 id="归档压缩工具王者tar"><a class="markdownIt-Anchor" href="#归档压缩工具王者tar"></a> 归档压缩工具王者：tar</h2><p>事实上，说 tar 仅是打包工具是不准确的，因为 tar 命令可以具有<strong>压缩参数</strong>。通过选择压缩选项可以同时完成两个阶段，在实际使用中也是如此。</p><p>tar 难以记忆的点主要有两方面：</p><ul><li>参数风格</li><li>压缩格式对应的参数</li></ul><p>事实上，tar 分为 BSD tar 和 GNU tar 两种，主要区别在于参数前有没有 <code>-</code>：</p><ul><li>BSD 风格<strong>没有</strong> <code>-</code></li><li>GNU 风格有 <code>-</code></li></ul><p>总体来说两种风格都可以使用，GNU 风格更新一点，混用问题也不大。但是有一个点需要特别注意，<strong>如果使用带有 <code>-</code> 的风格，那么最后一个参数必须为 <code>f</code></strong>，这是因为这种风格的代码参数解析时，将 f 后面的参数作为了<strong>文件名</strong>；然而 BSD 风格的参数解析没有这个问题。</p><p>当建立一个压缩包的时候，两者均支持使用 <code>-a</code> 参数来自动创建压缩包 (compressed archive)，并依据其文件扩展名选择对应的压缩程序。另外，tar 针对不同的压缩格式提供了定制的参数，如</p><ul><li>xz 的 <code>-J</code></li><li>gzip 的 <code>-z</code></li><li>bzip2 的 <code>-j</code></li></ul><p>推荐使用 a 参数，代表 auto compress，不仅使用方便，又能<strong>降低命令记忆负担</strong>。</p><p>当解包一个被 bzip2，compress，gzip，lzip，lzma 或 xz压缩过的包的时候，两种 tar 工具均自动进行解压缩，再拆包。所不同的是，BSD tar <strong>基于格式</strong>识别压缩文件的格式，而 GNU tar 仅是<strong>基于文件后缀猜测</strong>压缩文件格式。</p><p>综上所述：笔者个人习惯于选择 BSD 风格，常用例子如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar cvf archive.tar /etc            <span class="comment"># 创建包 archive.tar，其内容为 /etc 目录</span></span><br><span class="line">tar cvf archive.tar a.txt b.c       <span class="comment"># 创建包 archive.tar，其内容为 a.txt b.c </span></span><br><span class="line">tar cavf archive.tar.gz /etc        <span class="comment"># 创建压缩包，需要什么压缩格式就写什么后缀</span></span><br><span class="line">tar xvf archive.tar.gz              <span class="comment"># 解压包 archive 到当前目录（自动选择压缩工具）</span></span><br><span class="line">tar xvf archive.tar.bz2 -C /opt/    <span class="comment"># 解压包 archive 到指定目录（自动选择压缩工具）</span></span><br></pre></td></tr></table></figure><h2 id="其他归档压缩工具"><a class="markdownIt-Anchor" href="#其他归档压缩工具"></a> 其他归档压缩工具</h2><p>虽然 Unix 设计的哲学是简单，但<strong>打包后压缩</strong>或<strong>解压后拆包</strong>应该是对用户无感的，用户只关注结果！如下是日常生活中用到的三种压缩格式对应的工具</p><table><thead><tr><th>名称</th><th>命令</th><th>拓展名</th><th>描述</th></tr></thead><tbody><tr><td><code>7z</code></td><td><code>7z</code></td><td><code>.7z</code></td><td>较为小众，但很易用的工具。</td></tr><tr><td><code>RAR</code></td><td><code>rar</code>, <code>unrar</code></td><td><code>.rar</code></td><td>格式和工具都是专有的。</td></tr><tr><td><code>ZIP</code></td><td><code>zip</code>, <code>unzip</code></td><td><code>.zip</code></td><td>在 Windows 系统上常用。</td></tr></tbody></table><p>常用命令如下，其中 7z 和 rar 都不约而同的使用了 <strong><code>a</code> (add) 指示打包并压缩，<code>x</code> (extract) 指示解压并拆包</strong>，对于 zip 文件则采用了 unzip 来解包，更加方便。</p><table><thead><tr><th>名称</th><th>压缩</th><th>解压</th><th>列出内容</th></tr></thead><tbody><tr><td><code>7z</code></td><td><code>7z a a.7z file1 file2</code></td><td><code>7z x a.7z</code></td><td><code>7z l a.7z</code></td></tr><tr><td><code>rar</code></td><td><code>rar a a.rar file1 file2</code></td><td><code>rar x a.rar</code></td><td><code>rar l a.rar</code></td></tr><tr><td><code>zip, unzip</code></td><td><code>zip a.zip file1 file2</code></td><td><code>unzip a.zip</code></td><td><code>unzip -l a.zip</code></td></tr></tbody></table><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>利用 tar 打包， <code>cfv</code> 分别代表 create file verbose， <code>xfv</code> 的 x 代表 extract(抽取) 。</li><li>使用 tar 打包时候还可以压缩，增加参数 a 并 写明包后缀，如 <code>archive.tar.gz</code>，tar 可以自动依据后缀选择对应压缩程序对所选文件/目录进行压缩打包。</li><li>tar 支持自动解包常用的压缩包格式。如不支持，先解压，再解包。</li><li>有一些工具仅支持压缩，其命令格式大致为：命令 + 文件。默认压缩，使用 <code>-d</code> 参数指示解压。</li><li>有一些工具支持打包并压缩，大部分用 <code>a</code> 指示打包并压缩， 用 <code>x</code> 指示解压并拆包。</li></ul><p>以上均是一些浅显的规律，目的是减少记忆负担。**在拿不准命令如何使用的时候，千万 <code>man</code> 一下。**本文编写时，笔者曾多次查阅 man page 以获取信息和验证。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://wiki.archlinux.org/index.php/Archiving_and_compression" target="_blank" rel="noopener">Archiving and compression, ArchWiki</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Writing Skills</title>
      <link href="/2018/10/25/tool-hexo-writing-skills/"/>
      <url>/2018/10/25/tool-hexo-writing-skills/</url>
      
        <content type="html"><![CDATA[<p>Here are some Hexo writing skills that we can use. For more details, <a href="https://hexo.io/docs/tag-plugins" target="_blank" rel="noopener">click here</a>.</p><a id="more"></a><h2 id="writing"><a class="markdownIt-Anchor" href="#writing"></a> Writing</h2><p>To create a new post or a new page:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>e.g.:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page about <span class="comment"># To create a new about page</span></span><br><span class="line">$ hexo new post hexo-test <span class="comment"># To create a new post</span></span><br><span class="line">$ hexo new draft hexo-advanced <span class="comment"># To create a new draft</span></span><br><span class="line">$ hexo publish post hexo-advanced <span class="comment"># To move drafts to the source/_posts folder</span></span><br></pre></td></tr></table></figure><h2 id="front-matter"><a class="markdownIt-Anchor" href="#front-matter"></a> Front-matter</h2><h3 id="settings"><a class="markdownIt-Anchor" href="#settings"></a> Settings</h3><table><thead><tr><th>Setting</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>layout</td><td>Layout</td><td></td></tr><tr><td>title</td><td>Title</td><td></td></tr><tr><td>date</td><td>Published date</td><td>File created date</td></tr><tr><td>updated</td><td>Updated date</td><td>File updated date</td></tr><tr><td>comments</td><td>Enables comment feature for the post</td><td>true</td></tr><tr><td>tags</td><td>Tags (Not available for pages)</td><td></td></tr><tr><td>categories</td><td>Categories (Not available for pages)</td><td></td></tr><tr><td>permalink</td><td>Overrides the default permalink of the post</td><td></td></tr></tbody></table><h3 id="categories-tags"><a class="markdownIt-Anchor" href="#categories-tags"></a> Categories &amp; Tags</h3><ul><li>Tags are all defined on the same hierarchical level.</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tags:</span></span><br><span class="line">- Injury</span><br><span class="line">- Fight</span><br><span class="line">- Shocking</span><br></pre></td></tr></table></figure><ul><li>Categories apply to posts in order, resulting in a hierarchy of classifications and sub-classifications.</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>Sports</span><br><span class="line"><span class="bullet">- </span>Baseball</span><br></pre></td></tr></table></figure><ul><li>If you want to apply multiple category hierarchies, use a list of names instead of a single name, then each category for that post as its own independent hierarchy.</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>[MLB, American League, New York Yankees]</span><br><span class="line"><span class="bullet">- </span>Rivalries</span><br></pre></td></tr></table></figure><h2 id="tag-plugins"><a class="markdownIt-Anchor" href="#tag-plugins"></a> Tag Plugins</h2><h3 id="block-quote"><a class="markdownIt-Anchor" href="#block-quote"></a> Block Quote</h3><p>This is the extension of <code>&gt;</code>. <strong>Alias: quote</strong></p><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">blockquote</span> [author[, <span class="name">source</span>]] [link] [source_link_title] %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">content</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endblockquote</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h3 id="center-quote"><a class="markdownIt-Anchor" href="#center-quote"></a> Center Quote</h3><p><strong>Alias: cq</strong></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">centerquote</span> %&#125;</span><span class="xml">blah blah blah</span><span class="template-tag">&#123;% <span class="name">endcenterquote</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h3 id="bootstrap-callout-supported-by-theme-next"><a class="markdownIt-Anchor" href="#bootstrap-callout-supported-by-theme-next"></a> Bootstrap Callout (supported by Theme NexT)</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;%<span class="built_in"> note </span>class_name %&#125; </span><br><span class="line">class_name 可以是以下列表中的一个值：</span><br><span class="line">- default</span><br><span class="line">- primary</span><br><span class="line">- success</span><br><span class="line">- info</span><br><span class="line">- warning</span><br><span class="line">- danger</span><br><span class="line">(md partial supported) </span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><h3 id="code-block"><a class="markdownIt-Anchor" href="#code-block"></a> Code Block</h3><p>This is the extension of <code>Backtick Code Block</code>. <strong>Alias: code</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock <span class="string">[title]</span> <span class="string">[lang:language]</span> <span class="string">[url]</span> <span class="string">[link text]</span> %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><h3 id="image"><a class="markdownIt-Anchor" href="#image"></a> Image</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% img [<span class="keyword">class</span> <span class="symbol">names</span>] /<span class="symbol">path</span>/<span class="symbol">to</span>/<span class="symbol">image</span> [<span class="symbol">width</span>] [<span class="symbol">height</span>] [<span class="symbol">title</span> <span class="symbol">text</span> [<span class="symbol">alt</span> <span class="symbol">text</span>]] %&#125;</span><br></pre></td></tr></table></figure><h3 id="link"><a class="markdownIt-Anchor" href="#link"></a> Link</h3><p>Inserts a link with target=&quot;_blank&quot; attribute.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link text url [external] [title] %&#125;</span><br></pre></td></tr></table></figure><h3 id="include-code"><a class="markdownIt-Anchor" href="#include-code"></a> Include Code</h3><p>Inserts code snippets in <code>source/downloads/code</code> folder.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include_code [title] [<span class="keyword">lan</span><span class="variable">g:language</span>] path/<span class="keyword">to</span>/<span class="keyword">file</span> %&#125;</span><br></pre></td></tr></table></figure><h3 id="raw"><a class="markdownIt-Anchor" href="#raw"></a> Raw</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;%<span class="built_in"> raw </span>%&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h3 id="post-excerpt"><a class="markdownIt-Anchor" href="#post-excerpt"></a> Post Excerpt</h3><p>Use text placed before the <!-- more --> tag as an excerpt for the post.</p><h3 id="picture-group"><a class="markdownIt-Anchor" href="#picture-group"></a> Picture group</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">gp</span> 2-2 %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">![](xxx.png)</span></span><br><span class="line"><span class="xml">![](xxx.svg)</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endgp</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h3 id="tabs"><a class="markdownIt-Anchor" href="#tabs"></a> Tabs</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">tabs</span> Fourth unique name %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab Solution 1 --&gt;</span></span></span><br><span class="line"><span class="xml">**This is Tab 1.**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab Solution 2 --&gt;</span></span></span><br><span class="line"><span class="xml">**This is Tab 2.**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab Solution 3 --&gt;</span></span></span><br><span class="line"><span class="xml">**This is Tab 3.**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endtabs</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404</title>
      <link href="/404/index.html"/>
      <url>/404/index.html</url>
      
        <content type="html"><![CDATA[<script src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" charset="utf-8" homepageurl="/" homepagename="Back to home"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>About</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>I’m a master candidate in Institute of Smart Wireless Mobile Information Technology, Beijing University of Posts and Telecommunications, China.</p><p>Feel free to contact me anytime for anything.</p><ul><li><a href="mailto:liyanjiu1996@gmail.com" target="_blank" rel="noopener">liyanjiu1996@gmail.com</a> (Making friends with me)</li><li><a href="mailto:liyanjiu@outlook.com" target="_blank" rel="noopener">liyanjiu@outlook.com</a> (Making friends with me)</li><li><a href="mailto:liyanjiu@bupt.edu.cn" target="_blank" rel="noopener">liyanjiu@bupt.edu.cn</a> (Job)</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Notes</title>
      <link href="/notes/index.html"/>
      <url>/notes/index.html</url>
      
        <content type="html"><![CDATA[<p>本版为<strong>技术笔记</strong>，目的是结构化自身计算机知识架构，不定期更新…</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>The hitchhiker is there so you can do your good deed for the day.<br>– Hitchhiking with a bike, by Max Neumegen</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>hitchhiker 意思是搭便车的旅行者，Max Neumegen 说“想搭顺风车的人在那里等着，刚好让你日行一善”，如果笔者在学习路上能顺便帮助一些志同道合的“旅客”，也算做了一件好事，毕竟，大多数情况下，美好并非存在于目的地而是旅程中。</p><p>所有内容均采用 <strong><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">署名-非商业使用-相同方式共享 4.0 国际许可 (Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0))</a></strong>，如果文章对您有帮助，希望您可以留言表示感谢；如果经济条件允许，也可以在文章末扫描二维码捐助笔者，毕竟根据经济学原理，好的东西应该受到报酬才更加利于社会发展。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Database</title>
      <link href="/notes/database/index.html"/>
      <url>/notes/database/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库概念"><a class="markdownIt-Anchor" href="#数据库概念"></a> 数据库概念</h1><h1 id="关系型数据库"><a class="markdownIt-Anchor" href="#关系型数据库"></a> 关系型数据库</h1><ul><li><a href>SQL</a></li><li><a href>MySQL</a></li></ul><h1 id="非关系型数据库"><a class="markdownIt-Anchor" href="#非关系型数据库"></a> 非关系型数据库</h1><ul><li><a href>Redis</a></li><li><a href>MongoDB</a></li></ul><h2 id="mongodb"><a class="markdownIt-Anchor" href="#mongodb"></a> MongoDB</h2><h1 id="draft-below-"><a class="markdownIt-Anchor" href="#draft-below-"></a> —draft below-------</h1><h1 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><img src="transaction.png" alt="transaction"></p><h2 id="acid"><a class="markdownIt-Anchor" href="#acid"></a> ACID</h2><h3 id="原子性atomicity"><a class="markdownIt-Anchor" href="#原子性atomicity"></a> 原子性（Atomicity）</h3><p>事务被视为<strong>不可分割的最小单元</strong>，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用**回滚日志（Undo Log）**来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3 id="隔离性isolation"><a class="markdownIt-Anchor" href="#隔离性isolation"></a> 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="持久性durability"><a class="markdownIt-Anchor" href="#持久性durability"></a> 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>系统发生奔溃可以用**重做日志（Redo Log）**进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><h3 id="一致性consistency"><a class="markdownIt-Anchor" href="#一致性consistency"></a> 一致性（Consistency）</h3><p>一致性是指系统从一个正确的状态,迁移到另一个正确的状态，正确的状态就是当前的状态满足预定的约束，只有满足一致性，事务的执行结果才是正确的，即 <strong>C 是目的，AID 是手段</strong>。因此可以得出以下的关系结论：</p><ul><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><h2 id="自动提交"><a class="markdownIt-Anchor" href="#自动提交"></a> 自动提交</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p><h1 id="并发一致性问题"><a class="markdownIt-Anchor" href="#并发一致性问题"></a> 并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><ul><li>丢失修改</li><li>读脏数据</li><li>不可重复读</li><li>幻影读</li></ul><p>产生并发不一致性问题的主要原因是<strong>破坏了事务的隔离性</strong>，解决方法是通过并发控制来保证隔离性。并发控制可以通过<strong>封锁</strong>来实现，但是封锁操作需要用户自己控制，相当复杂。<strong>数据库管理系统提供了事务的隔离级别</strong>，让用户以一种更轻松的方式处理并发一致性问题。</p><h1 id="封锁"><a class="markdownIt-Anchor" href="#封锁"></a> 封锁</h1><h2 id="锁粒度"><a class="markdownIt-Anchor" href="#锁粒度"></a> 锁粒度</h2><p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。因此<strong>锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高</strong>。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此<strong>封锁粒度越小，系统开销就越大</strong>。在选择封锁粒度时，需要在<strong>锁开销</strong>和<strong>并发程度</strong>之间做一个权衡。</p><h2 id="锁类型"><a class="markdownIt-Anchor" href="#锁类型"></a> 锁类型</h2><h1 id="杂"><a class="markdownIt-Anchor" href="#杂"></a> 杂</h1><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h2><p>关系型 。。。</p><h2 id="主流数据库"><a class="markdownIt-Anchor" href="#主流数据库"></a> 主流数据库</h2><p>关系型：<br>非</p><h2 id="sql"><a class="markdownIt-Anchor" href="#sql"></a> SQL</h2><h2 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h2><h3 id="主键"><a class="markdownIt-Anchor" href="#主键"></a> 主键</h3><p>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。</p><p>最好用 id：自增整数类型 或 GUID BIGINT NOT NULL AUTO_INCREMENT</p><p>联合主键 ：并不常用</p><h3 id="外键"><a class="markdownIt-Anchor" href="#外键"></a> 外键</h3><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><p>ALTER TABLE students<br>ADD CONSTRAINT fk_class_id<br>FOREIGN KEY (class_id)<br>REFERENCES classes (id);</p><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。</p><ul><li>一对多：</li><li>多对多：通过两个一对多实现</li><li>一对一：<br>有细心的童鞋会问，既然是一对一关系，那为啥不给students表增加一个mobile列，这样就能合二为一了？</li></ul><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，contacts表就不存在对应的记录。实际上，一对一关系准确地说，是contacts表一对一对应students表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。</p><p>小结：关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><h3 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h3><h2 id="sql-查询"><a class="markdownIt-Anchor" href="#sql-查询"></a> SQL 查询</h2><ul><li>基本查询：<code>SELECT * FROM &lt;表名&gt;</code> / 也可以只有 SELECT</li><li>条件查询：<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</code> / 上述NOT条件NOT class_id = 2其实等价于class_id &lt;&gt; 2，因此，NOT查询不是很常用。</li><li>投影查询：<code>SELECT 列1, 列2, 列3 FROM ...</code> / 起别名</li><li>结果排序：<code>... ORDER BY &lt;排序表达式&gt;</code></li><li>结果分页：<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code> / LIMIT 表示最多，如果不够，没事；OFFSET 表示偏移，也就是起点，注意，从零开始编号。OFFSET超了也没事，结果为空。；OFFSET 可以不写，默认从0开始，但不写 LIMIT 不行；LIMIT M OFFSET N 可以在 MySQL 里简写为 LIMIT N M，注意先表示偏移点，再表示个数</li><li>聚合查询：使用函数 <code>COUNT</code> <code>AVG</code> 等</li><li>分组：<code>GROUP BY</code><br>SELECT class_id, gender, AVG(score) points FROM students<br>GROUP BY class_id, gender<br>ORDER BY class_id, gender, points DESC;</li></ul><h3 id="ff"><a class="markdownIt-Anchor" href="#ff"></a> ff</h3><p>通过对数据库表创建索引，可以提高查询速度。</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p><p>数据库索引对于用户和应用程序来说都是透明的。</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><a href="https://en.wikipedia.org/wiki/Database" target="_blank" rel="noopener">Database, wikipedia</a></li><li><a href="https://www.liaoxuefeng.com/wiki/001508284671805d39d23243d884b8b99f440bfae87b0f4000" target="_blank" rel="noopener">SQL 教程，廖雪峰</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/notes/algorithm/index.html"/>
      <url>/notes/algorithm/index.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Algorithms + Data Structures = Programs<br>– Niklaus Wirth</p><p>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.<br>– Torvalds Linus</p>            <i class="fa fa-quote-right"></i>          </blockquote><h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1><h2 id="数据类型-data-type"><a class="markdownIt-Anchor" href="#数据类型-data-type"></a> 数据类型 (Data Type)</h2><p><a href="https://en.wikipedia.org/wiki/Data_type" target="_blank" rel="noopener">数据类型</a>可以分为以下几种。</p><h3 id="原始数据类型-primitive-data-type"><a class="markdownIt-Anchor" href="#原始数据类型-primitive-data-type"></a> 原始数据类型 (Primitive Data Type)</h3><p>编程语言提供若干<a href="https://en.wikipedia.org/wiki/Primitive_data_type" target="_blank" rel="noopener">原始数据类型</a>，以作为程序以及专用化复合类型的创建基础。典型的原始数据类型包含各种<strong>整数</strong>、<strong>浮点数</strong>以及<strong>布尔类型</strong>。</p><div class="note info">            <p>有些高级语言将 String 字符串视为内建数据类型 (Built-in type)，这是因为字符串使用的过于广泛，但字符串不属于原始数据类型。</p>          </div><h3 id="复合数据类型-composite-types"><a class="markdownIt-Anchor" href="#复合数据类型-composite-types"></a> 复合数据类型 (Composite Types)</h3><p>复合数据类型通常由原始数据类型以一定的方式组织而成，从而提供更便利的表达方式。每种编程语言提供的复合数据类型不尽相同，通常包括：</p><ul><li>Array：数组（广泛提供）</li><li>String：字符串（广泛提供）</li><li>Struct：结构体（例如 C）</li><li>Union：联合体（例如 C）</li><li>Object：对象（面向对象语言）</li><li>Enumerate：枚举体（广泛提供）</li></ul><h3 id="其他类型-other-types"><a class="markdownIt-Anchor" href="#其他类型-other-types"></a> 其他类型 (Other Types)</h3><p>除此之外，还有几种特别重要的类型，几乎在任何编程语言都有实现。</p><ul><li>Pointer：指针类型</li><li>Reference：引用类型</li><li>Function：函数类型</li></ul><h2 id="抽象数据类型-abstract-data-type"><a class="markdownIt-Anchor" href="#抽象数据类型-abstract-data-type"></a> 抽象数据类型 (Abstract Data Type)</h2><p>抽象数据类型 (Abstract Data Type, ADT) 是计算机科学中具有类似行为的特定类别的数据结构的数学模型，简单的理解就是一种对于数据结构的抽象表示，因此也被称为抽象数据结构，其理论性较强，对于程序员而言，<strong>ADT 可以看作是一种接口与实现分离</strong>的表示，ADT 定义了某一类数据类型应该具有的特性和方法，却不关心其具体的实现，有助于程序员从宏观的角度来思考数据结构的组织。</p><p>从形式上讲，ADT 可以定义为“<strong>一类对象，其逻辑行为由一组值和一组操作定义</strong>”，这可以方便的通过支持类 (Class) 的编程语言实现。某些抽象数据类型在程序设计中相当普遍且实用，因此常常出现在编程语言的原生类型或标准库中。更多的信息可以查看 <a class="btn" href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>Abstract data type          </a>。</p><table><thead><tr><th>名称</th><th>特征</th><th>实现</th></tr></thead><tbody><tr><td>List</td><td>列表的元素顺序排列</td><td>动态数组、链表</td></tr><tr><td>Set</td><td>集合包含不重复的元素</td><td>哈希表、树</td></tr><tr><td>Multiset</td><td>包含重复的元素的集合</td><td></td></tr><tr><td>Map</td><td>由键唯一的键值对组成的集合</td><td>哈希表、树、链表</td></tr><tr><td>Multimap</td><td>由键不唯一的键值对组成的集合</td><td></td></tr><tr><td>Graph</td><td>若干节点和链接组成的无规则图</td><td>邻接矩阵、链表的链表</td></tr><tr><td>Tree</td><td>若干节点和链接组成的层次结构</td><td>树</td></tr><tr><td>Stack</td><td>栈中元素先入后出</td><td>动态数组、链表</td></tr><tr><td>Queue</td><td>队列中元素先进先出</td><td>动态数组、链表</td></tr><tr><td>Priority queue</td><td>优先队列中元素有优先级区别</td><td>堆</td></tr><tr><td>Double-ended queue</td><td>两端都可以进出的队列</td><td>动态数组、双链表</td></tr><tr><td>Double-ended priority queue</td><td>两端都可以进出的优先队列</td><td>双端堆</td></tr></tbody></table><p>我们可以看到，虽然抽象数据类型定义了一些接口的特征，但其后支撑的数据结构（实现部分）更加重要，其中主要包括：</p><ul><li>动态数组</li><li><strong>链表</strong></li><li><strong>树</strong></li><li><strong>哈希表</strong></li></ul><p>而其中最复杂多变的就是树。</p><h2 id="数据结构-data-structure"><a class="markdownIt-Anchor" href="#数据结构-data-structure"></a> 数据结构 (Data Structure)</h2><p>数据结构 (Data Structure) 是抽象数据类型 (ADT) 的基础。抽象数据类型<strong>定义</strong>了数据类型的<strong>逻辑形式</strong>，而数据结构<strong>实现</strong>了数据类型的<strong>物理形式</strong>。</p><p>不同的数据结构适用于不同的应用，其中有一些是针对特殊任务而高度定制的。合理的数据结构不仅可以提高数据组织和使用的效率，还是设计高效算法的基础。</p><p><strong>数据结构的实现基于计算机可以在内存中存取数据</strong>这一事实，计算机使用指针 (pointer) 来表示内存中的地址，而这个指针本身作为一个位字符串，也可以存储在内存中从而被程序使用。因此，数据结构可以被简单的分为两类：</p><ul><li>数组 (array) 和 记录/结构体 (record, struct, structure) 这种数据结构<strong>基于计算数据项的地址</strong>，该类数据结构存储数据本身。</li><li>链接数据结构<strong>基于存储数据项的地址</strong>，该类数据结构不存储数据本身，而存储数据项的地址。</li></ul><blockquote><p>Thus, the array and record data structures are based on computing the addresses of data items with arithmetic operations, while the linked data structures are based on storing addresses of data items within the structure itself.</p></blockquote><p>数据结构的实现需要编写用于创建和管理该结构实例的方法，而一个数据结构的效率间接地被这些方法的性能而决定，这性能包括时间复杂度和空间复杂度。</p><p>以下是常用数据结构的列表 <a class="btn" href="https://en.wikipedia.org/wiki/List_of_data_structures" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>List of data structures          </a></p><p>其中比较重要的将在其他博文详述：</p><ul><li><a href="/2020/01/21/algo-tree/">Trees</a></li><li><a href="/2020/02/17/algo-hash-table/">Hash table</a></li></ul><h1 id="算法分析-analysis"><a class="markdownIt-Anchor" href="#算法分析-analysis"></a> 算法分析 (Analysis)</h1><p>我们首先给出算法分析的一些基本概念，其次明确算法分析的符号表示，最后掌握一般算法分析的方式。</p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><h3 id="关心对象"><a class="markdownIt-Anchor" href="#关心对象"></a> 关心对象</h3><p>算法分析的结果意味着<strong>预测算法需要的资源</strong>。涉及到的资源有内存，通信带宽或计算机硬件，但是<strong>通常最关心计算时间</strong>。</p><h3 id="技术模型"><a class="markdownIt-Anchor" href="#技术模型"></a> 技术模型</h3><p>我们假定使用 RAM 模型，在 RAM 模型中，<strong>程序一条条执行</strong>，没有并发操作。同时，不试图对当代计算机中常见的内存层次建模，也就是说，<strong>不考虑高速缓存和虚拟内存</strong>，但对于真实计算机运行的程序，这种影响有时是巨大的。对于这种问题，需要特殊考虑。</p><h3 id="输入规模与运行时间"><a class="markdownIt-Anchor" href="#输入规模与运行时间"></a> 输入规模与运行时间</h3><p>一般来说，算法的运行时间与输入规模同时增长。可以将“运行时间”看作是“输入规模”的一个函数。</p><p><strong>输入规模的概念依赖于具体的研究问题</strong>。但感性上来说，输入规模度量是比较好找到的。例如在排序算法中，输入规模是待排序数组的项数，在一个输入为图的算法中，输入规模可以是图的顶点数和边数。</p><p><strong>一个算法在特定输入规模上的运行时间是指执行基本操作数或步数</strong>。也就是说，我们认为执行一句 for 语句与执行一句 while 语句是相当的，只是两者语句代价不同，但也仍然只是不同的常数而已，在绝大多数情况下，我们不必考虑其中差别。</p><p>对于给定规模的输入n，我们可以将运行时间表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，即 n 的函数，其可能是 n 的对数函数、线性函数、二次函数等。</p><h3 id="情况分析"><a class="markdownIt-Anchor" href="#情况分析"></a> 情况分析</h3><ul><li>最坏情况运行时间：对规模为 n 的任何输入，算法的最长运行时间。</li><li>最好情况运行时间：对规模为 n 的某个或某些输入，算法的最短运行时间。</li><li>平均情况运行时间：对规模为 n 的所有输入，算法的平均运行时间。</li></ul><p>但是通常我们仅会关注<strong>最坏情况运行时间</strong>，理由如下：</p><ul><li>一个算法的最坏情况运行时间，给出了任何输入的运行时间的一个上界。这样就可以确保，该算法绝不需要更长时间。</li><li>对于某些算法，最坏情况经常出现。比如对缺失信息的检索。</li><li>平均情况大致与最坏情况一样差。</li></ul><p>在某些时候，我们会关注平均情况，这涉及到一些概率分析。</p><h3 id="渐进效率"><a class="markdownIt-Anchor" href="#渐进效率"></a> 渐进效率</h3><p>一个算法的运行时间中最重要的的项决定了我们真正感兴趣的<strong>增长量级</strong>。而不重要的低阶项（或者说极限情况下的高阶无穷小项）往往被忽略。当输入规模足够大时，我们要研究算法的<strong>渐进效率</strong>。即：极限中，算法的运行时间如何随输入规模的变大而增加。</p><p>但是，在实际使用中，需要结合实际规模考虑算法的可用性。渐进效率不是唯一的考虑因素，需要结合具体问题具体分析。例如,在 [0, 100] 范围内 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">T(n) = n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>10000</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n) = 10000n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">n</span></span></span></span> 具有更好的性能，然而前者的渐进效率很低。</p><h2 id="渐进符号表示"><a class="markdownIt-Anchor" href="#渐进符号表示"></a> 渐进符号表示</h2><p>这部分涉及一些数学知识，不再详述，可阅读 wiki 相关词条内容。</p><ul><li>big Theta：给出渐进紧确界。</li><li>big Order：给出渐进上界，但通常给出一个紧缺的上界。</li><li>big Omega：给出渐进下界。</li><li>small order：表示一个非渐进紧确的上界。</li><li>small omega：表示一个非渐进紧确的下界。</li></ul><h2 id="算法分析"><a class="markdownIt-Anchor" href="#算法分析"></a> 算法分析</h2><p>算法分析主要取决于该算法使用的<strong>设计准则 (Design Paradigms)</strong>。依据不同的准则设计出来的算法分析思路往往不同，但根据相同的准则设计出来的算法分析思路往往相同。例如，求单向图最短简单路径的算法与归并排序算法的分析思路不相同，因为前者依据动态规划设计，后者依据分治法设计。又如归并排序和求解最大子数组算法看起来很不相关，但是两者分析思路一致，因为均是基于分治法设计。</p><p>基于以上思路，我们得到如下启示：</p><ol><li>明确算法分析的基本原理和表示方法。</li><li>掌握算法设计准则，从宏观学习算法分析思路。也就是掌握某一类问题。</li><li>在算法设计准则掌握熟练的情况下。主要思考内容就是<strong>如何把某个问题抽象成某一类问题</strong>和<strong>某一个问题中的特殊的地方</strong>。</li></ol><h1 id="算法设计准则-design-paradigms"><a class="markdownIt-Anchor" href="#算法设计准则-design-paradigms"></a> 算法设计准则 (Design Paradigms)</h1><ul><li>Iteration | 迭代</li><li>Recursion | 递归</li><li>Recurrence | 递推</li><li>Randomization | 随机化</li><li>Brute Force | 穷举法</li><li>Back Tracking  | 回溯法</li><li>Divide and Conquer | 分治法</li><li>Dynamic Programming | 动态规划</li><li>Greedy Algorithm | 贪心算法</li></ul><h1 id="排序-sorting"><a class="markdownIt-Anchor" href="#排序-sorting"></a> 排序 (Sorting)</h1><p>排序是一个非常常见的应用，通常我们需要对各种数据类型进行排序，甚至包括自定义数据类型。但最终基本可以归结为三种：</p><ul><li>通用排序算法</li><li>数字排序算法</li><li>字符串排序算法</li></ul><p>详情请见 <a class="btn" href="/2020/03/17/algo-sort/">            <i class="fa fa-book fa-fw fa-lg"></i>Sorting          </a></p><h1 id="搜索-searching"><a class="markdownIt-Anchor" href="#搜索-searching"></a> 搜索 (Searching)</h1><p>搜索可能时最常用的场景了，与排序不同，毕竟搜索的结果只有两种：找到或未找到。因此搜索算法与待搜索的数据类型关系不大，只要是能比较的对象即可，搜索主要和数据组织的方式有关。感受一下以下的场景：</p><ul><li>在一个数组里搜索一个数字、一个字符串；</li><li>在一个链表里搜索一个数字、一个字符串；</li><li>在一个字符串里搜索一个字符；</li><li>在一个树中搜索一个节点；</li><li>在一个哈希表中搜索一个键对应的值；</li><li>在一个图中搜索一个值；</li><li>在一个文件中搜索感兴趣的字符串；</li><li>在一个文件系统中搜索感兴趣的文件；</li><li>在互联网上搜索你感兴趣的某个文本；</li><li>在互联网上搜索你感兴趣的某些图片；</li></ul><p>当然，后几种场景已经远远超出了数据结构和算法的范围，不过我们仍然可以感受到，<strong>搜索对应于字典/符号表这一 ADT</strong>，任何数据结构，<code>value = dict.get(key)</code> 都是最重要的 API 应用，毕竟我们关心的东西才是有价值的东西。</p><p>以下是一些搜索的算法：</p><ul><li><a href="/2019/11/12/algo-binary-search/">二分搜索 Binary Search</a></li></ul><!-- ------------------------------------------------------------# 符号表 (Symbol Table)符号表 (symbol table, map, associative array or dictionary) 是一种由键值对 (key-value pairs) 的集合构成的抽象数据类型。符号表又称之为映射表、关联数组或者字典，其支持的操作如下：- 向表中增加键值对- 从表中删除键值对- 在表中根据键查询其关联的值因此，在符号表的实现中，我们关心的通常是**增、删、查**的性能，其中“改”操作可以视为“增”操作的一种，即插入一个键已存在但值不同的键值对视为表的更改。## API ## 实现 (Implementations)### 链表- get() 的实现为遍历链表- put() 的实现也为遍历链表### 总结 (Comparison)Underlying data structure|---|---|---|---Unordered linked list (sequential search)|$$Ordered arrays (binary search)|BST|RedBlackBST|Hash table|# Dynamic Programming (DP)- careful brute force- subproblems + reuseexample 1：- fibonacci     - naive    - naive + memorization- shortest path- text justification- black jack# Priority Queue优先队列 (Priority Queue) 支持两种操作：- 删除最大元素- 插入元素## API## 初级实现可以使用**有序或者无序的数组或链表**来实现优先队列。### 数组实现最简单的一种方法是修改栈的实现以支持优先队列的特性。其中，insert() 方法和 push() 方法完全相同；要实现 delMax() 方法，可以**添加一段选择排序的内循环代码，将最大元素和边界元素交换然后删除它**，就和栈的 pop() 方法实现一致。和栈相同，可以加入动态调整数组大小的方法，使得数据结构中具有适合容量的元素而又不会溢出。另一种方法就是在 insert() 方法中添加代码，**将所有较大的元素向右边移动一格，以使得数组保持有序，就和插入排序一样**，这样最大的元素总会在数组的一边，delMax() 的操作就和栈的 pop() 操作一致。### 链表表示和上文类似，可以用基于链表的栈作为基础，来支持优先队列的实现。而后只需要选择修改 pop() 来找到并返回最大元素，或者修改 push() 来保证所有元素为逆序并用 pop() 来删除并返回列表的首元素（最大的元素）。### 分析使用无序序列是解决这个问题的惰性方法，仅在返回最大元素的时候才采取行动；使用有序序列则是解决问题的积极方法，会在插入元素时候就保持列表有序，使得后续操作更加高效。无论采用何种方式，插入元素和删除最大元素这两个操作之一在最坏情况下时间复杂度都是线性的，而接下来的基于数据结构**堆的实现能够保证两种操作都可以更快的执行**。数据结构|插入元素|删除最大元素:---|:---:|:---:无序数组|$1$|$n$|有序数组|$n$|$1$|堆|$\log n$|$\log n$|## 堆实现### 堆的定义二叉堆能够很好的实现优先队列的基本操作。## 堆排序1. 从无序数组中构造最大堆2. 找到最大的元素 `A[1]`3. 交换 `A[1]` 和 `A[n]` (最大的元素位于数组最后)4. discard node n from heap5. New root may violate max heap but children are max heaps. (Go to step 2)# 字符串## 单词查找树 (Trie)### R 向单词查找树### 三向单词查找树二叉查找树与快速排序单词查找树与高位优先字符串排序三向单词查找树与三向字符串快速排序## 子字符串查找应用场景：- 文本编辑器和浏览器查找单词 --><h1 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h1><ul><li><a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">Algorithms 4th Edition</a> | <a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法 (第四版)</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Cloud Computing</title>
      <link href="/notes/cloud/index.html"/>
      <url>/notes/cloud/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟化"><a class="markdownIt-Anchor" href="#虚拟化"></a> 虚拟化</h1><h2 id="硬件虚拟化-hypervisors"><a class="markdownIt-Anchor" href="#硬件虚拟化-hypervisors"></a> 硬件虚拟化 (Hypervisors)</h2><p>硬件虚拟化 (Hardware Virtualization or Hypervisors) 可以按照虚拟化的程度不同分为两种类型。</p><ul><li>type-1 hypervisor</li><li>type-2 hypervisor</li></ul><table><thead><tr><th>类型</th><th>实现</th></tr></thead><tbody><tr><td>Type-2 or hosted hypervisors</td><td>Xen, VMware ESXi (formerly ESX)</td></tr><tr><td>Type-1, native or bare-metal hypervisors</td><td>Parallels Desktop for Mac, QEMU, VirtualBox, VMware Player and VMware Workstation</td></tr></tbody></table><p>这两种类型之间的区别并不总是很清楚。例如，Linux 的基于内核的虚拟机（KVM）和 FreeBSD 的 bhyve 是内核模块，可以有效地将主机操作系统转换为 type-1 hypervisor。同时，由于 Linux 发行版和 FreeBSD 仍然是通用操作系统，并且应用程序在争夺 VM 资源方面相互竞争，因此 KVM 和 bhyve 也可以归为 type-2 hypervisor。</p><p>来源：<a href="https://en.wikipedia.org/wiki/Hypervisor" target="_blank" rel="noopener">Hypervisor/Virtual Machine Monitor (VMM)</a></p><h3 id="kvm"><a class="markdownIt-Anchor" href="#kvm"></a> KVM</h3><p>KVM 全称是 Kernel-Based Virtual Machine。也就是说 KVM 是基于 Linux 内核实现的。KVM有一个内核模块叫 kvm.ko，只用于管理虚拟 CPU 和内存。</p><p>那 IO 的虚拟化，比如存储和网络设备由谁实现呢？这个就交给 Linux 内核和 Qemu 来实现。说白了，作为一个 Hypervisor，KVM 本身只关注虚拟机调度和内存管理这两个方面。IO 外设的任务交给 Linux 内核和 Qemu。</p><p>Libvirt<br>大家在网上看 KVM 相关文章的时候肯定经常会看到 Libvirt 这个东西。Libvirt 是啥？简单说就是 KVM 的管理工具。</p><p>其实，Libvirt 除了能管理 KVM 这种 Hypervisor，还能管理 Xen，VirtualBox 等。OpenStack 底层也使用 Libvirt，所以很有必要学习一下。</p><p>Libvirt 包含 3 个东西：</p><ul><li>后台 daemon 程序 libvirtd、</li><li>API 库</li><li>命令行工具 virsh</li></ul><p>libvirtd 是服务程序，接收和处理 API 请求；</p><p>API 库使得其他人可以开发基于 Libvirt 的高级工具，比如 virt-manager，这是个图形化的 KVM 管理工具，后面我们也会介绍；</p><p>virsh 是我们经常要用的 KVM 命令行工具，后面会有使用的示例。</p><p>作为 KVM 和 OpenStack 的实施人员，virsh 和 virt-manager 是一定要会用的。</p><p>KVM 虚拟化实现</p><ul><li>CPU 虚拟化：一个 KVM 虚机在宿主机中其实是一个 qemu-kvm 进程，与其他 Linux 进程一样被调度。虚机中的每一个虚拟 vCPU 则对应 qemu-kvm 进程中的一个线程</li><li>内存虚拟化：VA – PA – MA</li><li>存储虚拟化：KVM 的存储虚拟化是通过存储池（Storage Pool）和卷（Volume）来管理的。<ul><li>目录型 SP：Volume 是目录中的一个文件</li><li>LVM 型 SP</li><li>KVM 还支持 iSCSI，Ceph 等多种类型的 Storage Pool</li></ul></li><li>网络虚拟化</li></ul><h2 id="操作系统虚拟化-os-level-virtualization"><a class="markdownIt-Anchor" href="#操作系统虚拟化-os-level-virtualization"></a> 操作系统虚拟化 (OS-level Virtualization)</h2><blockquote><p>OS-level virtualization refers to an operating system paradigm in which the kernel allows the existence of multiple isolated user space instances. Such instances, called containers (Solaris, Docker), Zones (Solaris), virtual private servers (OpenVZ), partitions, virtual environments (VEs), virtual kernels (DragonFly BSD), or jails (FreeBSD jail or chroot jail), may look like real computers from the point of view of programs running in them.</p></blockquote><h2 id="container"><a class="markdownIt-Anchor" href="#container"></a> Container</h2><h3 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h3><ul><li><a href="/2019/07/05/pro-docker/">Docker</a></li></ul><h2 id="kubernetes"><a class="markdownIt-Anchor" href="#kubernetes"></a> Kubernetes</h2><h3 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h3><p>Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。</p><h2 id="network-virtualization"><a class="markdownIt-Anchor" href="#network-virtualization"></a> Network Virtualization</h2><h3 id="nfv"><a class="markdownIt-Anchor" href="#nfv"></a> NFV</h3><h4 id="nfv-concepts"><a class="markdownIt-Anchor" href="#nfv-concepts"></a> NFV Concepts</h4><table><thead><tr><th>Terminology</th><th>Explanation</th></tr></thead><tbody><tr><td>Network Function (NF)</td><td>Functional building block with a well defined interfaces and well defined functional behavior</td></tr><tr><td>Virtualized Network Function (VNF)</td><td>Software implementation of NF that can be deployed in a virtualized infrastructure</td></tr><tr><td>VNF Set</td><td>Connectivity between VNFs is not specified, e.g., residential gateways</td></tr><tr><td>VNF Forwarding Graph</td><td>Service chain when network connectivity order is important, e.g., firewall, NAT, load balancer</td></tr><tr><td>NFV Infrastructure (NFVI)</td><td>Hardware and software required to deploy, mange and execute VNFs including computation, networking, and storage.</td></tr><tr><td>NFV Orchestrator</td><td>Automates the deployment, operation, management, coordination of VNFs and NFV</td></tr><tr><td>NFVI Point of Presence (PoP)</td><td>Location of NFVI</td></tr><tr><td>NFVI-PoP Network</td><td>Internal network</td></tr><tr><td>Transport Network</td><td>Network connecting a PoP to other PoPs or external networks</td></tr><tr><td>VNF Manager</td><td>VNF lifecycle management e.g., instantiation, update, scaling, query, monitoring, fault diagnosis, healing, termination</td></tr><tr><td>Virtualized Infrastructure Manager</td><td>Management of computing, storage, network, software resources</td></tr><tr><td>Network Service</td><td>A composition of network functions and defined by its functional and behavioral specification</td></tr><tr><td>NFV Service</td><td>A network services using NFs with at least one VNF.</td></tr><tr><td>User Service</td><td>Services offered to end users/customers/subscribers.</td></tr><tr><td>Deployment Behavior</td><td>NFVI resources that a VNF requires, e.g., Number of VMs, memory, disk, images, bandwidth, latency</td></tr><tr><td>Operational Behavior</td><td>VNF instance topology and lifecycle operations, e.g., start, stop, pause, migration, …</td></tr><tr><td>VNF Descriptor</td><td>Deployment behavior + Operational behavior</td></tr></tbody></table><h4 id="nfv-framework-requirements"><a class="markdownIt-Anchor" href="#nfv-framework-requirements"></a> NFV Framework Requirements</h4><ol><li>General</li><li>Portability</li><li>Performance</li><li>Elasticity (灵活性、弹性):ScalabletomeetSLAs.Movabletootherservers.</li><li>Resiliency (弹性): Beabletorecreateafterfailure.<br>Specifiedpacketlossrate,callsdrops,timetorecover,etc.</li><li>Security</li><li>Service Continuity</li><li>Service Assurance</li><li>Energy Efficiency Requirements</li><li>Operational and Management Requirements</li><li>Transition</li><li>Service Models</li></ol><h1 id="openstack"><a class="markdownIt-Anchor" href="#openstack"></a> OpenStack</h1><h2 id="openstack-架构"><a class="markdownIt-Anchor" href="#openstack-架构"></a> OpenStack 架构</h2><ul><li>Nova：管理 VM 的生命周期，是 OpenStack 中最核心的服务。</li><li>Neutron：为 OpenStack 提供网络连接服务，负责创建和管理L2、L3 网络，为 VM 提供虚拟网络和物理网络连接。</li><li>Glance：管理 VM 启动镜像，Nova 创建 VM 时将使用 Glance 提供的镜像。</li><li>Cinder：为 VM 提供块存储服务。Cinder 提供的每一个 Volume 在 VM 看来就是一块虚拟硬盘，一般用作数据盘。</li><li>Swift：提供对象存储服务。VM 可以通过 RESTful API 存放对象数据。作为可选的方案，Glance 可以将镜像存放在 Swift 中；Cinder 也可以将 Volume 备份到 Swift 中。</li><li>Keystone：为 OpenStack 的各种服务提供认证和权限管理服务。简单的说，OpenStack 上的每一个操作都必须通过 Keystone 的审核。</li><li>Ceilometer：提供 OpenStac k监控和计量服务，为报警、统计或计费提供数据。</li><li>Horizon：为 OpenStack 用户提供一个 Web 的自服务 Portal。</li></ul><h2 id="部署拓扑"><a class="markdownIt-Anchor" href="#部署拓扑"></a> 部署拓扑</h2><p>OpenStack 是一个分布式系统，由若干不同功能的节点（Node）组成：</p><ul><li>控制节点（Controller Node） 管理 OpenStack，其上运行的服务有 Keystone、Glance、Horizon 以及 Nova 和 Neutron 中管理相关的组件。 控制节点也运行支持 OpenStack 的服务，例如 SQL 数据库（通常是 MySQL）、消息队列（通常是 RabbitMQ）和网络时间服务 NTP。</li><li>网络节点（Network Node） 其上运行的服务为 Neutron。 为 OpenStack 提供 L2 和 L3 网络。 包括虚拟机网络、DHCP、路由、NAT 等</li><li>存储节点（Storage Node） 提供块存储（Cinder）或对象存储（Swift）服务。</li><li>计算节点（Compute Node） 其上运行 Hypervisor（默认使用 KVM）。 同时运行 Neutron 服务的 agent，为虚拟机提供网络支持。</li></ul><p>最小双机部署：</p><ol><li>devstack-controller：控制节点 + 网络节点 + 块存储节点 + 计算节点</li><li>devstack-compute：计算节点</li></ol><p>网络上规划了三个网络：</p><ul><li>Management Network：用于 OpenStack 内部管理用，比如各服务之间通信。 这里使用 eth0</li><li>VM（Tenant）Network：OpenStack 部署的虚拟机所使用的网络。 OpenStack 支持多租户（Tenant），虚机是放在 Tenant 下的，所以叫 Tenant Network。 这里使用 eth1</li><li>External Network：一般来说，Tenant Network 是内部私有网络，只用于 VM 之间通信，与其他非 VM 网络是隔离的。 这里我们规划了一个外部网络（External Network），通过 devstak-controller 的 eth2 连接。 Neutron 通过 L3 服务让 VM 能够访问到 External Network。 对于公有云，External Network 一般指的是 Internet。 对于企业私有云，External Network 则可以是 Intranet 中的某个网络。</li></ul><h2 id="keystone"><a class="markdownIt-Anchor" href="#keystone"></a> Keystone</h2><ul><li>User</li><li>Project</li></ul><h2 id="glance"><a class="markdownIt-Anchor" href="#glance"></a> Glance</h2><h2 id="nova"><a class="markdownIt-Anchor" href="#nova"></a> Nova</h2><p>对于 Nova，这些服务会部署在两类节点上：计算节点和控制节点。</p><p>计算节点上安装了 Hypervisor，上面运行虚拟机。 由此可知：</p><ol><li>只有 nova-compute 需要放在计算节点上。</li><li>其他子服务则是放在控制节点上的。</li></ol><h2 id="通用设计准则"><a class="markdownIt-Anchor" href="#通用设计准则"></a> 通用设计准则</h2><ul><li>api</li><li>scheduler</li><li>worker</li><li>driverf</li><li>message queue</li><li>database</li></ul><h1 id="neutron"><a class="markdownIt-Anchor" href="#neutron"></a> Neutron</h1><p>Neutron 为整个 OpenStack 环境提供网络支持，包括二层交换，三层路由，负载均衡，防火墙和 VPN 等。Neutron 提供了一个灵活的框架，通过配置，无论是开源还是商业软件都可以被用来实现这些功能。</p><h2 id="逻辑架构"><a class="markdownIt-Anchor" href="#逻辑架构"></a> 逻辑架构</h2><p>Neutron 由如下组件构成：</p><p>Neutron Server<br>对外提供 OpenStack 网络 API，接收请求，并调用 Plugin 处理请求。</p><p>Plugin<br>处理 Neutron Server 发来的请求，维护 OpenStack 逻辑网络状态， 并调用 Agent 处理请求。</p><p>Agent<br>处理 Plugin 的请求，负责在 network provider 上真正实现各种网络功能。</p><p>network provider<br>提供网络服务的虚拟或物理网络设备，例如 Linux Bridge，Open vSwitch 或者其他支持 Neutron 的物理交换机。</p><p>Queue<br>Neutron Server，Plugin 和 Agent 之间通过 Messaging Queue 通信和调用。</p><p>Database<br>存放 OpenStack 的网络状态信息，包括 Network, Subnet, Port, Router 等。</p><h2 id="物理部署"><a class="markdownIt-Anchor" href="#物理部署"></a> 物理部署</h2><p>方案1：控制节点 + 计算节点<br>在这个部署方案中，OpenStack 由控制节点和计算节点组成。</p><ul><li>控制节点 部署的服务包括：neutron server, core plugin 的 agent 和 service plugin 的 agent。</li><li>计算节点 部署 core plugin 的agent，负责提供二层网络功能。</li></ul><p>方案2：控制节点 + 网络节点 + 计算节点</p><h2 id="neutron-server"><a class="markdownIt-Anchor" href="#neutron-server"></a> Neutron Server</h2><p>归纳起来，Neutron Server 包括两部分：</p><ol><li>提供 API 服务。</li><li>运行 Plugin。</li></ol><p>即 Neutron Server = API + Plugins</p><h2 id="service-pluginagent"><a class="markdownIt-Anchor" href="#service-pluginagent"></a> Service Plugin/Agent</h2><p>Core Plugin/Agent 负责管理核心实体：net, subnet 和 port。而对于更高级的网络服务，则由 Service Plugin/Agent 管理。</p><ul><li>DHCP - dhcp agent 通过 dnsmasq 为 instance 提供 dhcp 服务。</li><li>Routing - l3 agent 可以为 project（租户）创建 router，提供 Neutron subnet 之间的路由服务。路由功能默认通过 IPtables 实现。</li><li>Firewall - l3 agent 可以在 router 上配置防火墙策略，提供网络安全防护。另一个与安全相关的功能是 Security Group，也是通过 IPtables 实现。 Firewall 与 Security Group 的区别在于：<ul><li>Firewall 安全策略位于 router，保护的是某个 project 的所有 network。</li><li>Security Group 安全策略位于 instance，保护的是单个 instance。</li></ul></li><li>Load Balance - Neutron 默认通过 HAProxy 为 project 中的多个 instance 提供 load balance 服务。</li></ul><h2 id="网络类型"><a class="markdownIt-Anchor" href="#网络类型"></a> 网络类型</h2><h3 id="local-网络"><a class="markdownIt-Anchor" href="#local-网络"></a> local 网络</h3><ol><li>位于同一 local network 的 instance 可以通信。</li><li>位于不同 local network 的 instance 无法通信。</li><li>一个 local network 只能位于一个物理节点，无法跨节点。</li></ol><h3 id="flat-网络"><a class="markdownIt-Anchor" href="#flat-网络"></a> flat 网络</h3><p>每个 flat network 都会独占一个物理网卡。</p><h2 id="安全组"><a class="markdownIt-Anchor" href="#安全组"></a> 安全组</h2><p>安全组有以下特性：</p><ol><li>通过宿主机上 iptables 规则控制进出 instance 的流量。</li><li>安全组作用在 instance 的 port 上。</li><li>安全组的规则都是 allow，不能定义 deny 的规则。</li><li>instance 可应用多个安全组叠加使用这些安全组中的规则。</li></ol><h2 id="虚拟防火墙"><a class="markdownIt-Anchor" href="#虚拟防火墙"></a> 虚拟防火墙</h2><p>FWaaS 有三个重要概念：Firewall、Policy 和 Rule。</p><ul><li>Firewall - 租户能够创建和管理的逻辑防火墙资源。Firewall 必须关联某个 Policy，因此必须先创建 Policy。</li><li>Firewall Policy - Policy 是 Rule 的集合，Firewall 会按顺序应用 Policy 中的每一条 Rule。</li><li>Firewall Rule - Rule 是访问控制规则，由源与目的子网 IP、源与目的端口、协议、allow 或 deny 动作组成。例如，我们可以创建一条 Rule，允许外部网络通过 ssh 访问租户网络中的 instance，端口为 22。</li></ul><p>安全组的应用对象是虚拟网卡，由 L2 Agent 实现，比如 neutron_openvswitch_agent 和 neutron_linuxbridge_agent。安全组会在计算节点上通过 iptables 规则来控制进出 instance 虚拟网卡的流量。也就是说：安全组保护的是 instance。</p><p>FWaaS 的应用对象是 router，可以在安全组之前控制外部过来的流量，但是对于同一个 subnet 内的流量不作限制。也就是说：FWaaS 保护的是 subnet。</p><p>同时我们也发现，firewall rule 对进出流量同时生效，不区分方向。</p><p>相同点：</p><ol><li>底层都是通过 iptables 实现。</li></ol><p>不同点：</p><ol><li>FWaaS 的 iptables 规则应用在 router 上，保护整个租户网络；安全组则应用在虚拟网卡上，保护单个 instance。</li><li>FWaaS 可以定义 allow 或者 deny 规则；安全组只能定义 allow 规则。</li></ol><h2 id="lbaas"><a class="markdownIt-Anchor" href="#lbaas"></a> LBaaS</h2><p>LBaaS 有三个主要的概念：<br>Pool Member，Pool 和 Virtual IP</p><p>Pool Member<br>Pool Member 是 layer 4 的实体，拥有 IP 地址并通过监听端口对外提供服务。<br>例如 Pool Member 可以是一个 web server，IP 为 172.16.100.9 并通过 80 端口提供 HTTP 服务。</p><p>Pool<br>Pool 由一组 Pool Member 组成。<br>这些 Pool Member 通常提供同一类服务。<br>例如一个 web server pool，包含：<br>web1：172.16.100.9：80<br>web2：172.16.100.10：80</p><p>Virtual IP<br>Virtual IP 也称作 VIP，是定义在 load balancer 上的 IP 地址。<br>每个 pool member 都有自己的 IP，但对外服务则是通过 VIP。</p><p>load balancer 负责监听外部的连接，并将连接分发到 pool member。<br>外部 client 只知道 VIP，不知道也不需要关心是否有 pool 或者有多少个 pool member。</p><p>OpenStack Neutron 目前默认通过 HAProxy 软件来实现 LBaaS。<br>HAProxy 是一个流行的开源 load balancer。<br>Neutron 也支持其他一些第三方 load balancer。</p><ol><li>Load Balance Method 是为新连接选择 member 的方法</li><li>Session Persistence 是为同一个 client 的后续连接选择 member 的方法</li></ol><p>LBaaS 可以创建 monitor，用于监控 Pool Member 健康状态。</p><h1 id="大型网站系统"><a class="markdownIt-Anchor" href="#大型网站系统"></a> 大型网站系统</h1><h2 id="架构演进"><a class="markdownIt-Anchor" href="#架构演进"></a> 架构演进</h2><ul><li>用 Java 和单机构建的交易网站</li><li>单机负载过大 - 数据库与应用分离</li><li>应用服务器负载过大 - 应用服务器集群化<ul><li>引入负载均衡</li><li>解决 session 问题<ul><li>session sticky</li><li>session replication</li><li>session 集中存储</li><li>cookie based session</li></ul></li></ul></li><li>数据读取压力大 - 读写分离<ul><li>采用数据库作为读库</li><li>使用 search cluster 构建索引</li><li>缓存 cache cluster</li></ul></li><li>关系型数据库不足 - 分布式存储系统</li><li>单个（主）数据库瓶颈<ul><li>专库专用，垂直拆分</li><li>水平拆分</li></ul></li><li>应用方面的挑战<ul><li>根据业务特性拆分应用</li><li>服务化系统结构。业务之间的功能不再是方法调用，引入远程服务调用</li></ul></li><li>消息中间件！！ (Message Oriented Middleware, MOM)</li></ul><h2 id="java-中间件"><a class="markdownIt-Anchor" href="#java-中间件"></a> Java 中间件</h2><ul><li>三个领域的中间件<ul><li>RPC 和对象访问中间件</li><li>消息中间件</li><li>数据访问中间件</li></ul></li><li>Java 中间件基础知识<ul><li>JVM</li><li>垃圾回收与内存堆布局</li><li>Java 并发编程的类、接口、方法<ul><li>线程池</li><li>synchronized</li><li>ReentrantLock</li><li>volatile</li><li>Atomics</li><li>wait, notify, notifyAll</li><li>CountDownLatch</li><li>CyclicBarrier</li><li>Semaphore 利用 acquire and release 控制并发量</li><li>Exchanger 两个线程间数据交换</li><li>Future and FutureTask 暂时不需要的数据，不应该傻傻的等待，开一个执行线程，等需要的时候再 get</li><li>并发容器 CopyOnWrite 以及 Concurrent* 类</li></ul></li><li>动态代理</li><li>反射</li><li>网络通信实现 (BIO, NIO, AIO)<ul><li>同步阻塞IO (BIO)</li><li>同步非阻塞IO (NIO)</li><li>异步阻塞IO ()</li></ul></li></ul></li><li>分布式系统中的 Java 中间件</li></ul><h2 id="服务框架"><a class="markdownIt-Anchor" href="#服务框架"></a> 服务框架</h2><ul><li>网站功能丰富后的应对</li><li>服务框架的设计与实现<ul><li>数据库从单机到分布式的挑战和应对方式</li><li>服务调用端的设计实现</li><li>服务提供端的调用实现</li><li>服务升级</li></ul></li><li>实战优化</li></ul><h2 id="数据访问层"><a class="markdownIt-Anchor" href="#数据访问层"></a> 数据访问层</h2><ul><li>数据库从单机到分布式的挑战和应对方式</li><li>数据访问层的设计与实现<ul><li>如何对外提供数据访问层的功能<ul><li>对外提供数据访问层的方式<ul><li>专有 API</li><li>数据层本身作为一个 JDBC 的实现</li><li>基于 ORM 或类 ORM 接口的方式</li></ul></li><li>不同方式在合并查询的对比</li></ul></li><li>数据层流程</li></ul></li></ul><h1 id="系统设计-system-design"><a class="markdownIt-Anchor" href="#系统设计-system-design"></a> 系统设计 (System Design)</h1><ul><li><a href="https://www.zhihu.com/question/26312148" target="_blank" rel="noopener">https://www.zhihu.com/question/26312148</a></li></ul><h1 id="openstack-2"><a class="markdownIt-Anchor" href="#openstack-2"></a> OpenStack</h1><ul><li><a href="https://cloud.tencent.com/developer/article/1083332" target="_blank" rel="noopener">OpenStack Neutron 架构指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/31045898" target="_blank" rel="noopener">OpenStack Neutron概述</a></li><li><a href="https://www.cnblogs.com/sammyliu/p/4622563.html" target="_blank" rel="noopener">Neutron 理解</a></li><li><a href="https://docs.openstack.org/arch-design/index.html" target="_blank" rel="noopener">OpenStack Architecture Design Guide</a></li><li><a href="https://docs.openstack.org/neutron/latest/" target="_blank" rel="noopener">Welcome to Neutron’s documentation!</a></li><li><a href="https://docs.openstack.org/glance/latest/" target="_blank" rel="noopener">Welcome to Glance’s documentation!</a></li></ul><h1 id="云计算"><a class="markdownIt-Anchor" href="#云计算"></a> 云计算</h1><h2 id="云计算模型"><a class="markdownIt-Anchor" href="#云计算模型"></a> 云计算模型</h2><p>每种类型的云计算都提供不同级别的控制、灵活性和管理，因此您可以根据需要选择正确的服务集。</p><ul><li>基础设施即服务 (IaaS)</li><li>平台即服务 (PaaS)</li><li>软件即服务 (SaaS)</li></ul><p>参考资料：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html" target="_blank" rel="noopener">IaaS，PaaS，SaaS 的区别</a></li><li><a href="https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/" target="_blank" rel="noopener">SaaS vs PaaS vs IaaS: What’s The Difference and How To Choose</a></li><li><a href="https://www.redhat.com/en/topics/cloud-computing/what-is-caas" target="_blank" rel="noopener">What is CaaS?</a></li></ul><h2 id="云计算部署模型"><a class="markdownIt-Anchor" href="#云计算部署模型"></a> 云计算部署模型</h2><ul><li>云</li><li>混合</li><li>本地</li></ul><h2 id="vpc"><a class="markdownIt-Anchor" href="#vpc"></a> VPC</h2><p>VPC的全称是 Virtual Private Cloud，中文有的叫专有网络，有的叫私有网络，核心就是能让你购买的一台或多台机器（或其它资源），能划分到一个私网中，与其它用户隔离，也可以把自己的多台资源的机器隔离（如果你需要的话）。VPC是随着云计算而产生的一种技术，是为了解决传统网络在云环境中无法满足的功能、安全性、灵活性而生的。</p><ul><li><a href="https://www.cloudflare.com/learning/cloud/what-is-a-virtual-private-cloud/" target="_blank" rel="noopener">What Is a Virtual Private Cloud (VPC)?</a></li></ul><h1 id="分布式存储"><a class="markdownIt-Anchor" href="#分布式存储"></a> 分布式存储</h1><h2 id="块存储-vs-文件存储-vs-对象存储"><a class="markdownIt-Anchor" href="#块存储-vs-文件存储-vs-对象存储"></a> 块存储 vs 文件存储 vs 对象存储</h2><ul><li><a href="https://www.redhat.com/en/topics/data-storage/file-block-object-storage" target="_blank" rel="noopener">File storage, block storage, or object storage?</a></li><li><a href="https://www.zhihu.com/question/21536660" target="_blank" rel="noopener">块存储、文件存储、对象存储这三者的本质差别是什么？</a></li></ul><h1 id="mq"><a class="markdownIt-Anchor" href="#mq"></a> MQ</h1><h2 id="rabbitmq"><a class="markdownIt-Anchor" href="#rabbitmq"></a> RabbitMQ</h2><ul><li><p>什么是 mq？<br>采用 AMQP 高级消息队列协议的一种消息队列技术,最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦</p></li><li><p>为什么需要 mq？<br>（1）在分布式系统下具备异步,削峰,负载均衡等一系列高级功能;（2）拥有持久化的机制，进程消息，队列中的信息也可以保存下来。（3）实现消费者和生产者之间的解耦。（4）对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。（5）可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。</p></li><li><p>使用 rabbitmq 的场景<br>（1）服务间异步通信<br>（2）顺序消费<br>（3）定时任务<br>（4）请求削峰</p></li><li><p>4、如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？<br>发送方确认模式将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p></li></ul><p>接收方确认机制消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；下面罗列几种特殊情况（1）如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）（1）2如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</p><p>5.如何避免消息重复投递或重复消费？在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支付 ID、订单 ID、帖子 ID 等）作为去重的依据，避免同一条消息被重复消费。6、消息基于什么传输？由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</p><p>7、消息如何分发？<br>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能</p><p>8、消息怎么路由？消息提供方-&gt;路由-&gt;一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；常用的交换器主要分为一下三种：fanout：如果交换器收到消息，将会广播到所有绑定的队列上direct：如果路由键完全匹配，消息就被投递到相应的队列topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符</p><p>9、如何确保消息不丢失？消息持久化，当然前提是队列必须持久化RabbitMQ 确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit 会在消息提交到日志文件后才发送响应。一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ 会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前 RabbitMQ 重启，那么 Rabbit 会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件中的消息到合适的队列。</p><p>10、使用 RabbitMQ 有什么好处？<br>（1）服务间高度解耦<br>（2）异步通信性能高<br>（3）流量削峰</p><p>11、RabbitMQ 的集群镜像集群模式你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://www.makeuseof.com/tag/virtualbox-vs-vmware-vs-hyper-v/" target="_blank" rel="noopener">VirtualBox vs. VMWare vs. Hyper-V: What’s the Best Virtual Machine?<br></a></li></ul><h2 id="openstack-3"><a class="markdownIt-Anchor" href="#openstack-3"></a> Openstack</h2><ul><li><a href="https://www.jianshu.com/p/4c06dff6cea8" target="_blank" rel="noopener">每天5分钟玩转 OpenStack</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Programming</title>
      <link href="/notes/programming/index.html"/>
      <url>/notes/programming/index.html</url>
      
        <content type="html"><![CDATA[<p>编程的目的是让计算机以我们想要的方式运行，从而为我们解决实际问题。然而驱动硬件需要使用机器指令或是汇编语言，没有人希望写一个计算两个整数加法的程序还需要查询 CPU 的指令集手册，我们只是需要一种对所执行任务的逻辑表达，然后计算机可以“懂得”我们的意思，并愉快的执行任务。</p><p>高级编程语言（如 C/C++，Python，Java，Golang 等）为我们做了中间翻译的过程，他们使用了基本相似的“翻译”手段，将程序员使用该语言书写的遵循某种语法的源文件，翻译为计算机可以执行的机器码，从而解放了生产力。不同的语言根据使用场景、个人品味、历史潮流等因素，都或多或少的“夹带私货”，这些“私货”就是他们之间不同的地方，合理的利用私货可以提高生产力，但遗憾的是，并非所有的私货都是精华。</p><p>学习编程的第一步通常是学习某种编程语言，理论上来讲，学习任何编程语言都是类似的过程，因为现代的大多数高级编程语言都包含了<strong>语言特性</strong>。通过基本语言特性，我们其实已经能很好的完成 99% 的工作，所以我们首先应当理解这些基本的语言特性，这对于所有的语言都是类似的，仅仅是呈现的语法不同而已。</p><p>现代编程语言的语言特性可能包括但不限于以下：</p><ul><li>变量定义</li><li>算术运算</li><li>控制流（条件语句、循环语句）</li><li>函数定义、函数调用</li><li>递归</li><li>静态的类型系统</li><li>动态类型推导</li><li>lambda 函数</li><li>面向对象</li><li>垃圾回收</li><li>指针算术</li><li>goto 语句</li></ul><div class="note info">            <p>并非所有的编程语言都实现了这些语言特性，其中有一些也不是基本语言特性。是否具有某种语言特性，以及这种语言特性是如何实现的属于“私货”。在大部分场景下，合理的利用高级语言特性将会提高机器执行和程序开发的效率。</p>          </div><div class="note warning">            <p>你可能已经注意到，C 语言中 printf 等打印输出函数不能算语言特性，这只是一种调用操作系统接口的库函数而已。所以学习一门新的编程语言千万<strong>不要陷入对库函数用法的机械记忆</strong>（有多少新手是由于记不住 printf() 中 %p 格式究竟代表何种数据类型而劝退的呢？），确认掌握了基本语言特性以及尽可能的理解高级语言特性才是学习一门编程语言的正确方式。</p>          </div><p>我们书写的程序是在计算机上运行的（假设都是现代 X86/64 架构的通用计算机），而计算机的管家是操作系统，所以相当于我们的程序是在操作系统上运行的，而大部分操作系统又是使用 C 语言以及汇编语言写成的，因此，C 语言是高级编程语言中相对低级的那些，它是高级语言的鼻祖，没有花哨的高级语言特性，却能在偏向底层的场合运行的十分好。</p><p>那么什么是编程语言的高级语言特性呢？正是由于 C 语言不具有高级的特性，在如今计算机硬件飞速发展和软件系统如此发达的今天，C 语言在大多数场合显得不那么合适了。这时，这些高级语言特性为我们做了更多的事情，以便我们将注意力更多的放在业务实现的逻辑，而不是面面俱到的处理每一个编程的细节。例如：支持类型推导的 Python 使我们不再烦恼一个变量应该定义为什么类型；支持垃圾回收的 Java 语言使我们不再烦恼于因为忘记释放指针而引起的内存泄漏。</p><p>这些高级的特性总是好的吗？不然！设计该特性的初衷可能是好的，然而该语言的具体实现可能具有种种使用约束，或者程序员滥用特性等语言，可能会导致更加糟心的后果。但总体来说是利大于弊。因此，学习编程语言在如今更像是选择一种工具，正如没有十全十美的工具，程序员应当在众多工具之中权衡利弊，最后选择合适的编程语言与架构来完成工作。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System</title>
      <link href="/notes/os/index.html"/>
      <url>/notes/os/index.html</url>
      
        <content type="html"><![CDATA[<p>在操作系统的实际学习中，其与计算机组成原理以及计算机体系架构有着很强的关联。因此，本部分内容以操作系统为主，且辅以计算机系统和计算机架构等相关的知识。正如 <a class="btn" href="http://csapp.cs.cmu.edu/3e/home.html" title="home fa-fw fa-lg" target="_blank" rel="noopener">            <i class="fa fa-3/E (CS:APP3e)"></i>Computer Systems: A Programmer's Perspective          </a> 这本书所展示的，只有对操作系统、计算机系统，甚至硬件具有相当的了解，才能写出更好的代码。</p><p>从程序员的角度来看，操作系统的学习包括两方面：</p><ol><li>操作系统的概念：为何要有某种机制？以及 OS 如何实现这种机制？</li><li>操作系统的应用：OS 为软件提供了哪些功能？程序员如何使用这些功能？</li></ol><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><ul><li><a href="/2020/08/03/os-intro/">操作系统介绍</a></li><li><a href="/2020/10/21/os-unix/">Unix/Linux 介绍</a></li></ul><h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1><ul><li>[完成 90%+] <a href="/2020/08/02/os-process/">进程</a></li><li>[0%] [进程间通信]</li></ul><h1 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h1><ul><li><a href="/2020/08/03/os-vm">虚拟内存</a></li><li><a href>超越物理内存</a></li></ul><h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1><h2 id="线程并发"><a class="markdownIt-Anchor" href="#线程并发"></a> 线程并发</h2><ul><li><a href="/2020/10/21/os-thread/">线程及其 API</a> — 并发梦开始的地方</li><li><a href="/2020/07/31/os-lock/">锁</a> — 线程并发的基石</li><li>基于锁的并发数据结构 — 锁在不同场景下的性能</li><li><a href="/2020/08/01/os-cv/">条件变量</a> — 另一种并发的原语</li><li>信号量 — 作为同步的唯一原语统一锁和条件变量</li><li>线程并发的问题 — 原子性缺陷、顺序性缺陷、可见性缺陷、死锁</li></ul><h2 id="事件并发"><a class="markdownIt-Anchor" href="#事件并发"></a> 事件并发</h2><h1 id="文件系统实现"><a class="markdownIt-Anchor" href="#文件系统实现"></a> 文件系统实现</h1><h1 id="杂"><a class="markdownIt-Anchor" href="#杂"></a> 杂</h1><h2 id="unix-io-模型"><a class="markdownIt-Anchor" href="#unix-io-模型"></a> Unix I/O 模型</h2><p>对于一次 IO 访问 (以 read 举例) ，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个 read 操作发生时，它会经历两个阶段：</p><ol><li>等待数据准备完毕 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ol><p>Unix 下有五种基本的 I/O 模型：</p><ul><li>阻塞 I/O (blocking I/O)</li><li>非阻塞 I/O (nonblocking I/O)</li><li>I/O 多路复用 (IO multiplexing)</li><li>信号驱动 I/O (signal driven IO)</li><li>异步 I/O (asynchronous IO)</li></ul><h1 id="io-设备"><a class="markdownIt-Anchor" href="#io-设备"></a> I/O 设备</h1><h2 id="系统架构"><a class="markdownIt-Anchor" href="#系统架构"></a> 系统架构</h2><p>分层架构？物理布局和造价成本</p><ul><li>越快越短</li><li>越快越贵</li></ul><p><a href="prototypical-system-architecture.png">prototypical-system-architecture</a></p><h2 id="标准设备"><a class="markdownIt-Anchor" href="#标准设备"></a> 标准设备</h2><ul><li>interface</li><li>internal</li></ul><p><img src="device.png" alt="device"></p><h2 id="标准协议"><a class="markdownIt-Anchor" href="#标准协议"></a> 标准协议</h2><h3 id="轮询-polling"><a class="markdownIt-Anchor" href="#轮询-polling"></a> 轮询 (polling)</h3><h3 id="中断-interrupt"><a class="markdownIt-Anchor" href="#中断-interrupt"></a> 中断 (interrupt)</h3><p>合并 (coalescing)</p><h3 id="dma"><a class="markdownIt-Anchor" href="#dma"></a> DMA</h3><h2 id="操作系统与设备"><a class="markdownIt-Anchor" href="#操作系统与设备"></a> 操作系统与设备</h2><h3 id="设备交互"><a class="markdownIt-Anchor" href="#设备交互"></a> 设备交互</h3><ul><li>明确的 I/O 指令</li><li>内存映射 I/O</li></ul><h3 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h3><h2 id="典型-io-设备"><a class="markdownIt-Anchor" href="#典型-io-设备"></a> 典型 I/O 设备</h2><h3 id="hard-disk-driver"><a class="markdownIt-Anchor" href="#hard-disk-driver"></a> Hard Disk Driver</h3><h3 id="raid-redundant-array-of-inexpensive-disk"><a class="markdownIt-Anchor" href="#raid-redundant-array-of-inexpensive-disk"></a> RAID (Redundant Array of Inexpensive Disk)</h3><p>评估 RAID：</p><ul><li>容量</li><li>可靠性</li><li>性能</li></ul><p>Raid</p><ul><li>RAID 0：无冗余</li><li>RAID 1：镜像<ul><li>RAID 10</li><li>RAID 01</li></ul></li><li>RAID 4：奇偶校验</li><li>RAID 5：旋转奇偶校验</li></ul><h1 id="文件和目录"><a class="markdownIt-Anchor" href="#文件和目录"></a> 文件和目录</h1><h2 id="文件和目录-2"><a class="markdownIt-Anchor" href="#文件和目录-2"></a> 文件和目录</h2><h2 id="文件系统接口"><a class="markdownIt-Anchor" href="#文件系统接口"></a> 文件系统接口</h2><table><thead><tr><th>接口</th><th>系统调用</th></tr></thead><tbody><tr><td>创建文件</td><td>open()</td></tr><tr><td>读取文件</td><td>read()</td></tr><tr><td>写入文件</td><td>write()</td></tr><tr><td>文件偏移</td><td>lseek()</td></tr><tr><td>立即写入</td><td>fsync()</td></tr><tr><td>文件重命名</td><td>rename()</td></tr><tr><td>获取文件信息</td><td>stat()/fstat()</td></tr><tr><td>删除文件</td><td>unlink()</td></tr><tr><td>创建目录</td><td>mkdir()</td></tr><tr><td>读取目录</td><td>opendir(), readdir(), closedir()</td></tr><tr><td>删除目录</td><td>rmdir()</td></tr></tbody></table><div class="note info">            <ul><li>文件描述符</li><li>strace 跟踪系统调用</li></ul>          </div><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><h2 id="书籍"><a class="markdownIt-Anchor" href="#书籍"></a> 书籍</h2><ul><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">Operating Systems: Three Easy Pieces</a></li><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/01.pdf" target="_blank" rel="noopener">操作系统导论</a></li><li><a href="http://www.apuebook.com/about3e.html" target="_blank" rel="noopener">Advanced Programming in the UNIX® Environment, Third Edition</a></li><li><a href="http://www.unpbook.com/" target="_blank" rel="noopener">UNIX Network Programming - Volume 1 Socket Programming, Third Edition</a></li><li>UNIX Network Programming - volume 2 IPC, Second Edition</li></ul><h2 id="文章"><a class="markdownIt-Anchor" href="#文章"></a> 文章</h2><ul><li><a href="https://en.wikipedia.org/wiki/Process_state" target="_blank" rel="noopener">Process state</a></li><li><a href="https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/" target="_blank" rel="noopener">CPU Scheduling in Operating Systems</a></li></ul><h2 id="问答"><a class="markdownIt-Anchor" href="#问答"></a> 问答</h2><ul><li><a href="https://stackoverflow.com/questions/2445242/what-does-the-kernel-virtual-memory-of-each-process-contain" target="_blank" rel="noopener">What does the Kernel Virtual Memory of each process contain?</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Networking</title>
      <link href="/notes/networking/index.html"/>
      <url>/notes/networking/index.html</url>
      
        <content type="html"><![CDATA[<p>网络 (networks) 是一个复杂的东西，因此网络 (networking) 同时又是一门复杂的技术，涉及到通信技术，算法，协议，编程语言，操作系统，服务器，网络设备等方方面面，不仅需要<strong>软硬结合</strong>的功力，还涉及不少<strong>理论和工程</strong>方面的知识。学习网络技术，也是一种旅行吧。</p><p>从 1969 年美国国防部的 ARPA 网开始，到如今「大物移云」的时代，多种网络技术、架构、协议轮番登场，有的如今仍然存在，有的却因为这样或者那样的原因退出了历史的舞台中，网络经历了演变，并正在演变…</p><a id="more"></a><div class="note info">            <ul><li>非链接表示：给出基础概念，用作复习关键词。</li><li>链接表示：有一篇博文对应。<ul><li>完成 90% + 的会从草稿移入已发布。</li><li>未完成的在草稿箱中待完善。</li><li>计划中表示对该技术有兴趣，但暂时缺乏动力编写。</li></ul></li></ul>          </div><h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ul><li>计算机网络发展</li><li>分组交换和电路交换</li><li><a href="/2018/12/19/network-architecture-and-standardization">网络体系结构与标准</a></li><li>网络的服务质量保证 (QoS)</li></ul><h2 id="物理层-physical-layer"><a class="markdownIt-Anchor" href="#物理层-physical-layer"></a> 物理层 (Physical Layer)</h2><ul><li>传输链路</li><li>数据编码</li><li>无线传输</li></ul><h2 id="局域网-local-area-networks-the-link-layer"><a class="markdownIt-Anchor" href="#局域网-local-area-networks-the-link-layer"></a> 局域网 (Local Area Networks / The Link Layer)</h2><ul><li><a href="/2018/12/29/network-lan/">局域网</a></li><li>[完成 70%] <a href="/2018/12/29/network-ethernet/">以太网 - Ethernet</a></li><li>[计划中] <a href>Shared Media LANs</a></li></ul><h2 id="网络互联-tcpip-internet-working-the-network-layer"><a class="markdownIt-Anchor" href="#网络互联-tcpip-internet-working-the-network-layer"></a> 网络互联 (TCP/IP Internet-working / The Network Layer)</h2><ul><li>[完成 90%+] <a href="/2019/01/01/network-addressing">Addressing in TCP/IP Networks</a></li><li>[完成 20%] <a href="/2019/07/01/network-ipv4/">Routed Protocols - Internet Protocol Version 4 (IPv4)</a></li><li>[完成 20%] <a href="/2019/08/30/network-ipv6/">Routed Protocols - Internet Protocol Version 6 (IPv6)</a></li><li>[完成 50%] <a href="/2019/07/01/network-ip-routing/">IP Routing in TCP/IP Networks</a></li><li>[计划中] <a href>ICMP: Internet Control Message Protocol</a></li></ul><h2 id="传输层-transport-layer"><a class="markdownIt-Anchor" href="#传输层-transport-layer"></a> 传输层 (Transport Layer)</h2><ul><li>[完成 90%] <a href>传输控制协议 - TCP</a></li><li>[计划中] <a href>用户数据报协议 - UDP</a></li><li>[完成 20%] <a href>给你安全感的 TLS</a></li><li>[计划中] <a href>给你快速度的 QUIC</a></li></ul><h2 id="应用层-application-layer"><a class="markdownIt-Anchor" href="#应用层-application-layer"></a> 应用层 (Application Layer)</h2><ul><li>[完成 20%] <a href>The Web and HTTP(S)</a></li><li>[计划中] <a href>Electronic Mail in the Internet</a></li></ul><h1 id="套接字编程-socket-programming"><a class="markdownIt-Anchor" href="#套接字编程-socket-programming"></a> 套接字编程 (Socket Programming)</h1><p>本部分内容由网络工程师的角度转化为程序员的角度，讨论的内容也由整个网络缩小到<strong>网络中的终端</strong>。在前面的部分，我们讨论了物理层，通过 LAN 认识了数据链路层，通过 TCP/IP 网络互联了解了网络层、传输层、应用层及其相关协议。</p><p>我们熟悉的 Web 和 HTTP 协议、邮件、即时聊天软件、在线视频点播等应用，大都构筑在传输层之上的，这些软件的开发者，不需要深入了解应用层以下的网络内容，也可以写出可用的软件，这得益于 <strong>TCP/IP 网络的分层架构</strong>以及<strong>操作系统提供的套接字 (Socket) 编程接口</strong>，通过 Socket，我们可以专注于业务应用，而将复杂的网络数据包处理过程交给操作系统中的网络协议栈来帮助我们完成。</p><p>提到 Socket，你可能会以为它仅仅是一个传输层到应用层的桥梁，虽然大多数情况下，我们使用 TCP 流套接字 (Stream Sockets) 或者 UDP 数据报套接字 (Datagram Sockets) 来开发我们的程序，但却不仅仅如此，不同类型的套接字可能深入到不同的协议层，除了上述提到的套接字，还包括其他流套接字、原始套接字（深入到 IP 层）、数据链路套接字，甚至还有内核之间的套接字等。因此，可以说 Socket 编程是一个广泛的问题，其可能涉及到从数据链路层到应用层的所有知识。</p><p>通常，我们使用 C 语言来学习 Socket 编程，这是必要的，因为底层的套接字只有 C 语言可以实现（其他语言如 Python 仅仅是包装了一层 C 函数，提供了 Python 的 API 而已），因此使用 C 语言可以方便的编写一些网络工具。但对于大规模的应用开发，使用 C 语言有些力不从心，考虑到一般情况下传输层协议采用 TCP 或 UDP 协议，因此可以使用 Java 语言（Java 为了跨平台特性，只提供 TCP 和 UDP 的套接字接口）来进行开发。</p><p>在本部分内容中，所有的 Socket 编程均使用 C 语言，并且在 Linux 平台下开发，尽管是 Linux 操作系统，但为了保持较好的移植性也尽可能使用 Unix 兼容的 POSIX 接口，在必要的时候会使用 Linux 接口。</p><p>考虑到 Socket 编程涉及到一些操作系统知识，因此本部分的内容建立在 <a class="btn" href="/notes/os/linux/">            <i class="fa fa-home fa-fw fa-lg"></i>OS - Linux          </a> 之上。</p><ul><li>[完成 20%-] <a href="/2019/06/10/socket-programming-in-c/">Socket Programming in C</a></li></ul><h1 id="软件定义网络-sdn"><a class="markdownIt-Anchor" href="#软件定义网络-sdn"></a> 软件定义网络 (SDN)</h1><p>软件定义网络 (Software-Defined Networking, SDN) 如今的到了飞速的发展，并逐渐用于一些网络场景。以下是一些简单的链接。</p><h2 id="emulator-mininet"><a class="markdownIt-Anchor" href="#emulator-mininet"></a> Emulator: Mininet</h2><ul><li><a href="/2018/10/31/mininet-basics">Basics: Get Started, Sample Workflow and Walkthrough</a></li></ul><h2 id="controllers"><a class="markdownIt-Anchor" href="#controllers"></a> Controllers</h2><h3 id="floodlight"><a class="markdownIt-Anchor" href="#floodlight"></a> Floodlight</h3><ul><li><a href="https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/overview" target="_blank" rel="noopener">Documentation</a><ul><li><a href="https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343542/Getting+Started" target="_blank" rel="noopener">Getting Started</a></li><li><a href="https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343557/User+Documentation" target="_blank" rel="noopener">User Documentation</a></li><li><a href="https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343556/For+Developers" target="_blank" rel="noopener">For Developers</a></li></ul></li></ul><h3 id="onos"><a class="markdownIt-Anchor" href="#onos"></a> ONOS</h3><h3 id="opendaylight"><a class="markdownIt-Anchor" href="#opendaylight"></a> OpenDayLight</h3><h2 id="hypervisor"><a class="markdownIt-Anchor" href="#hypervisor"></a> Hypervisor</h2><ul><li>FlowVisor</li><li>OVX</li></ul><h2 id="switches"><a class="markdownIt-Anchor" href="#switches"></a> Switches</h2><ul><li>OVS</li></ul><h2 id="protocols"><a class="markdownIt-Anchor" href="#protocols"></a> Protocols</h2><h3 id="openflow"><a class="markdownIt-Anchor" href="#openflow"></a> OpenFlow</h3><ul><li><a href="/2019/02/23/openflow-specification/">OpenFlow Specification</a></li></ul><h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2><ul><li>Q：SDN 中 处理 ARP 的逻辑<br>A：<a href="https://www.sdnlab.com/8513.html" target="_blank" rel="noopener">https://www.sdnlab.com/8513.html</a></li></ul><h2 id="external-links"><a class="markdownIt-Anchor" href="#external-links"></a> External Links</h2><ul><li><a href="https://www.zhihu.com/question/27336289/answer/92617122?from=profile_answer_card" target="_blank" rel="noopener">杨泽卫老师推荐</a></li><li><a href="https://sites.google.com/site/sdnreadinglist/" target="_blank" rel="noopener">SDN Reading list</a> 需要梯子</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="http://www.olifer.co.uk/Main_menu_eng.htm" target="_blank" rel="noopener">Computer Networks: Principles, Technologies and Protocols for Network Design</a></li><li>Computer Networking A Top-Down Approach 6th Edition By Kurose and Ross</li><li>Computer Networks 5th Edition By Andrew S. Tanenbaum</li><li><a href="https://en.wikipedia.org/wiki/Computer_network" target="_blank" rel="noopener">Computer network, wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI model</a></li><li><a href="https://en.wikipedia.org/wiki/Lists_of_network_protocols" target="_blank" rel="noopener">Lists of network protocols</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tools</title>
      <link href="/notes/tools/index.html"/>
      <url>/notes/tools/index.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>工欲善其事，必先利其器。<br>– 孔子</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>本版收集各种好用的工具的用法。以下将分类别列出，💕表示个人喜好与推荐。</p><ul><li>对于重要、使用频率高且有推广价值的工具，将开辟<strong>单独子版块</strong>详细记录。</li><li>对于其他工具，视<s>心情</s>情况给出一个<strong>本博客的文章链接</strong>或者<strong>官方链接</strong>。</li></ul><h1 id="版本控制工具"><a class="markdownIt-Anchor" href="#版本控制工具"></a> 版本控制工具</h1><ul><li>💕 <a href="/notes/tools/git/">Git</a></li></ul><h1 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h1><ul><li><a href="/2019/05/08/pro-vim/">Vim</a></li><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a></li></ul><h1 id="集成开发环境"><a class="markdownIt-Anchor" href="#集成开发环境"></a> 集成开发环境</h1><ul><li>💕 <a href="/notes/tools/idea/">IntelliJ IDEA</a></li></ul><h1 id="项目构建与管理"><a class="markdownIt-Anchor" href="#项目构建与管理"></a> 项目构建与管理</h1><h2 id="cc"><a class="markdownIt-Anchor" href="#cc"></a> C/C++</h2><ul><li><a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">GNU make</a></li><li><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html" target="_blank" rel="noopener">CMake</a></li></ul><h2 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h2><ul><li><a href="/2020/01/09/pro-maven/">Maven</a></li><li><a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">Gradle</a></li></ul><h2 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h2><ul><li><a href="https://pip.pypa.io/en/stable/" target="_blank" rel="noopener">pip</a></li></ul><h2 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h2><ul><li><a href="https://docs.npmjs.com/" target="_blank" rel="noopener">npm</a></li></ul><h1 id="online-references"><a class="markdownIt-Anchor" href="#online-references"></a> Online References</h1><ul><li><a href="https://katex.org/docs/supported.html" target="_blank" rel="noopener">katex</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Commands</title>
      <link href="/notes/os/commands/index.html"/>
      <url>/notes/os/commands/index.html</url>
      
        <content type="html"><![CDATA[<p>学习 Linux 主要包括两种程序员：</p><ol><li>使用 Linux 完成工作。</li><li>工作的内容是 Linux 的方方面面。</li></ol><p>第一类人是 Linux 的使用者，本分版的内容是笔者作为 Linux 使用者的一个总结，不涉及第二类人所需的 Linux 内核等操作系统实现的知识。本版内容主要介绍各种各样的<strong>命令行工具 (command-line tools)</strong>，或称之为命令、命令行软件等。大致可以分为两种：</p><ul><li>操作系统自带的命令或软件 (包括不同 Linux 版本自带的命令或软件)</li><li>用户安装的命令行界面软件 (包括 GUI 软件提供的命令行工具)</li></ul><p>前者解决了有无的问题，自带的命令/软件保证了我们对于该操作系统可以进行基本的操作，而后者解决了使用体验好坏的问题，自行安装喜欢的软件或许可以提高我们的工作效率。</p><p>Windows 系统的操作风格是面向界面 (Graphic User Interface, GUI) 的，而 *nix (包括 Unix、Linux、macOS 以及其他 Unix-like 系统) 操作系统的操作风格是面向命令行 (Command Line Interface, CLI) 的。两种方式各有利弊，所以两种操作系统在各自偏好的操作风格的基础上，都提供了 GUI 和 CLI 两种操作方式，例如 Windows 的 CMD/PowerShell 以及 Linux 的 X Window 等。</p><p>笔者以 Linux 作为主要使用的操作系统，因此<strong>如无特殊说明，本版内容中的命令均用于 Linux 系统</strong>，其中部分应当可以用于 Unix 以及 Unix-like 等操作系统。</p><p>有一些命令是系统自带的，被称为<strong>核心工具包 (Core utilities)</strong>，它们是管理系统的基础和核心，应当首先掌握。而有一些命令是某些组织或用户开发的，这些命令 (或称为软件) 往往能帮助我们<strong>更好</strong>的使用系统，但并<strong>不意味着都是必需的</strong>，等到用时再了解这些前辈留下智慧往往使你惊艳，而不是陷入盲目学习各种命令的深渊，如果你觉得 GNU/Linux 世界的命令实在是太复杂而难以掌握，这或许是一个原因。</p><p>本文整理了包括但不限于 <code>GNU coreutils</code> 的工具，例如其他 GNU package，<code>util-linux</code>，甚至一些 shell built-ins。其中包括传统 Unix 的工具，也有一些基于 POSIX 标准开发的工具，但他们提供了更多的特性。这些工具 (命令) 的基本用法应该是首要掌握的，至于高级用法，慢慢 (<code>$ man man</code>) 探索就是了。</p><div class="note info">            <p>想要获取完整的用法，请查看 man page 或 help，<strong>想要获取一份按照用途分类的推荐应用清单，或许 <a class="btn" href="https://wiki.archlinux.org/index.php/List_of_applications" target="_blank" rel="noopener"><br><i class="fa fa-home fa-fw fa-lg"></i>List of applications<br></a> 对你具有重大参考价值</strong></p>          </div><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1><p>以下列出一些重要的命令，表格来源于 <a class="btn" href="https://wiki.archlinux.org/index.php/Core_utilities#Essentials" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>Essentials in Arch Linux          </a> 。</p><table><thead><tr><th>Package</th><th style="text-align:center">Utility</th><th>Description</th><th>Alternatives</th></tr></thead><tbody><tr><td>shell built-ins</td><td style="text-align:center">cd</td><td>change directory</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">ls</td><td>list directory</td><td>exa, tree</td></tr><tr><td>GNU coreutils</td><td style="text-align:center">cat</td><td>concatenate files to stdout</td><td>tac</td></tr><tr><td>GNU coreutils</td><td style="text-align:center">mkdir</td><td>make directory</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">rm</td><td>remove files or directories</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">cp</td><td>copy files or directories</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">mv</td><td>move files or directories</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">ln</td><td>make hard or symbolic links</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">chown</td><td>change file owner and group</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">chmod</td><td>change file permissions</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">dd</td><td>convert and copy a file</td><td></td></tr><tr><td>GNU coreutils</td><td style="text-align:center">df</td><td>report file system disk space usage</td><td></td></tr><tr><td>GNU tar</td><td style="text-align:center">tar</td><td>tar archiver</td><td></td></tr><tr><td>GNU less</td><td style="text-align:center">less</td><td>terminal pager</td><td></td></tr><tr><td>GNU findutils</td><td style="text-align:center">find</td><td>search files or directories</td><td></td></tr><tr><td>GNU diffutils</td><td style="text-align:center">diff</td><td>compare files line by line</td><td></td></tr><tr><td>GNU grep</td><td style="text-align:center">grep</td><td>print lines matching a pattern</td><td></td></tr><tr><td>GNU sed</td><td style="text-align:center">sed</td><td>stream editor</td><td></td></tr><tr><td>GNU gawk</td><td style="text-align:center">awk</td><td>pattern scanning and processing language</td><td></td></tr><tr><td>util-linux</td><td style="text-align:center">dmesg</td><td>print or control the kernel ring buffer</td><td></td></tr><tr><td>util-linux</td><td style="text-align:center">dmesg</td><td>print or control the kernel ring buffer</td><td>systemd journal</td></tr><tr><td>util-linux</td><td style="text-align:center">lsblk</td><td>list block devices</td><td></td></tr><tr><td>util-linux</td><td style="text-align:center">mount</td><td>mount a filesystem</td><td></td></tr><tr><td>util-linux</td><td style="text-align:center">umount</td><td>unmount a filesystem</td><td></td></tr><tr><td>util-linux</td><td style="text-align:center">su</td><td>substitute user</td><td>sudo</td></tr><tr><td>util-linux</td><td style="text-align:center">kill</td><td>terminate a process</td><td></td></tr><tr><td>procps-ng</td><td style="text-align:center">pgrep</td><td>look up processes by name or attributes</td><td></td></tr><tr><td>procps-ng</td><td style="text-align:center">ps</td><td>show information about processes</td><td></td></tr><tr><td>procps-ng</td><td style="text-align:center">free</td><td>display amount of free and used memory</td><td></td></tr></tbody></table><h1 id="搜索-searching"><a class="markdownIt-Anchor" href="#搜索-searching"></a> 搜索 (Searching)</h1><h2 id="主要命令find"><a class="markdownIt-Anchor" href="#主要命令find"></a> 主要命令：find</h2><p>find 命令的语法为</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="string">[-H]</span> <span class="string">[-L]</span> <span class="string">[-P]</span> <span class="string">[-D debugopts]</span> <span class="string">[-Olevel]</span> <span class="string">[starting-point...]</span> <span class="string">[expression]</span></span><br></pre></td></tr></table></figure><p>其中，前 5 个选项不太常用，具体含义可以查看手册，因此重点介绍<strong>搜索路径集</strong>和<strong>搜索表达式</strong>。</p><ul><li>starting-point… 用于指定<strong>搜索的起始路径集合</strong>。find 会依次<strong>递归</strong>的搜索该集合中列出的目录及其子目录。当没有给出该选项时，<strong>默认为 <code>.</code> 即当前目录</strong></li><li>expression 为搜索规则。用于指定<strong>如何匹配文件以及匹配成功后的动作</strong>。该部分是 find 的核心，同时也比较复杂。</li></ul><p>搜索表达式由以下一系列部分构成</p><ul><li>Tests</li><li>Actions</li><li>Global options</li><li>Optional options</li><li>Operators</li></ul><h3 id="示例-examples"><a class="markdownIt-Anchor" href="#示例-examples"></a> 示例 Examples</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>find -name &quot;*.java&quot;</code></td><td>在当前目录中查找以 java 结尾的文件</td></tr></tbody></table><h2 id="匹配过滤命令grep"><a class="markdownIt-Anchor" href="#匹配过滤命令grep"></a> 匹配过滤命令：grep</h2><ul><li><a href="http://man7.org/linux/man-pages/man1/grep.1.html" target="_blank" rel="noopener">greq - man page</a></li></ul><h2 id="参数化命令xargs"><a class="markdownIt-Anchor" href="#参数化命令xargs"></a> 参数化命令：xargs</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html" target="_blank" rel="noopener">xargs 命令教程</a></li></ul><h2 id="其他搜索命令"><a class="markdownIt-Anchor" href="#其他搜索命令"></a> 其他搜索命令</h2><h3 id="locate"><a class="markdownIt-Anchor" href="#locate"></a> locate</h3><p>locate命令其实是 <code>find -name</code> 的另一种写法，但是要比后者快得多，<strong>原因在于它不搜索具体目录，而是搜索一个数据库（<code>/var/lib/locatedb</code>）</strong>，这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用 locate 之前，先使用 <code>updatedb</code> 命令，手动更新数据库。</p><h3 id="whereis"><a class="markdownIt-Anchor" href="#whereis"></a> whereis</h3><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数 -b）、man 说明文件（参数 -m）和源代码文件（参数 -s）。如果省略参数，则返回所有信息。</p><h3 id="which"><a class="markdownIt-Anchor" href="#which"></a> which</h3><p>which 命令的作用是<strong>在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果</strong>。也就是说，使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><h3 id="type"><a class="markdownIt-Anchor" href="#type"></a> type</h3><p>type 命令其实不能算查找命令，它是用来区分某个命令到底是由 shell 自带的，还是由 shell 外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用 -p 参数，会显示该命令的路径，相当于 which 命令。</p><h1 id="网络-networking"><a class="markdownIt-Anchor" href="#网络-networking"></a> 网络 (Networking)</h1><h2 id="telnet"><a class="markdownIt-Anchor" href="#telnet"></a> telnet</h2><p><code>telnet localhost 8080</code></p><h2 id="nc"><a class="markdownIt-Anchor" href="#nc"></a> nc</h2><p><code>nc -u localhost 8080</code></p><h1 id="directory-listing"><a class="markdownIt-Anchor" href="#directory-listing"></a> Directory listing</h1><h2 id="ls-list-directory-contents"><a class="markdownIt-Anchor" href="#ls-list-directory-contents"></a> ls - list directory contents</h2><h3 id="常用选项"><a class="markdownIt-Anchor" href="#常用选项"></a> 常用选项</h3><table><thead><tr><th>Option</th><th>解释</th></tr></thead><tbody><tr><td><code>-a, --all</code></td><td>全部显示，包括以 <code>.</code> 开头的文件和目录</td></tr></tbody></table><h3 id="文件分类-ls-f"><a class="markdownIt-Anchor" href="#文件分类-ls-f"></a> 文件分类 <code>ls -F</code></h3><ul><li><code>@</code> means symbolic link (or that the file has extended attributes).</li><li><code>*</code> means executable.</li><li><code>=</code> means socket.</li><li><code>|</code> means named pipe.</li><li><code>&gt;</code> means door.</li><li><code>/</code> means directory.</li></ul><h1 id="special-file-types"><a class="markdownIt-Anchor" href="#special-file-types"></a> Special File Types</h1><h2 id="link-make-a-hard-link-via-the-link-syscall"><a class="markdownIt-Anchor" href="#link-make-a-hard-link-via-the-link-syscall"></a> link - Make a hard link via the link syscall</h2><figure class="highlight sh"><figcaption><span>link</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link filename linkname</span><br></pre></td></tr></table></figure><p>直接调用 syscall 创建硬链接，一般情况下不常用。</p><h2 id="ln-make-links-between-files"><a class="markdownIt-Anchor" href="#ln-make-links-between-files"></a> ln - Make links between files</h2><p>ln 用于创建链接，默认情况下创建<strong>硬链接 (hard links)</strong>，如果有 <code>-s, --symbolic</code> 参数，则创建<strong>软连接 (soft links) / 符号链接 (symbolic links)</strong>。</p><figure class="highlight sh"><figcaption><span>ln</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln [OPTION]... [-T] TARGET LINK_NAME   (1st form) <span class="comment"># 创建一个指向 TARGET 的名为 LINK_NAME 的文件</span></span><br><span class="line">ln [OPTION]... TARGET                  (2nd form) <span class="comment"># 在当前目录下创建一个指向 TARGET 的同名文件</span></span><br><span class="line">ln [OPTION]... TARGET... DIRECTORY     (3rd form) <span class="comment"># 在 DIRECTORY 目录下创建指向若干 TARGET... 的同名文件</span></span><br><span class="line">ln [OPTION]... -t DIRECTORY TARGET...  (4th form) <span class="comment"># 在 DIRECTORY 目录下创建指向若干 TARGET... 的同名文件 (同 3th form 相同)</span></span><br></pre></td></tr></table></figure><h2 id="mkdir-make-directories"><a class="markdownIt-Anchor" href="#mkdir-make-directories"></a> mkdir - Make directories</h2><p>mkdir 用于创建目录，默认情况下可以同时创建多个目录，安装 DIRECTORY 顺序依次创建。如果目录已存在，或者目录的父目录不存在则会报错。若要递归的创建目录，使用 <code>-p, --parents</code> 参数。</p><figure class="highlight sh"><figcaption><span>mkdir</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [OPTION]... DIRECTORY...</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir1 dir2 dir3 <span class="comment"># 在当前目录下创建三个子目录，目录名称依次为 dir1，dir2，dir3。</span></span><br><span class="line">mkdir -p dir/subdir/subsubdir <span class="comment"># 在当前目录下创建目录 dir，并依次创建其子目录 subdir，子目录的子目录 subsubdir。</span></span><br></pre></td></tr></table></figure><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><ul><li>sudo fuser -k 6633/tcp</li></ul><figure class="highlight accesslog"><figcaption><span>更改 U 盘名称</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo umount <span class="string">[/dev/sda1]</span></span><br><span class="line">sudo ntfslabel <span class="string">[/dev/sda1]</span> <span class="string">[newname]</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://wiki.archlinux.org/index.php/Core_utilities" target="_blank" rel="noopener">Core utilities, ArchWiki</a></li><li><a href="https://www.gnu.org/software/coreutils/manual/" target="_blank" rel="noopener">GNU coreutils - Core GNU utilities, GNU Operating System</a></li><li><a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands" target="_blank" rel="noopener">List of GNU Core Utilities commands, wikepedia</a></li><li><a href="https://en.wikipedia.org/wiki/List_of_Unix_commands" target="_blank" rel="noopener">List of Unix commands, wikipedia</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/notes/algorithm/leetcode/index.html"/>
      <url>/notes/algorithm/leetcode/index.html</url>
      
        <content type="html"><![CDATA[<p>LeetCode 的题目可以按照标签来分类，LeetCode 官方给每道题目定义了 easy/medium/hard 的难度，笔者给 tag 按照难度进行了排序，分为一星（⭐）到五星（⭐⭐⭐⭐⭐）。</p><p>刷题<strong>不建议完全按照 Tag 来刷起</strong>。但对于我这样的初学者按照顺序刷题有些苦恼，以下是我的策略：<strong>循序渐进，从简单标签到困难标签，每种标签从简单题目到困难题目。</strong></p><ol><li>从一星难度标签开始强攻。目的是<strong>建立信心</strong>，巩固基础数据结构和这门语言的对这些数据结构的支持。</li><li>开始两星难度标签。</li></ol><h1 id="题目总结"><a class="markdownIt-Anchor" href="#题目总结"></a> 题目总结</h1><p>以下是笔者刷过的题目总结：</p><table><thead><tr><th>Tag</th><th>Rank</th><th>Link</th></tr></thead><tbody><tr><td>Linked List</td><td>⭐</td><td><a href="/2019/10/15/leetcode-linked-list/">LeetCode Linked List</a></td></tr><tr><td>Array</td><td>⭐</td><td><a href="/2019/11/09/leetcode-array/">LeetCode Array</a></td></tr><tr><td>Hash Table</td><td>⭐</td><td></td></tr><tr><td>Math</td><td>⭐</td><td></td></tr><tr><td>String</td><td>⭐</td><td></td></tr></tbody></table><p>图、树、堆、栈、链表、哈希表、记忆搜索、动态规划、指针法、并查集<br>DFS + memo 322<br>Backtracking 22<br>DP (DP &lt;–&gt; DFS + memo) 55<br>BFS 286<br>Partition 86<br>Greedy 421<br>Sliding Window 15<br>Divide and Conquer<br>Graph 207 743<br>Tree<br>Binary Search</p><h1 id="刷题模板"><a class="markdownIt-Anchor" href="#刷题模板"></a> 刷题模板</h1><p>以下是一些刷题模板</p><ul><li><a href="/2019/11/12/algo-binary-search/">Binary Search Template</a></li></ul><h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1><ul><li><a href="https://www.zhihu.com/question/36738189" target="_blank" rel="noopener">LeetCode按照怎样的顺序来刷题比较好？</a></li></ul><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><ul><li>递归找中位数，边界条件如何选？？全闭 or 半开半闭。应该属于binary search 问题。</li></ul><h1 id="未单独成文的-tag"><a class="markdownIt-Anchor" href="#未单独成文的-tag"></a> 未单独成文的 Tag</h1><h2 id="array"><a class="markdownIt-Anchor" href="#array"></a> Array</h2><h2 id="hash-table"><a class="markdownIt-Anchor" href="#hash-table"></a> Hash Table</h2><h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h2><table><thead><tr><th>ID</th><th>题目</th><th>思路</th></tr></thead><tbody><tr><td>647</td><td>回文子串</td><td>二维 DP<br>中心法</td></tr><tr><td>5</td><td>最长回文子串</td><td>二维 DP<br>中心法</td></tr></tbody></table><h2 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h2><table><thead><tr><th>ID</th><th>题目</th><th>思路</th></tr></thead><tbody></tbody></table><ol start="69"><li>x 的平方根</li></ol><ul><li>二分查找 + 注意溢出</li><li>牛顿法</li></ul><h2 id="tree"><a class="markdownIt-Anchor" href="#tree"></a> Tree</h2><ol start="617"><li>合并二叉树</li><li>路径总和 III  等待复习 （前缀和，双重递归等）</li></ol><h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2><table><thead><tr><th>ID</th><th>题目</th><th>思路</th></tr></thead><tbody><tr><td>53</td><td>最大子序和</td><td><code>dp[k] = Math.max(dp[k-1], 0) + nums[k]</code></td></tr><tr><td>121</td><td>买卖股票的最佳时机</td><td></td></tr><tr><td>70</td><td>爬楼梯</td><td></td></tr></tbody></table><h2 id="回溯法"><a class="markdownIt-Anchor" href="#回溯法"></a> 回溯法</h2><ol start="79"><li>单词搜索</li><li>括号生成</li></ol><h2 id="广度搜索"><a class="markdownIt-Anchor" href="#广度搜索"></a> 广度搜索</h2><ol start="994"><li>腐烂橘子</li></ol><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><table><thead><tr><th>ID</th><th>题目</th><th>思路</th></tr></thead><tbody><tr><td>56</td><td>合并区间</td><td>排序合并</td></tr></tbody></table><h1 id="问题模板"><a class="markdownIt-Anchor" href="#问题模板"></a> 问题模板</h1><h2 id="top-k-问题"><a class="markdownIt-Anchor" href="#top-k-问题"></a> Top-k 问题</h2><p>问题描述</p><ul><li>求给定数据中前 K 大的数</li><li>求给定数据中前 K 小的数</li></ul><p>解决思路</p><ol><li>数据排序后（降序）取前 <em>k</em> 个元素。</li><li>维护一个大小为 <em>k</em> 的堆。</li><li>BFPRT 算法，基于快速排序。</li></ol><p>LeetCode 题目</p><ul><li><ol start="692"><li>前K个高频单词</li></ol></li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><h2 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h2><h3 id="二叉树镜像"><a class="markdownIt-Anchor" href="#二叉树镜像"></a> 二叉树镜像</h3><figure class="highlight java"><figcaption><span>MirrorTree</span><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode tmp = mirrorTree(root.left);</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称的二叉树"><a class="markdownIt-Anchor" href="#对称的二叉树"></a> 对称的二叉树</h3><figure class="highlight java"><figcaption><span>isSymmetric</span><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp;</span><br><span class="line">               isSymmetric(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序打印二叉树"><a class="markdownIt-Anchor" href="#层序打印二叉树"></a> 层序打印二叉树</h3><figure class="highlight java"><figcaption><span>LevelOrder</span><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;result[i] = res.get(i);&#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序打印二叉树-ii"><a class="markdownIt-Anchor" href="#层序打印二叉树-ii"></a> 层序打印二叉树 II</h3><figure class="highlight java"><figcaption><span>LevelOrder</span><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.remove();</span><br><span class="line">                result.get(level).add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bst-的后序遍历序列"><a class="markdownIt-Anchor" href="#bst-的后序遍历序列"></a> BST 的后序遍历序列</h3><figure class="highlight java"><figcaption><span>VerifyPostorder</span><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">while</span> (postorder[i] &lt; postorder[end]) i++;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (postorder[i] &gt; postorder[end]) i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (i == end) &amp;&amp;</span><br><span class="line">                recur(postorder, start, j - <span class="number">1</span>) &amp;&amp;</span><br><span class="line">                recur(postorder, j, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>如果处理二叉树的遍历序列，首先应该找到根结点，然后基于根结点把遍历序列拆分为左子树对应的子序列和右子树对应的子序列，最后递归的处理这两个子序列。</p>          </div><h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><h3 id="顺时针打印矩阵"><a class="markdownIt-Anchor" href="#顺时针打印矩阵"></a> 顺时针打印矩阵</h3><figure class="highlight java"><figcaption><span>SpiralMatrix</span><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>C</title>
      <link href="/notes/programming/c/index.html"/>
      <url>/notes/programming/c/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1><p>C 语言标准层面没有明确定义基本数据类型的大小，只能确定 sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)。</p><p>具体某种类型的大小与编译器和系统有关，具体来说和实现采用的<strong>数据模型</strong>有关，</p><p><img src="primitive-type-bits.svg" alt="primitive-type-bits"></p><ul><li>LLP64: Microsoft Windows (x86-64 and IA-64) using Visual C++; and MinGW</li><li>LP64: Most Unix and Unix-like systems, e.g., Solaris, Linux, BSD, macOS. Windows when using Cygwin; z/OS</li></ul><div class="note info">            <p>当数据类型的位数重要时：</p><ul><li>请使用 stdint.h 中定义的 fixed-size types，例如 int8_t、uint32_t 等。</li><li>或使用 sizeof() 计算位数。</li></ul>          </div><h1 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1><p>我们知道，每个变量代表一个存储位置，并且每个存储位置都有一个可以使用 <code>＆</code> 运算符进行访问的内存地址，该地址表示内存中的地址。</p><p>指针就是一个变量，该变量存储的值为另一个变量的地址。也就是说，指针就是一个内存地址。</p><p>关于指针：</p><ul><li><strong>总是将指针初始化为 NULL 是一个好习惯</strong>！</li><li>指针可以进行加减运算（<code>++</code>、<code>--</code>、<code>+</code>、<code>-</code>），其加减的<strong>单位为指向数据类型的大小</strong>。</li><li>指针与普通类型一样也可以存储在数组中，成为指针数组。</li><li>指针与普通类型一样也可以被另一个指针指向，构成<strong>多级指针</strong>。</li><li>指针可以作为参数传给函数，可以在调用函数时改变该参数的值。</li><li>指针可以作为函数返回值，<strong>一般用于动态内存分配</strong>时返回该堆指针，需要注意若该指针指向局部变量，则在函数退出时，该变量也不复存在。</li></ul><h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1><h2 id="数组初始化"><a class="markdownIt-Anchor" href="#数组初始化"></a> 数组初始化</h2><ol><li>局部数组未初始化时，其值为随机值。</li><li>全局或静态数组未初始化时，其值 NUL 或 0。</li></ol><div class="note info">            <p>当数组初始化之后，会将未初始化的位置设置为 NUL 或 0，应当养成每次都初始化数组的好习惯。</p>          </div><figure class="highlight c"><figcaption><span>init.c</span><a href="/downloads/code/c/array/init.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_int</span><span class="params">(<span class="keyword">int</span>* str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_char</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr_g[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr_s[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">5</span>] = { <span class="number">0</span> };</span><br><span class="line">    <span class="keyword">char</span> arr3[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> arr4[<span class="number">5</span>] = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">    dump_int(arr_g); <span class="comment">//(int) 0 0 0 0 0</span></span><br><span class="line">    dump_int(arr_s); <span class="comment">//(int) 0 0 0 0 0</span></span><br><span class="line">    dump_int(arr1); <span class="comment">// (int)  0 0 1346658496 21995 407207840</span></span><br><span class="line">    dump_int(arr2); <span class="comment">// (int)  0 0 0 0 0</span></span><br><span class="line">    dump_char(arr3); <span class="comment">// (char)  NUL NUL -32 -124 t</span></span><br><span class="line">    dump_char(arr4); <span class="comment">// (char) a b c NUL NUL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_int</span><span class="params">(<span class="keyword">int</span>* str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(int) "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">5</span>; ++n) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *(str + n));</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_char</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(char) "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">5</span>; ++n) {</span><br><span class="line">        <span class="keyword">if</span> (str[n] &lt; <span class="number">0</span> || str[n] &gt; <span class="number">127</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, str[n]);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (str[n] == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NUL "</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, str[n]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><h2 id="表示方式"><a class="markdownIt-Anchor" href="#表示方式"></a> 表示方式</h2><p>C 语言使用<strong>字符数组</strong>来表示字符串，字符数组和字符串之间的区别在于<strong>字符串以特殊字符 <code>\0</code> 结尾</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">6</span>] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;; <span class="comment">// equivalent to str</span></span><br></pre></td></tr></table></figure><p><strong>字符指针</strong>在某种程度上也可以表示字符串，这并不惊讶，因为字符数组名本身就是一个常指针。</p><p>char* str1 和 char str2[] 都可以表示字符串，然而两者具有很大区别：</p><ul><li>str1 是一个指向 char 变量的指针变量，指向一个字符串常量（其位于常量区），指针变量的值可以改变，而字符串常量的值不能改变。</li><li>str2 是一个指针常量，指向一个字符数组，指针常量值不可改变，但数组内容可以改变。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">10</span>] = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1: %s\n"</span>, str1); <span class="comment">// hello</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2: %s\n"</span>, str2); <span class="comment">// world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//str1[0] = 'W'; // Segment Fault</span></span><br><span class="line">    str2[<span class="number">0</span>] = <span class="string">'W'</span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2: %s\n"</span>, str2); <span class="comment">// World</span></span><br><span class="line"></span><br><span class="line">    str1 = <span class="string">"hello c language"</span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1: %s\n"</span>, str1); <span class="comment">// hello c language</span></span><br><span class="line">    str1 = str2; <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1: %s\n"</span>, str1); <span class="comment">// World</span></span><br><span class="line">    <span class="comment">//str2 = "hello"; // Error，expression must be a modifiable lvalue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，str1 和 str2 位于不同的内存区。显然，str2 位于栈，而 str1 同全局变量、堆内存一样位于堆中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">"C"</span>; <span class="comment">// address: 0x55a607eb1010</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str1 = <span class="string">"hello"</span>;   <span class="comment">// address: 0x55a607eaf004</span></span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">10</span>] = <span class="string">"world"</span>;  <span class="comment">// address: 0x7ffc2940e042</span></span><br><span class="line">    <span class="keyword">char</span>* str3 = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">// address: 0x55a609b752a0</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stringh-头文件"><a class="markdownIt-Anchor" href="#stringh-头文件"></a> string.h 头文件</h2><p>通常字符串函数都位于 <code>string.h</code> 头文件中。该头文件引入了以下内容：</p><ul><li>一个变量：<code>size_t</code> 表示无符号整数</li><li>一个宏：<code>NULL</code> 表示空字符串常量</li><li>若干函数：主要可以分为两类：<ol><li>以 <code>mem</code> 开头的操作内存字节的函数</li><li>以 <code>str</code> 开头的操作字符的函数</li></ol></li></ul><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>strlen(str)</td><td>计算 str 长度，不包括 NUL 字符。</td></tr><tr><td>strcat(dst, src)</td><td>将 src 加到 dst 后面。</td></tr><tr><td>strcmp(fir, sec)</td><td>相同为 0，否则返回第一个不匹配字符的 ASCII 值的差，即 fir - sec。</td></tr><tr><td>strcpy(dst, src)</td><td>将 src 拷贝到 dst，遇到 NUL 字符停止。</td></tr><tr><td>strncpy(dst, src, n)</td><td>将 src 的 n 字节拷贝到 dst。<br>如果 src 的前 n 字节不包括 NUL 字符，则 dst 将不会有 NUL 结束符！<br>如果 src 不足 n 字节，则剩余空间使用 NUL 字符补齐。</td></tr><tr><td>memcpy(dst, src, n)</td><td>将 src 的 n 字节拷贝到 dst。</td></tr><tr><td>memset(s, c, n)</td><td>将 s 的 n 字节设为 c。</td></tr></tbody></table><p>具有相同后缀的两种函数功能相似，但稍有不同。其中 <code>mem</code> 系列函数将字符序列视为字节操作，而 <code>str</code> 系列函数将字符序列视为字符串操作。逻辑上而言 <code>mem</code> 系列表达的语义更加底层。</p><h2 id="字符串拷贝"><a class="markdownIt-Anchor" href="#字符串拷贝"></a> 字符串拷贝</h2><p>以 <code>memcpy</code> vs <code>strcpy</code> 作为例子。</p><figure class="highlight c"><figcaption><span>str_mem_cpy.c</span><a href="/downloads/code/c/string/str_mem_cpy.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">5</span>] = { <span class="string">'s'</span>, <span class="string">'a'</span>, <span class="string">'\0'</span>, <span class="string">'c'</span>, <span class="string">'h'</span> };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> membuff[<span class="number">5</span>] = { <span class="number">0</span> };</span><br><span class="line">    <span class="keyword">char</span> strbuff[<span class="number">5</span>] = { <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strbuff, s);</span><br><span class="line">    <span class="built_in">memcpy</span>(membuff, s, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    dump(membuff); <span class="comment">// 73 61 00 63 68  sa ch</span></span><br><span class="line">    dump(strbuff); <span class="comment">// 73 61 00 00 00  sa</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span>* p = str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">5</span>; ++n) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2.2x "</span>, *p);</span><br><span class="line">        ++p;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">    p = str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">5</span>; ++n) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, *p ? *p : <span class="string">' '</span>);</span><br><span class="line">        ++p;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在网络编程时，应当使用 memcpy 拷贝数据。</p><h2 id="字符串格式化"><a class="markdownIt-Anchor" href="#字符串格式化"></a> 字符串格式化</h2><p>除了 <code>memcpy</code> 和 <code>strcpy</code> 以及其系列函数外，<code>sprintf</code> 函数也常用于字符串拷贝，但该函数操作的源对象不限于字符串，源对象可以是字符串、也可以是任意基本类型的数据。因此 <code>sprintf</code> 主要是实现将其他数据类型转换为字符串功能。同时，由于该函数属于 printf 家族函数，因此也可以完成字符串拼接效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> path[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(path, <span class="string">"/proc/%d/uid_map"</span>, pid);</span><br></pre></td></tr></table></figure><h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1><h2 id="内存布局与字节对齐"><a class="markdownIt-Anchor" href="#内存布局与字节对齐"></a> 内存布局与字节对齐</h2><p>结构体字节对齐的细节和具体的编译器实现相关，但一般来说遵循 3 个准则：</p><ul><li>结构体变量的首地址能够被其最宽基本类型成员的大小(sizeof)所整除。</li><li>结构体每个成员相对结构体首地址的偏移量 offset 都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节。</li><li>结构体的总大小 sizeof 为结构体最宽基本成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</li></ul><p>直接使用 <code>pragma pack</code> 预处理宏可以改变结构体的字节对齐方式：</p><ul><li><code>#pragma pack(n)</code>：结构体将按照 n 个字节对齐，其取值为 1、2、4、8、16，默认是 8。</li><li><code>#pragma pack(1)</code>：结构体没有填充字节，实现空间“无缝存储”，这对跨平台传输数据来说是友好和兼容的。</li></ul><p>如果只想改变个别结构体的字节对齐方式，可以使用 GCC 编译器指定结构体<strong>类型属性 (Type Attribute)</strong> 为 packed，即： <code>__attribute__((__packed__))</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">short</span> s; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">//8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof() is 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nopadding</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">short</span> s; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">//8</span></span><br><span class="line">&#125; __attribute__((__packed__));</span><br><span class="line"><span class="comment">// sizeof() is 15</span></span><br></pre></td></tr></table></figure><div class="note info">            <p><code>__attribute__</code> 必须紧挨着 struct 关键字或者结构体 <code>}</code> 之后，否则将会报错或不起作用。</p>          </div><h1 id="存储级别关键字"><a class="markdownIt-Anchor" href="#存储级别关键字"></a> 存储级别关键字</h1><h2 id="static-关键字"><a class="markdownIt-Anchor" href="#static-关键字"></a> static 关键字</h2><ul><li><strong>静态局部变量</strong>使用 static 修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为 0，且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。</li><li><strong>静态全局变量</strong>仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。</li><li><strong>静态函数</strong>只能在声明它的文件中可见，其他文件不能引用该函数</li></ul><div class="note info">            <p>static 关键字标识该变量/函数作用域为本“模块”，C 语言以文件的方式来组织模块。</p><p>C++ 和 Java 的类成员变量/函数被 static 修饰时则为类共享，因为此时程序以类的方式组织模块。</p>          </div><h2 id="const-关键字"><a class="markdownIt-Anchor" href="#const-关键字"></a> const 关键字</h2><p>指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）。</p><h2 id="volatile-关键字"><a class="markdownIt-Anchor" href="#volatile-关键字"></a> volatile 关键字</h2><p>指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc/index.html#SEC_Contents" target="_blank" rel="noopener">GNU Compiler Collection</a></li><li><a href="https://en.m.wikipedia.org/wiki/64-bit_computing#64-bit_data_models" target="_blank" rel="noopener">64 位数据模型</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/notes/tools/git/index.html"/>
      <url>/notes/tools/git/index.html</url>
      
        <content type="html"><![CDATA[<p>本文基于 Git 官方参考书籍 <a class="btn" href="https://git-scm.com/book/en/v2/" target="_blank" rel="noopener">            <i class="fa fa-book fa-fw fa-lg"></i>Pro Git          </a> 总结提炼而成，详细的实例和用法请参见原书籍。本文同样也不是 Pro Git 的中文翻译，如果想阅读中文版，可以选择 <a class="btn" href="https://gitee.com/progit/" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>Pro Git 中文版          </a></p><p>命令|解释<br>git config|配置 git 参数，包含系统级、用户级和仓库级三种等级。<br>git diff|显示当前工作树中还未提交的更改</p><h1 id="git-简介"><a class="markdownIt-Anchor" href="#git-简介"></a> Git 简介</h1><h2 id="版本控制系统-vcs"><a class="markdownIt-Anchor" href="#版本控制系统-vcs"></a> 版本控制系统 (VCS)</h2><p>版本控制系统大致可以分为三种：</p><ul><li>本地版本控制系统 (Local Version Control Systems, LVCS)</li><li>集中式版本控制系统 (Centralized Version Control Systems, CVCS)</li><li>分布式版本控制系统 (Distributed Version Control System, DVCS)</li></ul><div class="tabs" id="vcs"><ul class="nav-tabs"><li class="tab active"><a href="#vcs-1">本地版本控制系统</a></li><li class="tab"><a href="#vcs-2">集中式版本控制系统</a></li><li class="tab"><a href="#vcs-3">分布式版本控制系统</a></li></ul><div class="tab-content"><div class="tab-pane active" id="vcs-1"><p><img src="index/local.png" alt="local"></p></div><div class="tab-pane" id="vcs-2"><p><img src="index/centralized.png" alt="centralized"></p></div><div class="tab-pane" id="vcs-3"><p><img src="index/distributed.png" alt="distributed"></p></div></div></div><h2 id="git-特性"><a class="markdownIt-Anchor" href="#git-特性"></a> Git 特性</h2><ul><li>直接记录快照，而非差异比较</li><li>近乎所有操作都是本地执行</li><li>Git 保证完整性 (使用 SHA-1 hash 计算校验和)</li><li>Git 一般只添加数据</li></ul><h2 id="工作区域和文件状态"><a class="markdownIt-Anchor" href="#工作区域和文件状态"></a> 工作区域和文件状态</h2><p>Git 仓库的文件有三种状态：</p><ol><li>已修改 (modified) 表示修改了某个文件，但还没有提交保存；</li><li>已暂存 (staged) 表示把已修改的文件放在下次提交时要保存的清单中；</li><li>已提交 (committed) 表示该文件已经被安全地保存在本地数据库中了。</li></ol><p>由此我们看到 Git 管理项目时，文件流转的三个工作区域为：</p><ol><li>工作目录 (Working Directory)</li><li>暂存区域 (Staging Area)</li><li>Git 仓库 (<code>.git</code> directory or Repository)</li></ol><p><img src="index/areas.png" alt="areas"></p><p><strong>从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录</strong>。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，工作目录也是我们可以看到的目录，接下来就可以在工作目录中对这些文件进行编辑。</p><p><strong>所谓的暂存区域只不过是个简单的文件</strong>，一般都放在 .git 目录中。在 Git 中也把这个文件叫做<strong>索引文件 (index)</strong>。</p><p><strong>Git 仓库是用来保存元数据和对象数据库的地方</strong>，该目录非常重要。每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p><h2 id="git-配置"><a class="markdownIt-Anchor" href="#git-配置"></a> Git 配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量存储在三个不同的位置，因此具有三种级别，<strong>每一个级别会覆盖上一级别的配置。</strong></p><table><thead><tr><th>文件</th><th>作用域</th><th>命令行参数参数</th></tr></thead><tbody><tr><td><code>/etc/gitconfig</code></td><td>系统上每一个用户及他们仓库的通用配置</td><td><code>git config --system</code></td></tr><tr><td><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code></td><td>当前用户配置</td><td><code>git config --global</code></td></tr><tr><td><code>.git/config</code></td><td>当前仓库配置</td><td><code>git config [--local]</code></td></tr></tbody></table><p>当安装完 Git 应该做的第一件事就是设置你的<strong>用户名称</strong>与<strong>邮件地址</strong>。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"John Doe"</span></span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。或者通过 <code>git config &lt;key&gt;</code> 来检查某一项配置，如 <code>git config user.email</code>。</p><div class="note info">            <p>如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。<strong>当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</strong></p>          </div><h2 id="获取帮助"><a class="markdownIt-Anchor" href="#获取帮助"></a> 获取帮助</h2><p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --<span class="built_in">help</span></span><br><span class="line">man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><h1 id="git-状态迁移"><a class="markdownIt-Anchor" href="#git-状态迁移"></a> Git 状态迁移</h1><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://education.github.com/git-cheat-sheet-education.pdf" target="_blank" rel="noopener">GIT CHEAT SHEET</a></li><li><a href="http://www.flutterbys.com.au/stats/tut/tut19.1.html" target="_blank" rel="noopener">Tutorial 19.1 - Git and version control</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/notes/programming/java/index.html"/>
      <url>/notes/programming/java/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="java-basics"><a class="markdownIt-Anchor" href="#java-basics"></a> Java Basics</h2><p>对于 C/C++ 的使用者来说，<a class="btn" href="/2019/11/21/java-basics/">            <i class="fa-fw fa-lg"></i>Java Basics          </a> 是很容易的，他们拥有相同的祖先，拥有近似的语法。相比较 C++ 而言，Java 删去了指针和内存管理等容易出错的特性，因而被戏称为 <code>C++--</code>，这带来了相当的好处，但也做了一些牺牲。<strong>对于有 C++ 基础的程序员，经常对比思考 C++ 和 Java 对某种方式的实现差异，或许能带来对该技术更深层次的理解。</strong>。</p><h2 id="java-object-oriented-programming-oop"><a class="markdownIt-Anchor" href="#java-object-oriented-programming-oop"></a> Java Object Oriented Programming (OOP)</h2><p>如果说 Java Basics 里面描述了一门编程语言应该有的样子，那么 <a class="btn" href="/2019/11/27/java-oop/">            <i class="fa-fw fa-lg"></i>Java OOP          </a> 无疑才是 Java 的亮点。 <strong>相比于 C++，Java 是一种更纯粹的面向对象程序设计语言。我们应当能体会到：在 Java 中 (几乎) 一切都是对象。</strong></p><div class="note info">            <p>尽管 C++ 和 Java 都是混合型语言。C++ 允许多种编程风格主要是因为它需要兼容过程型的 C 语言，但 Java 语言的设计者假设我们只进行面向对象程序设计。也就是说，我们在进行 Java 编程设计之前，最好将思维转换到面向对象的世界来。否则，你可能只是想逃避 C/C++ 程序编写的复杂，如果是这样的话，我推荐你使用 Python，因为确实 OOP 和 Java 不是每个人都需要的。</p>          </div><h2 id="java-containers-in-depth"><a class="markdownIt-Anchor" href="#java-containers-in-depth"></a> Java Containers in Depth</h2><p>容器的作用就是持有对象 (holding object)。几乎所有的 Java 大型程序，都需要与容器打交道，因为我们总是需要持有我们的对象。除了数组这种“固定大小的容器”，<strong>Java 提供了一套相当完整的数据类来让我们组织我们的数据结构。</strong> 学习熟悉这些类库的使用固然重要，但更重要的是挖掘容器背后深层的思想。通过阅读 Java 的源码，我们惊讶的发现，原来 <a class="btn" href="/2019/11/27/java-containers/">            <i class="fa-fw fa-lg"></i>Java Containers          </a> 背后是由复杂、优美而高效的数据结构来支撑的。</p><h2 id="java-io"><a class="markdownIt-Anchor" href="#java-io"></a> Java I/O</h2><p>对 IO 进行简单的编程是非常容易的，只需要几个类和方法就可以完成输入输出操作，但<strong>高效、可移植的 IO 编程</strong>非常困难，尤其是还需要处理很多不同的字符集，因此也导致了实际应用中 <a class="btn" href="/2019/10/10/java-io/">            <i class="fa-fw fa-lg"></i>Java I/O          </a> 成为了一个相当复杂的编程对象。</p><h2 id="java-concurrency-in-practice"><a class="markdownIt-Anchor" href="#java-concurrency-in-practice"></a> Java Concurrency in Practice</h2><a class="btn" href="/2019/10/21/java-concurrency/">            <i class="fa-fw fa-lg"></i>Java Concurrency          </a><h2 id="java-virtual-machine-jvm"><a class="markdownIt-Anchor" href="#java-virtual-machine-jvm"></a> Java Virtual Machine (JVM)</h2><a class="btn" href="/2019/11/28/java-virtual-machine/">            <i class="fa-fw fa-lg"></i>JVM          </a><h2 id="networking-in-java"><a class="markdownIt-Anchor" href="#networking-in-java"></a> Networking in Java</h2><p>如果说 Java I/O 和 Java Concurrency 令你头疼的话，那么现在 <a class="btn" href="/2019/10/22/java-networking/">            <i class="fa-fw fa-lg"></i>Java Networking          </a> 将会同时涉及这两种技术，不仅如此，Java 的网络编程还将涉及更多概念，包括网络协议，操作系统等等。但也别太沮丧，<strong>Java 的网络编程仅涉及传输层及其以上层</strong>，Java 将 C 语言实现的底层网络功能做了进一步<strong>限制与封装</strong>，提供了简单易用的 API。对于大部分场景，我们使用 UDP 或 TCP 协议 (或者基于 UDP 或 TCP 的协议) 已经足够，甚至我们可以使用成熟的网络框架 <a class="btn" href="/2019/11/18/netty/">            <i class="fa-fw fa-lg"></i>Netty          </a> 来进一步优化我们的工作。</p><div class="note info">            <p>Java 的跨平台特性使得其不可能深入底层，对于网络套接字的限制我认为是一种明智的做法。如果程序员需要定制 Ping，实现网络嗅探等功能，那么直接使用 C 语言是更好的选择。反而，大多数情况我们都是在传输层以上工作，提供这些类库和框架已然足够。由于 Java 的网络库只是一种高级的封装，因此若想学好网络编程，请务必从操作系统和 C 语言开始。</p>          </div><h2 id="java-related"><a class="markdownIt-Anchor" href="#java-related"></a> Java Related</h2><p>A curated list of awesome Java frameworks, libraries and software.</p><h3 id="ide"><a class="markdownIt-Anchor" href="#ide"></a> IDE</h3><a class="btn" href="https://www.jetbrains.com/help/idea/getting-started.html" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>IntelliJ IDEA          </a><h3 id="build"><a class="markdownIt-Anchor" href="#build"></a> Build</h3><a class="btn" href="https://maven.apache.org/guides/index.html" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>Maven          </a><a class="btn" href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>Gradle          </a><ul><li><a href="https://search.maven.org/" target="_blank" rel="noopener">Central Repository</a></li></ul><h3 id="jdk-tools"><a class="markdownIt-Anchor" href="#jdk-tools"></a> JDK Tools</h3><a class="btn" href="https://docs.oracle.com/javase/8/docs/technotes/tools/" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>JDK 8 Tools and Utilities          </a><a class="btn" href="https://docs.oracle.com/en/java/javase/11/tools/" target="_blank" rel="noopener">            <i class="fa fa-home fa-fw fa-lg"></i>JDK 11 Tools Reference          </a><h3 id="logging"><a class="markdownIt-Anchor" href="#logging"></a> Logging</h3><p>Logging Shims</p><ul><li>Apache Commons Logging</li><li>SLF4J (Recommended)</li></ul><p>Logging Frameworks</p><ul><li>Java Util Logging</li><li>Apache Log4J (Not Recommended)</li><li>Logback</li><li>Apache Log4J2</li></ul><h3 id="messaging"><a class="markdownIt-Anchor" href="#messaging"></a> Messaging</h3><h3 id="networking"><a class="markdownIt-Anchor" href="#networking"></a> Networking</h3><p>Libraries for building network servers.<br>Dubbo - High-performance RPC framework.<br>Netty - Framework for building high-performance network applications.</p><h3 id="orm"><a class="markdownIt-Anchor" href="#orm"></a> ORM</h3><p>APIs that handle the persistence of objects.</p><h3 id="server"><a class="markdownIt-Anchor" href="#server"></a> Server</h3><p>Servers specifically used to deploy applications.</p><ul><li>Apache Tomcat - Robust, all-round server for Servlet and JSP.</li><li>Jetty - Provides a Web server and javax.servlet container, plus support for HTTP/2, WebSocket, OSGi, JMX, JNDI, JAAS and many other integrations.</li></ul><h3 id="search"><a class="markdownIt-Anchor" href="#search"></a> Search</h3><p>Engines that index documents for search and analysis.</p><ul><li>Elasticsearch - Distributed, multitenant-capable, full-text search engine with a RESTful web interface and schema-free JSON documents.</li></ul><h3 id="security"><a class="markdownIt-Anchor" href="#security"></a> Security</h3><p>Libraries that handle security, authentication, authorization or session management.</p><ul><li>Apache Shiro - Performs authentication, authorization, cryptography and session management.</li></ul><h2 id="resources"><a class="markdownIt-Anchor" href="#resources"></a> Resources</h2><h3 id="awesome-lists"><a class="markdownIt-Anchor" href="#awesome-lists"></a> Awesome Lists</h3><ul><li><a href="https://github.com/akullpp/awesome-java" target="_blank" rel="noopener">Awesome Java</a></li></ul><h3 id="influential-books"><a class="markdownIt-Anchor" href="#influential-books"></a> Influential Books</h3><p>Books that made a big impact and are still worth reading.</p><ul><li>Core Java Volume I – Fundamentals</li><li>Core Java, Volume II – Advanced Features</li><li>Effective Java (3rd Edition)</li><li>Java Concurrency in Practice</li><li>Thinking in Java</li></ul><h3 id="websites"><a class="markdownIt-Anchor" href="#websites"></a> Websites</h3><ul><li><a href="https://java-design-patterns.com/" target="_blank" rel="noopener">Design patterns implemented in Java</a></li></ul><h3 id="官方"><a class="markdownIt-Anchor" href="#官方"></a> 官方</h3><ul><li>JSR 133</li><li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">The Java Memory Model</a></li></ul><h3 id="面经"><a class="markdownIt-Anchor" href="#面经"></a> 面经</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/83978358" target="_blank" rel="noopener">投行 Java 面试必问的多线程和并发问题</a></li><li><a href="https://zhuanlan.zhihu.com/p/84106079" target="_blank" rel="noopener">Java 面试</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>OOP &amp; Design Patterns</title>
      <link href="/notes/programming/design-patterns/index.html"/>
      <url>/notes/programming/design-patterns/index.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Each pattern describes a <strong>problem</strong> which occurs over and over again in our environment, and then describes the core of the <strong>solution</strong> to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice.<br>–  Christopher Alexander</p>            <i class="fa fa-quote-right"></i>          </blockquote><h1 id="面向对象编程思想"><a class="markdownIt-Anchor" href="#面向对象编程思想"></a> 面向对象编程思想</h1><p>面向对象程序设计（Object-oriented programming, OOP）是种<strong>具有对象概念的程序编程典范</strong>，同时也是一种程序开发的抽象方针。对象可能包括：</p><ul><li>字段形式的数据 (data in the form of field)，通常称为属性 (attributes or properties)</li><li>过程形式的代码 (code in the form of procedures )，通常称为方法/函数 (methods or functions)</li></ul><p>对象的典型特性是：对象的方法可以访问并修改与该对象关联的数据。对象有一个 this 或者 self 的概念，用来表示该对象自身。</p><p>传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中计算机程序会被设计成彼此相关的对象，其中每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。</p><p>OOP 语言多种多样，但是最受欢迎的语言是<strong>基于类 (class based)</strong> 的，这意味着<strong>对象是类的实例</strong> (objects are instances of classes)，同时类也决定了对象的类型。</p><p>许多广泛使用的编程语言（例如 C++，Java，Python 等）是多范例 (multi-paradigm) 的，这意味着他们或多或少地支持面向对象的编程，通常情况下会与命令式，过程式编程结合使用。在使用某门语言中，采用面向对象设计的程序员应当有意识的转变思维到面向对象范式 (OOP paradigm)，其中 Java 是一种重要而纯粹的面向对象语言，Java 语言也强烈建议程序员只进行面向对象的程序开发。</p><h2 id="三大特性"><a class="markdownIt-Anchor" href="#三大特性"></a> 三大特性</h2><h3 id="封装-encapsulation"><a class="markdownIt-Anchor" href="#封装-encapsulation"></a> 封装 Encapsulation</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为<strong>向上转型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><h3 id="多态-polymorphism"><a class="markdownIt-Anchor" href="#多态-polymorphism"></a> 多态 Polymorphism</h3><p>多态分为编译时多态和运行时多态：</p><ul><li>编译时多态主要指方法的重载 (Overload)</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件：</p><ul><li>继承</li><li>覆盖/重写 (Override)</li><li>向上转型</li></ul><h1 id="统一建模语言"><a class="markdownIt-Anchor" href="#统一建模语言"></a> 统一建模语言</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p><h2 id="类图"><a class="markdownIt-Anchor" href="#类图"></a> 类图</h2><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。</p><p><strong>在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示</strong>。</p><ul><li>类名（Name）是一个字符串，例如，Student。</li><li>属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：<code>[可见性]属性名:类型[=默认值]</code></li><li>操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：<code>[可见性]名称(参数列表)[:返回类型]</code></li></ul><div class="note info">            <p>“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。</p>          </div><p>除了常规类，还有一些特殊的类常常用于面向对象编程语言中，包括：接口、抽象类等。类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。不同的编程语言有不同的模型，Java 中主要使用的类图如下。</p><p><img src="index/types.png" alt="types"></p><h2 id="类间关系"><a class="markdownIt-Anchor" href="#类间关系"></a> 类间关系</h2><p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p><table><thead><tr><th style="text-align:center">关系</th><th style="text-align:center">耦合度</th><th style="text-align:center">代码形式</th><th style="text-align:center">关系</th></tr></thead><tbody><tr><td style="text-align:center">泛化 (Generalization)</td><td style="text-align:center">⭐⭐⭐⭐⭐</td><td style="text-align:center">继承</td><td style="text-align:center">is-a</td></tr><tr><td style="text-align:center">实现 (Realization)</td><td style="text-align:center">⭐⭐⭐⭐⭐</td><td style="text-align:center">接口与实现</td><td style="text-align:center">like-a</td></tr><tr><td style="text-align:center">组合 (Composition)</td><td style="text-align:center">⭐⭐⭐⭐</td><td style="text-align:center">成员变量</td><td style="text-align:center">contains-a</td></tr><tr><td style="text-align:center">聚合 (Aggregation)</td><td style="text-align:center">⭐⭐⭐</td><td style="text-align:center">成员变量</td><td style="text-align:center">has-a</td></tr><tr><td style="text-align:center">关联 (Association)</td><td style="text-align:center">⭐⭐</td><td style="text-align:center">成员变量</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">依赖 (Dependency)</td><td style="text-align:center">⭐</td><td style="text-align:center">方法的参数、局部变量</td><td style="text-align:center">use-a</td></tr></tbody></table><div class="note info">            <p><strong>一般关联 vs 聚合 vs 组合</strong>：三者都是广义上的关联关系，但逻辑上拥有不同的耦合度，即：<code>组合 &gt; 聚合 &gt; 关联</code>。不过从代码的角度看都是<strong>成员变量</strong>的表示形式。三者均可以表示为 A 类的成员变量保存了关联 B 类的一个引用。</p>          </div><h3 id="泛化-generalization"><a class="markdownIt-Anchor" href="#泛化-generalization"></a> 泛化 (Generalization)</h3><p>泛化 (Generalization) 表示一般与特殊的关系，是父类与子类之间的关系，是一种<strong>继承</strong>关系，是 is-a 的关系。</p><p>在 UML 类图中泛化使用<strong>带三角箭头的实线</strong>表示，从具体类指向泛化类。</p><p><img src="index/generalization.png" alt="generalization"></p><h3 id="实现-realization"><a class="markdownIt-Anchor" href="#实现-realization"></a> 实现 (Realization)</h3><p>实现 (Realization) 表示接口与实现类之间的关系。类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作，是 like-a 的关系。</p><p>在 UML 类图中使用<strong>带三角箭头的虚线</strong>表示，从实现类指向抽象类。</p><p><img src="index/realization.png" alt="realization"></p><h3 id="关联-association"><a class="markdownIt-Anchor" href="#关联-association"></a> 关联 (Association)</h3><p>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系。这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。</p><p>在 UML 类图中关联分为：</p><ul><li>单向关联：使用<strong>带箭头的实线</strong>表示，箭头指向关联类；</li><li>双向关联：使用<strong>带双箭头或不带箭头的实线</strong>表示。</li></ul><p><img src="index/association.png" alt="association"></p><h3 id="聚合-aggregation"><a class="markdownIt-Anchor" href="#聚合-aggregation"></a> 聚合 (Aggregation)</h3><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，但整体不存在了部分还是可以存在的，是 has-a 的关系。</p><p>在 UML 类图中使用带<strong>空心菱形</strong>的实线表示，菱形指向整体。</p><p><img src="index/aggregation.png" alt="aggregation"></p><h3 id="组合-composition"><a class="markdownIt-Anchor" href="#组合-composition"></a> 组合 (Composition)</h3><p>组合关系是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种<strong>更强烈的聚合关系</strong>，但是和聚合关系不同的是，组合关系中的整体不存在了，部分也就不存在了，是 contains-a 关系。</p><p>在 UML 类图中使用带<strong>实心菱形</strong>的实线表示，菱形指向整体。</p><p><img src="index/composition.png" alt="composition"></p><h3 id="依赖-dependency"><a class="markdownIt-Anchor" href="#依赖-dependency"></a> 依赖 (Dependency)</h3><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。A 类和 B 类是依赖关系（B --&gt; A）主要有三种形式：</p><ul><li>A 类是 B 类方法的局部变量；</li><li>A 类是 B 类方法的参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li></ul><p>在 UML 类图中<strong>带箭头的虚线</strong>表示，从使用类指向被依赖的类。</p><p><img src="index/dependency.png" alt="dependency"></p><h1 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h1><h2 id="solid"><a class="markdownIt-Anchor" href="#solid"></a> S.O.L.I.D</h2><table><thead><tr><th>简写</th><th>全拼</th><th>中文翻译</th><th>一句话解释</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td><td>一个类只负责一件事</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td><td>类应该对扩展开放，对修改关闭。</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td><td>子类对象必须能够替换掉所有父类对象。</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td><td>使用多个专用接口比使用单一的总接口要好。</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td><td>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</td></tr></tbody></table><h2 id="其他原则"><a class="markdownIt-Anchor" href="#其他原则"></a> 其他原则</h2><table><thead><tr><th>简写</th><th>全拼</th><th>中文翻译</th><th>一句话解释</th></tr></thead><tbody><tr><td>LKP</td><td>Least Knowledge Principle</td><td>最少了解原则</td><td>一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</td></tr><tr><td>CRP</td><td>The Composite Reuse Principle</td><td>组合复用原则</td><td><strong>尽量使用对象组合，而不是通过继承来达到复用的目的</strong>。</td></tr><tr><td>SAP</td><td>The Stable Abstractions Principle</td><td>稳定抽象原则</td><td>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</td></tr><tr><td>SDP</td><td>The Stable Dependencies Principle</td><td>稳定依赖原则</td><td>之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</td></tr></tbody></table><h1 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h1><blockquote><p>Each pattern describes a <strong>problem</strong> which occurs over and over again in our environment, and then describes the core of the <strong>solution</strong> to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice.<br>–  Christopher Alexander</p></blockquote><h2 id="创建型"><a class="markdownIt-Anchor" href="#创建型"></a> 创建型</h2><table><thead><tr><th>设计模式</th><th>目的</th></tr></thead><tbody><tr><td><a href="/2019/03/28/design-patterns/#singleton">单例 (Singleton)</a></td><td>确保一个类只有一个实例，并提供该实例的全局访问点。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#simple-factory">简单工厂 (Simple Factory)</a></td><td>封装创建对象时的内部细节，并为客户提供一个创建对象的通用接口。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#factory-method">工厂方法（Factory Method）</a></td><td>提供一个创建对象的接口，但由工厂子类决定要实例化哪个类。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#abstract-factory">抽象工厂 (Abstract Factory)</a></td><td>提供一个接口，用于创建<strong>相关的对象家族</strong>。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#builder">构造器 (Builder)</a></td><td>封装一个对象的构造过程，并允许按步骤构造。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#prototype">原型模式 (Prototype)</a></td><td>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</td></tr></tbody></table><h2 id="行为型"><a class="markdownIt-Anchor" href="#行为型"></a> 行为型</h2><table><thead><tr><th>设计模式</th><th>目的</th></tr></thead><tbody><tr><td><a href="/2019/03/28/design-patterns/#chain-of-responsibility">责任链 (Chain of Responsibility)</a></td><td>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</td></tr><tr><td>过滤器</td><td></td></tr></tbody></table><h2 id="结构型"><a class="markdownIt-Anchor" href="#结构型"></a> 结构型</h2><table><thead><tr><th>设计模式</th><th>目的</th></tr></thead><tbody><tr><td><a href="/2019/03/28/design-patterns/#adapter">适配器 (Adapter)</a></td><td>把一个类接口转换成另一个用户需要的接口。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#bridge">桥接 (Bridge)</a></td><td>将抽象与实现分离开来，使它们可以独立变化。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#composite">组合 (Composite)</a></td><td>将对象组合成树形结构来表示“整体/部分”层次关系。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#decorator">装饰器 (Decorator)</a></td><td>为对象动态添加功能.</td></tr><tr><td><a href="/2019/03/28/design-patterns/#facade">外观 (Facade)</a></td><td>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#flyweight">享元 (Flyweight)</a></td><td>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</td></tr><tr><td><a href="/2019/03/28/design-patterns/#proxy">代理 (Proxy)</a></td><td>控制对其它对象的访问。</td></tr></tbody></table><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://www.oodesign.com/singleton-pattern.html" target="_blank" rel="noopener">https://www.oodesign.com/singleton-pattern.html</a></li><li><a href="https://www.planttext.com/" target="_blank" rel="noopener">https://www.planttext.com/</a></li><li><a href="https://www.oodesign.com/" target="_blank" rel="noopener">https://www.oodesign.com/</a></li><li><a href="https://cyc2018.github.io/CS-Notes/#/README" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/README</a></li><li>GoF</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code</title>
      <link href="/notes/tools/vscode/index.html"/>
      <url>/notes/tools/vscode/index.html</url>
      
        <content type="html"><![CDATA[<p>VS Code 是最风靡的编辑器之一，作为深度使用者，笔者主要使用 VS Code 来<strong>阅读代码</strong>，<strong>写 Markdown 笔记</strong>（本站所有内容都是在 VS Code 上写出来的），同时也用来写一些<strong>简单的解释型语言代码（例如 Python）或者脚本</strong>等。本文的内容偏分享向而非教学向，如果想了解更多，请参阅 <a href="https://code.visualstudio.com/docs/" target="_blank" rel="noopener">Visual Studio Code Docs</a>。</p><a id="more"></a><h1 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h1><p>VS Code 在 <strong>Help &gt; Keyboard Shortcut Reference</strong> 提供了一份平台相关的 PDF 来帮助你查<strong>找键盘快捷键</strong>。除了常用的复制、黏贴、查找、替换等常规文本操作，以下是比较常用的基本快捷键：</p><table><thead><tr><th>快捷键</th><th>解释</th></tr></thead><tbody><tr><td><code>Ctrl+P</code></td><td>快速打开、跳转到文件…</td></tr><tr><td><code>Ctrl+,</code></td><td>用户设置</td></tr><tr><td><code>Alt+ ↑ / ↓</code></td><td>上/下移动行（编程中很有用）</td></tr><tr><td><code>Ctrl+/</code></td><td>打开/关闭行注释</td></tr><tr><td><code>Ctrl+`(反引号)</code></td><td>显示集成终端</td></tr></tbody></table><h2 id="多选择多光标-multi-cursor"><a class="markdownIt-Anchor" href="#多选择多光标-multi-cursor"></a> 多选择/多光标 (multi-cursor)</h2><p>VS Code 支持多光标同时编辑，<code>Alt+Click</code> 即可添加一个光标，可以通过 <code>Ctrl+Alt+Down</code> or <code>Ctrl+Alt+Up</code> 同时上下添加多个光标。Esc 可以退出多光标模式。</p><h2 id="块选择-column-box-selection"><a class="markdownIt-Anchor" href="#块选择-column-box-selection"></a> 块选择 (Column (box) selection)</h2><p>按住 <code>Shift+Alt</code> 然后用鼠标拖拽就可以选中块区域，类似于 Vim 中的块选择效果。</p><h1 id="更改默认设置"><a class="markdownIt-Anchor" href="#更改默认设置"></a> 更改默认设置</h1><p>VS Code 的默认设置已经很人性化了，基本操作都比较符合直觉。但仍然有一些笔者不适应的地方，以下记录了如何修改这些默认设置：</p><h2 id="关闭预览模式"><a class="markdownIt-Anchor" href="#关闭预览模式"></a> 关闭预览模式</h2><p>VS Code 默认是<strong>单击预览文件，双击打开文件</strong>，笔者习惯单击打开文件，打开新文件时候经常会不小心进入预览模式而关闭当前文件，因此在设置中将 <code>&quot;workbench.editor.enablePreview&quot;: true</code> 改为 false。</p><h2 id="打开自动保存"><a class="markdownIt-Anchor" href="#打开自动保存"></a> 打开自动保存</h2><p>默认情况下，需要 <code>Ctrl+S</code> 才能将修改保存到硬盘，可以在 <strong>File &gt; Auto Save</strong> 设置自动保存，默认是延迟 1 秒自动保存，在设置中可以进行更细粒度设置，包括：</p><ul><li>off - 关闭自动保存（默认）</li><li>afterDelay - 经过延时配置的时间（默认 1000 毫秒）后保存</li><li>onFocusChange - 移出编辑区域后保存（<strong>推荐</strong>）</li><li>onWindowChange - 移出 VS Code 窗口后保存</li></ul><h2 id="使用-tab-补全"><a class="markdownIt-Anchor" href="#使用-tab-补全"></a> 使用 Tab 补全</h2><p>默认情况下，代码片和其他建议混在一起，需要使用 <code>Ctrl+Space</code> 不太方便补全，在设置 <code>&quot;editor.tabCompletion&quot;: &quot;on&quot;</code> 中开启 Tab 补全。</p><h1 id="代码片-snippets"><a class="markdownIt-Anchor" href="#代码片-snippets"></a> 代码片 (Snippets)</h1><p>VS Code 自带了简单的代码片，如果需要某种特定<strong>编程语言</strong>的代码补全，可以在 Extension 中下载对应语言的官方插件，一般都包含代码片。</p><h2 id="基本格式"><a class="markdownIt-Anchor" href="#基本格式"></a> 基本格式</h2><p>用户也可以创建自己的代码片，代码片文件是一个支持 C 风格注释的 JSON 文件，例如笔者创建了 Markdown 的代码片，用于快速输入一些控制格式的部分，可以专注于内容的编写。</p><p>以下是一个 JS 语言的 for 循环代码片：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// in file 'Code/User/snippets/javascript.json'</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"For Loop"</span>: &#123;</span><br><span class="line">    <span class="attr">"prefix"</span>: [<span class="string">"for"</span>, <span class="string">"for-const"</span>],</span><br><span class="line">    <span class="attr">"body"</span>: [<span class="string">"for (const $&#123;2:element&#125; of $&#123;1:array&#125;) &#123;"</span>, <span class="string">"\t$0"</span>, <span class="string">"&#125;"</span>],</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"A for loop."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个代码片使用名字作为键，其值包含：</p><ul><li>prefix 前缀：使用该代码片的输入前缀。</li><li>body 主体：主要部分。</li><li>description 描述：可选。</li></ul><p>代码片主体部分可以是简单的固定文字，也可以包含占位符，其格式为：<code>${跳转顺序:默认值}</code>，通过 Tab 进行跳转。其中第一个跳转的占位符为从 1 开始，<code>$0</code> 总为最后一个跳转占位符。</p><h2 id="作用范围"><a class="markdownIt-Anchor" href="#作用范围"></a> 作用范围</h2><p>用户可以通过 <strong>File &gt; Preferences - User Snippets</strong> 来创建或编辑代码片，默认的<strong>用户级代码片 (User Scope Snippet)</strong> 存储位置为 <code>Code\User\snippets\</code>, 用户级代码片又可以分为：</p><ul><li>依据语言类型分类的特定语言代码片</li><li>适用于所有语言的全局代码片</li></ul><p>除此之外，还可以创建<strong>项目代码片 (Project Scope Snippet)</strong>，更便于随着项目移植，位于项目根目录下的 <code>.vscode</code> 文件夹中。项目代码片类似于用户级的全局代码片，其适用于所有语言，可以通过 scope 属性来限制语言范围。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Vim</title>
      <link href="/notes/tools/vim/index.html"/>
      <url>/notes/tools/vim/index.html</url>
      
        <content type="html"><![CDATA[<p>从零开始，搭建一份属于你自己的 Vim，然后享受 coding 的乐趣。</p><h1 id="自定义配置-customization"><a class="markdownIt-Anchor" href="#自定义配置-customization"></a> 自定义配置 (Customization)</h1><h2 id="轻量级配置"><a class="markdownIt-Anchor" href="#轻量级配置"></a> 轻量级配置</h2><p>仅仅利用 vim 自身支持的配置项完成，不使用任何插件，不需要任何依赖，适合所有的环境使用，旨在于使用最快的速度拥有一个基本的编程环境。</p><figure class="highlight routeros"><figcaption><span>.vimrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" vim basic</span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string">set showmode</span></span><br><span class="line"><span class="string">set showcmd</span></span><br><span class="line"><span class="string">set mouse=a</span></span><br><span class="line"><span class="string">set encoding=utf-8</span></span><br><span class="line"><span class="string">set t_Co=256</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> display</span><br><span class="line"><span class="builtin-name">set</span> number          <span class="string">" 显示行号</span></span><br><span class="line"><span class="string">"</span> <span class="builtin-name">set</span> relativenumber  <span class="string">" 显示相对行号</span></span><br><span class="line"><span class="string">set cursorline      "</span> 高亮当前光标所在行</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">textwidth</span>=80    <span class="string">" 显示行宽</span></span><br><span class="line"><span class="string">set wrap            "</span> 自动折行</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">wrapmargin</span>=2    <span class="string">" 折行边缘宽度</span></span><br><span class="line"><span class="string">set linebreak       "</span> 单词内不折行</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">scrolloff</span>=5     </span><br><span class="line"><span class="builtin-name">set</span> ruler</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">matchtime</span>=1</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">laststatus</span>=2</span><br><span class="line"></span><br><span class="line"><span class="string">" enable filetype detection:</span></span><br><span class="line"><span class="string">filetype on</span></span><br><span class="line"><span class="string">filetype plugin on</span></span><br><span class="line"><span class="string">filetype indent on  "</span> file<span class="built_in"> type </span>based indentation</span><br><span class="line"></span><br><span class="line"><span class="string">" indent</span></span><br><span class="line"><span class="string">set autoindent      "</span> 按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致。</span><br><span class="line"><span class="builtin-name">set</span> smartindent     <span class="string">" 智能缩进</span></span><br><span class="line"><span class="string">set tabstop=4       "</span> 按下 Tab 键时，Vim 显示的空格数。</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">softtabstop</span>=4   <span class="string">" 按退格键时退回缩进的长度</span></span><br><span class="line"><span class="string">set shiftwidth=4    "</span> 按下缩进字符数</span><br><span class="line">autocmd FileType make <span class="builtin-name">set</span> noexpandtab <span class="attribute">shiftwidth</span>=8 <span class="attribute">softtabstop</span>=0</span><br><span class="line"></span><br><span class="line"><span class="string">" searching</span></span><br><span class="line"><span class="string">set showmatch</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">set incsearch</span></span><br><span class="line"><span class="string">set ignorecase</span></span><br><span class="line"><span class="string">set smartcase</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> edit</span><br><span class="line">autocmd FileType markdown,tex <span class="builtin-name">set</span> spell <span class="attribute">spelllang</span>=en,cjk</span><br><span class="line"><span class="builtin-name">set</span> wildmenu</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">wildmode</span>=longest:list,full</span><br><span class="line"><span class="builtin-name">set</span> autoread</span><br><span class="line"><span class="builtin-name">set</span> nobackup</span><br><span class="line"><span class="builtin-name">set</span> nowb</span><br><span class="line"><span class="builtin-name">set</span> noswapfile</span><br><span class="line"></span><br><span class="line"><span class="string">" coding</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> custom map</span><br><span class="line">map j gj</span><br><span class="line">map k gk</span><br><span class="line">inoremap jj &lt;Esc&gt;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://vimawesome.com/" target="_blank" rel="noopener">VimAwesome</a></li><li><a href="https://stackoverflow.com/questions/2627886/how-do-i-run-a-c-program-from-vim" target="_blank" rel="noopener">how-do-i-run-a-c-program-from-vim</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/notes/programming/python/index.html"/>
      <url>/notes/programming/python/index.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>人生苦短，我用 Python！<br>Life is short, you need Python！</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>本文集长期更新，记录 Python 学习路上的点点滴滴。更多内容可以查看英文笔记 <a href="https://github.com/liyanjiu/learn-python3" target="_blank" rel="noopener">learn-python3</a> 。</p><a id="more"></a><h1 id="起步-getting-started"><a class="markdownIt-Anchor" href="#起步-getting-started"></a> 起步 (Getting Started)</h1><h2 id="挑选-python-解释器-3-vs-2"><a class="markdownIt-Anchor" href="#挑选-python-解释器-3-vs-2"></a> 挑选 Python 解释器 (3 vs. 2)</h2><p>Python 是一种<strong>解释型</strong>语言，由于历史的演进，出现了许多方面不兼容或重新设计的 2 和 3 两个大版本，目前 Python 的现状 (3 &amp; 2) 如下：</p><ul><li>Python 2.7 已于 2020 年停止更新，不再维护。</li><li>仍有相当一部分应用是用 Python 2.x 写成。</li><li>目前 Python 3.x 是官方的推荐版本。</li></ul><p>所以推荐如下：</p><ul><li><s>新软件编写时使用 Python 3，但最好做到 2 和 3 兼容，因为有些人仍然使用 2。如果写新模块，用 Python 3 就好了。</s></li><li>无论是写软件还是模块，应当使用 Python 3！要不要兼容 2 取决于你的精力和心情。</li></ul><p>Python 语言有多种实现方式，官方使用的是 C 语言实现的版本。</p><table><thead><tr><th>Names</th><th>Language</th><th>Speed</th><th>Popular</th><th>Aim</th></tr></thead><tbody><tr><td>CPython</td><td>C</td><td>fast</td><td>reference</td><td>Reach the widest possible audience</td></tr><tr><td>PyPy</td><td>Python</td><td>5 times faster than CPython</td><td></td><td>Maximum compatibility, performance</td></tr><tr><td>Jython</td><td>Java</td><td></td><td></td><td>Be able to import and use any Java class like a Python module</td></tr><tr><td>IronPython</td><td>.NET</td><td></td><td></td><td>For the .NET framework and Window developer</td></tr></tbody></table><h2 id="安装-python"><a class="markdownIt-Anchor" href="#安装-python"></a> 安装 Python</h2><p>首先，基于你的系统安装 Python 。参考如下：</p><ul><li><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://docs.python-guide.org/starting/installation/" target="_blank" rel="noopener">Properly Installing Python - The Hitchhiker’s Guide to Python, by Kenneth Reitz</a></li></ul><h2 id="开发环境"><a class="markdownIt-Anchor" href="#开发环境"></a> 开发环境</h2><p>开发环境基于<strong>操作系统类型，主要包括是否使用IDE，使用何种编辑器</strong>。这部分根据个人喜好配置就好了。笔者的配置如下，推荐 PyCharm IDE：</p><ul><li>IDE: <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a> (推荐，适合写中大型项目)</li><li>Text editor：VS Code/Vim (配合终端适合写简单脚本)</li><li>Notebook：<a href="http://jupyter.org/" target="_blank" rel="noopener">Jupyter Notebook</a></li></ul><h2 id="包管理器-package-manager"><a class="markdownIt-Anchor" href="#包管理器-package-manager"></a> 包管理器 (Package manager)</h2><p>这里的<strong>包 (package)</strong> 指的是软件的一个发行版 (distribution)，而不是在源码中导入的包 (container of modules)，通俗的理解来说，包管理就是管理那些你下载的别人或官方用 Python 编写的软件。</p><h3 id="pip"><a class="markdownIt-Anchor" href="#pip"></a> pip</h3><p>pip 是官方推荐使用的包管理器，关于如何下载和使用 pip 的详细说明，请移步官方教程 <a href="https://packaging.python.org/tutorials/installing-packages/" target="_blank" rel="noopener">Installing Packages</a>。当然，现在默认情况下，pip 是随着 Python 的安装而默认安装的，因此基本上不需要自行下载了。</p><p>可以通过 <code>pip --version</code> 查看 pip 版本，以及是否和使用的 Python 的版本相同。这是因为使用官方的安装脚本安装 pip 时会探测系统上 Python 的版本，具体来说，<code>pip2</code> 代表管理 Python 2 的包，<code>pip3</code> 或 <code>pip3.6</code> 之类的代表管理 Python 3 的包，而 <code>pip</code> 代表什么取决于你的系统上的主要的 Python 版本。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python --version</span><br><span class="line">Python <span class="number">3.8</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line">$ pip --version</span><br><span class="line">pip <span class="number">20.1</span>.<span class="number">1</span> from /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.8/<span class="title">dist</span>-<span class="title">packages</span>/<span class="title">pip</span> (<span class="title">python</span> 3.8)</span></span><br></pre></td></tr></table></figure><h4 id="安装模式"><a class="markdownIt-Anchor" href="#安装模式"></a> 安装模式</h4><p>安装好 pip 之后，可以直接在命令行运行 <code>pip</code> 来查看使用说明。需要特别说明的是安装包有<strong>全局模式</strong>和<strong>用户模式</strong>的区别：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --<span class="keyword">user</span> <span class="title">SomeProject</span></span><br></pre></td></tr></table></figure><p>以上的命令会将包安装到用户存放二进制文件的目录中，<strong>不加参数的默认行为是全局安装</strong>。</p><ul><li>在 Linux 或 macOS 中，执行 <code>$ python -m site --user-base</code> 来查看用户的目录，一般是 <code>～/.local/</code>，最好将该路径加入 <code>PATH</code> 中，否则每次安装包时 pip 会报警告。</li><li>在 Windows 中，执行 <code>py -m site --user-site</code> 查看用户目录，一般是 <code>C:\Users\Username\AppData\Roaming\Python36\site-packages</code>，最好将 <code>C:\Users\Username\AppData\Roaming\Python36\Scripts</code> 加入环境变量 <code>PATH</code> 中。</li></ul><p>还有一些其他的用法，具体查看上述官网的教程以及 <code>pip --help</code>。</p><h4 id="更换镜像"><a class="markdownIt-Anchor" href="#更换镜像"></a> 更换镜像</h4><p>使用 pip 安装太慢？不如换国内镜像源试试。笔者习惯于清华的 TUNA 镜像站，5 min 同步一次。从 pip 10 开始可以使用 config 子命令可用来改配置，因此我们无需关心不同操作系统下配置文件路径。只需如下一条命令即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip config <span class="keyword">set</span> global.index-<span class="keyword">url</span> https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">Writing <span class="keyword">to</span> C:\<span class="keyword">Users</span>\%<span class="keyword">USER</span>%\AppData\Roaming\pip\pip.ini  <span class="comment"># Windows</span></span><br><span class="line">Writing <span class="keyword">to</span> $HOME/.config/pip/pip.conf                   <span class="comment"># Linux</span></span><br></pre></td></tr></table></figure><h4 id="pip-多版本冲突"><a class="markdownIt-Anchor" href="#pip-多版本冲突"></a> Pip 多版本冲突</h4><p>Pip 多版本冲突问题主要存在于 Linux 环境中，首先是发行版可能预装了 Python 2 或 Python 3，以 Ubuntu 为例，即使没有预装，用户一般使用 apt 包管理器安装 Python，这就导致了 Python 其实是由操作系统管理的，因此操作需要管理员权限。</p><p>如果通过 pip 的官方脚本 <a href="http://get-pip.py" target="_blank" rel="noopener">get-pip.py</a> 安装，需要特别注意 <a href="http://get-pip.py" target="_blank" rel="noopener">get-pip.py</a> 与这些包管理器工具不协调（脚本默认安装到用户目录），并且可能使我们的系统处于不一致状态，这种情况可以使用 <code>python get-pip.py --prefix=/usr/local</code> 来安装到系统目录。</p><p>另一种解决方法是直接使用包管理器来安装 pip。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> python-pip     <span class="comment"># for pip</span></span><br><span class="line">sudo apt <span class="keyword">install</span> python3-pip    <span class="comment"># for pip3</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>由于 Python 2 已经停止更新，从 Ubuntu 20.04 之后将不再支持 python-pip，随着 Python 2 使用的减少，或许冲突问题将会减少。</p>          </div><p>如果系统中确实存在多个 pip，尽量使用 <code>python -m pip [command]</code>。这指明了将 pip 模块作为 <code>python</code> 命令环境下的脚本来运行，也就是根据 Python 的版本和权限选择对应的 pip，这将自动为我们解决一些冲突问题，如：</p><ul><li>pip 多版本共存问题，如 pip2 以及 pip3。这时将自动选择适合 Python 版本的 pip。</li><li>pip 多权限版本共存问题，如系统目录下的 pip 以及用户目录下的 pip。</li></ul><div class="note warning">            <p>没有特别需求的话，一种 Python 版本不应当在多个目录下存在 pip 模块。好的做法是：</p><ol><li>仅使用系统目录（系统权限）下的 pip。换句话说，Python 和 Pip 的权限应当保持一致，由于大多数情况下 Python 是系统管理的，因此 Pip 也安装的系统目录下。</li><li>使用 <code>--user</code> 选项将库安装在用户目录下（这将不会让你提供 root 权限）。</li></ol><p>因此，当升级 pip 时，<strong>请确保执行 <code>python -m pip install --upgrade pip</code> 命令的 shell 具有系统权限</strong>。否则将升级失败。<strong>不要</strong>使用 <code>python -m pip install --user --upgrade pip</code> 来升级你的 pip，这将会导致在用户目录下重新下载一个 pip，从而引发 pip 的冲突问题，使得 <code>pip xxx</code> 命令报错。假如你这么做了，仍然可以使用 <code>python -m pip xxx</code> 来执行命令，原因如上，不过多个 pip 并不是一种优雅的方式。</p>          </div><h3 id="conda"><a class="markdownIt-Anchor" href="#conda"></a> conda</h3><p>除了 pip，还有其他的包管理工具，如 conda，随着 Anaconda 的安装而安装的，Anaconda 是一个针对于科学计算人员的软件发布包，其内置了 conda 这样的包管理器 (考虑到 conda 实现了下文中接着提到的虚拟环境管理器的功能，叫做包管理器可能不太恰当)，<strong>许多科学计算的库 (通过 pip 逐一安装它们可是要费不少劲的)</strong>，编辑器，IDE 以及 Jupiter 等工具。</p><div class="note info">            <p>由于 anaconda 的跨平台的特性，在国内有清华的镜像站，且还可以和 pip 协同工作，十分适合使用 Python 做机器学习，科学计算等需求的初学者，可以一键式打造开发环境。如果嫌它太臃肿，试试 miniconda？</p>          </div><h2 id="虚拟环境"><a class="markdownIt-Anchor" href="#虚拟环境"></a> 虚拟环境</h2><p>包管理器为我们解决了将<strong>依赖</strong>从网络上下载到本地这个过程，然而却不能保证任何本地项目的调用是否会成功。</p><p>当使用 Python 编写项目时，可能通过 <code>import module</code> (可以先不理解) 引入他人编写的模块，这样你就可以愉快的使用 <code>module.func()</code> 来调用别人写好的函数，这些模块就叫做当前项目的依赖 (dependencies)，用着是爽了，但会带来一个问题，如果项目 A 使用的是 module 版本 1.3，而项目 B 使用的是 module 版本 2.1，可是系统上安装的 module 只有一个版本，这下可麻烦了，不同的项目有不同的依赖，难免会出错。其他编程语言同样也存在类似的问题，并且具有类似的解决方案。</p><ul><li>例如 Java 可以使用 Maven 来构建工程，通过在项目目录下包含一个 <code>pom.xml</code> 文件来管理当前的依赖包。</li><li>例如 nodejs 使用 npm 来构建项目，通过在项目目录下包含一个 <code>package.json</code> 文件来管理当前的依赖包。</li></ul><p>Python 使用了一种称为<strong>虚拟环境</strong>的技术来实现这个需求。简单的讲，虚拟环境就是把所有运行 Python 文件的环境（包括解释器、库等）打包到一个单独的路径里面，然后用该路径来替换本机的全局环境，只不过替换不是通过手动更改环境变量等一系列设置，而是由工具自动完成。为每个项目创建一个虚拟环境，并安装不同版本的模块，这样每个项目可以调用自己的依赖版本库而互不影响。官方教程在这里：<a href="https://packaging.python.org/tutorials/managing-dependencies/" target="_blank" rel="noopener">Managing Application Dependencies</a></p><p>在 pipenv 之前一般通过 <strong>venv</strong> (Python 3 官方库) 或 <strong>virtualenv</strong> (第三方工具但比 venv 更早，也更受欢迎) 来管理虚拟环境，但多少有些麻烦，在 Kenneth Reitz 将自己的个人项目 pipenv 转交给 PyPA以后，<strong>pipenv 成为了官方推荐的虚拟环境管理工具</strong>。pipenv 是对 pip、virtualenv 等工具的进一步封装，结果就是我们可以像管理 Java 和 JavaScript 项目那样顺畅丝滑的管理 Python 的虚拟环境。pipenv 会在当前项目路径下创建 pipfile 文件，记录所有的依赖关系。这类似于 Java 的 Maven 生成的 pom.xml，node.js 的 npm 生成的 package.json。</p><div class="note info">            <p>其实还有一个管理 Python 版本的工具 pyenv 可以使用，目的是为了管理系统上不同版本的 Python，但我个人很少使用，因为每个项目的虚拟环境可以通过 pipenv 来管理，系统上的 Python 并没有太多管理的需求。如果个人有这方面的需求，不妨可以尝试下 pyenv。</p>          </div><h3 id="pipenv"><a class="markdownIt-Anchor" href="#pipenv"></a> Pipenv</h3><p>pipenv 的使用十分简单，首先通过 pip 安装 pipenv：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --<span class="keyword">user</span> <span class="title">pipenv</span></span><br></pre></td></tr></table></figure><p>接着，进入工程目录下，安装 requests 库：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> myproject &amp;&amp; <span class="built_in">cd</span> myproject</span><br><span class="line">pipenv install requests</span><br></pre></td></tr></table></figure><p>最后，使用 requests 库，创建一个 <code>main.py</code> 的文件，并写下以下代码，通过 Python 解释器运行这个文件，你会得到你当前的 IP 地址。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.<span class="keyword">get</span>(<span class="string">'https://httpbin.org/ip'</span>)</span><br><span class="line">print(<span class="string">'Your IP is &#123;0&#125;'</span>.format(response.json()[<span class="string">'origin'</span>]))</span><br></pre></td></tr></table></figure><p>如果在终端中使用 <code>python main.py</code> 来运行脚本，需要输入 <code>pipenv shell</code> 激活这个虚拟环境，否则不会使用虚拟环境，导致报错。当激活完虚拟环境之后，你会发现你的 Python 路径现在已经是虚拟环境里的 Python 解释器了。如果想推出这个环境，只需 <code>exit</code> 即可。更多的使用请见 <code>pipenv --help</code>。</p><h2 id="python-相关组织"><a class="markdownIt-Anchor" href="#python-相关组织"></a> Python 相关组织</h2><h3 id="python-software-foundation"><a class="markdownIt-Anchor" href="#python-software-foundation"></a> Python Software Foundation</h3><blockquote><p>The mission of the Python Software Foundation is to promote, protect, and advance the Python programming language, and to support and facilitate the growth of a diverse and international community of Python programmers.</p><footer><strong>Mission Statement page</strong></footer></blockquote><p>Python 软件基金会的使命是促进和保护 Python 编程语言的发展，致力于形成一个多样化和国际化的 Python 社区。其维护了 <a href="https://www.python.org" target="_blank" rel="noopener">官方网站</a> ，包括：</p><ul><li>Python Language：Python 语言</li><li>Python Documentation：Python 语言和官方库的文档</li><li>Python Community：Python 的社区</li><li>PyPI (Python Package Index)：Python 的官方第三方库索引</li><li>PyPA (Python Packaging Authority)：负责维护 Python 包管理的相关工具</li></ul><p>其中，Python 官方文档是笔者认为目前最好的<strong>初学者学习资源</strong>，没有之一。</p><h3 id="peps-标准提案"><a class="markdownIt-Anchor" href="#peps-标准提案"></a> PEPs (标准提案)</h3><p>PEP是 Python Enhancement Proposals 的缩写，就是改进 Python 建议书。每个 PEP 文件可能属于：</p><ul><li>信息类 (Information PEP)，如 Python 的编程规范等；</li><li>流程类 (Process PEP)，如 Python 的工具，仓库迁移等；</li><li>标准类 (Standards Track PEP)，包括新功能和新的实现等。</li></ul><p>PEPs 可以当做设计文档来读，包含了Python 这门语言许多有价值的的技术规范和发展历程，在<a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener">PEP 0（Index of Python Enhancement Proposals (PEPs)）</a>里，官方列举了所有的PEP，你可以按序号、按类型以及按状态进行检索。当然 PEPs 很多，全部通读很花费时间，<strong>但其中有一些相当重要的 PEP 还是应该读一读的，它们包括但不限于</strong>：</p><ul><li><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8 – Style Guide for Python Code</a></li><li><a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP 257 – Docstring Conventions</a></li><li><a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">PEP 20 – The Zen of Python</a> (彩蛋)</li><li><a href="https://www.python.org/dev/peps/pep-0333/" target="_blank" rel="noopener">PEP 333/3333 – Python Web Server Gateway Interface v1.0/v1.0.1</a></li></ul><p>在知乎上有一个问答 <a href="https://www.zhihu.com/question/23484654" target="_blank" rel="noopener">python 的众多PEP 之中，除了PEP8 ，还有哪一些是值得阅读的？</a>，里面有更多详细的回答。</p><h2 id="python-学习资源"><a class="markdownIt-Anchor" href="#python-学习资源"></a> Python 学习资源</h2><p>主要包括笔者读过的<strong>好书</strong>和遇到的有价值的资源（包括博客，第三方库等），这部分随时更新，用英文写的是英文资源，用中文写的是中文资源。</p><ul><li>The Hitchhiker’s Guide to Python, by Kenneth Reitz</li><li>…</li></ul><h1 id="基础-basics"><a class="markdownIt-Anchor" href="#基础-basics"></a> 基础 (Basics)</h1><p>假设读者有其他编程语言的基础，那么理解 Python 代码将是非常容易的。</p><h2 id="缩进和注释"><a class="markdownIt-Anchor" href="#缩进和注释"></a> 缩进和注释</h2><p>Python 的语法比较简单，采用<strong>缩进方式</strong>。当语句以冒号:结尾时，缩进的语句视为代码块。缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是 Tab。按照约定俗成的惯例，<strong>应该始终坚持使用 4 个空格的缩进</strong>。</p><p>以 # 开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。</p><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><p>在 Python中，等号 <code>=</code> 是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。</p><p>在 Python 中，通常用全部大写的变量名表示常量。但 Python 没有任何机制保证常量不被修改。</p><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><p>在 Python 中，能够直接处理的数据类型有以下几种：</p><ul><li>整数：Python 可以处理任意大小的整数，当然包括负整数。</li><li>浮点数</li><li>字符串：字符串是以单引号 <code>'</code> 或双引号 <code>&quot;</code> 括起来的任意文本。</li><li>布尔值：布尔值和布尔代数的表示完全一致，一个布尔值只有 <code>True</code>、<code>False</code> 两种值。</li><li>空值是：Python 里一个特殊的值，用None表示。</li></ul><h3 id="字符串和编码"><a class="markdownIt-Anchor" href="#字符串和编码"></a> 字符串和编码</h3><p>Python 3 的字符串使用 Unicode，直接支持多语言。</p><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><p>除了基本的数据类型，Python 内置了常用的数据结构，包括：</p><ul><li>list 列表</li><li>tuple 元组</li><li>dict 字典</li><li>set 集合</li></ul><h3 id="list-tuple"><a class="markdownIt-Anchor" href="#list-tuple"></a> list &amp; tuple</h3><p>Python 内置的一种数据类型是列表：list。list 是一种有序的集合，可以随时添加和删除其中的元素。</p><p>另一种有序列表叫元组：tuple。tuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改。</p><h3 id="dict-set"><a class="markdownIt-Anchor" href="#dict-set"></a> dict &amp; set</h3><p>Python 内置了字典：dict的支持，dict 全称 dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。</p><p>set 和 dict 类似，也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以在 set 中没有重复的 key。</p><h2 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h2><p>控制流与 C 十分相似，包括：</p><ul><li>if</li><li>for…in…</li><li>while</li><li>break</li><li>continue</li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><h2 id="模块和包"><a class="markdownIt-Anchor" href="#模块和包"></a> 模块和包</h2><h1 id="构建和分发-building-and-distributing"><a class="markdownIt-Anchor" href="#构建和分发-building-and-distributing"></a> 构建和分发 (Building and Distributing)</h1><p>Python 有非常丰富的第三方库可以使用，很多开发者会向 pypi 上提交自己的 Python 包。要想向 pypi 包仓库提交自己开发的包，首先要将自己的代码打包，才能上传分发。</p><p><code>distutils</code> 是标准库中负责建立 Python 第三方库的安装器，使用它能够进行 Python 模块的安装和发布。<code>distutils</code> 对于简单的分发很有用，但功能缺少。大部分 Python 用户会使用更先进的 <code>setuptools</code> 模块</p><p><code>setuptools</code> 是 Python <code>distutils</code> 增强的集合，允许开发人员更轻松地构建和分发 Python 软件包，尤其是依赖于其他软件包的软件包。具体参阅 <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#building-and-distributing-packages-with-setuptools" target="_blank" rel="noopener">Building and Distributing Packages with Setuptools</a>。</p><h2 id="setuppy"><a class="markdownIt-Anchor" href="#setuppy"></a> <a href="http://setup.py" target="_blank" rel="noopener">setup.py</a> 文件</h2><h3 id="最小安装脚本"><a class="markdownIt-Anchor" href="#最小安装脚本"></a> 最小安装脚本</h3><p>以下是一个最小的 setup 安装脚本，只需要将脚本放到项目目录下，与包目录同级。</p><figure class="highlight py"><figcaption><span>minimal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">"HelloWorld"</span>,</span><br><span class="line">    version=<span class="string">"0.1"</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="更多信息"><a class="markdownIt-Anchor" href="#更多信息"></a> 更多信息</h3><p>当然，在将项目发布到PyPI之前，您需要向设置脚本中添加更多信息，以帮助人们找到或了解您的项目。<br>到那时，也许您的项目将会发展壮大，以包括一些依赖项，以及一些数据文件和脚本：</p><figure class="highlight py"><figcaption><span>more information</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">"requirements.txt"</span>, <span class="string">"rb"</span>)</span><br><span class="line">    REQUIRES = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> f.read().decode(<span class="string">"utf-8"</span>).split(<span class="string">"\n"</span>)]</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"'requirements.txt' not found!"</span>)</span><br><span class="line">    REQUIRES = list()</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">"HelloWorld"</span>,</span><br><span class="line">    version=<span class="string">"0.1"</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    scripts=[<span class="string">"say_hello.py"</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Project uses reStructuredText, so ensure that the docutils get</span></span><br><span class="line">    <span class="comment"># installed or upgraded on the target machine</span></span><br><span class="line">    install_requires=[<span class="string">"docutils&gt;=0.3"</span>],</span><br><span class="line"></span><br><span class="line">    package_data=&#123;</span><br><span class="line">        <span class="comment"># If any package contains *.txt or *.rst files, include them:</span></span><br><span class="line">        <span class="string">""</span>: [<span class="string">"*.txt"</span>, <span class="string">"*.rst"</span>],</span><br><span class="line">        <span class="comment"># And include any *.msg files found in the "hello" package, too:</span></span><br><span class="line">        <span class="string">"hello"</span>: [<span class="string">"*.msg"</span>],</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># metadata to display on PyPI</span></span><br><span class="line">    author=<span class="string">"Me"</span>,</span><br><span class="line">    author_email=<span class="string">"me@example.com"</span>,</span><br><span class="line">    description=<span class="string">"This is an Example Package"</span>,</span><br><span class="line">    keywords=<span class="string">"hello world example examples"</span>,</span><br><span class="line">    url=<span class="string">"http://example.com/HelloWorld/"</span>,   <span class="comment"># project home page, if any</span></span><br><span class="line">    project_urls=&#123;</span><br><span class="line">        <span class="string">"Bug Tracker"</span>: <span class="string">"https://bugs.example.com/HelloWorld/"</span>,</span><br><span class="line">        <span class="string">"Documentation"</span>: <span class="string">"https://docs.example.com/HelloWorld/"</span>,</span><br><span class="line">        <span class="string">"Source Code"</span>: <span class="string">"https://code.example.com/HelloWorld/"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="string">"License :: OSI Approved :: Python Software Foundation License"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># could also include long_description, download_url, etc.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="复杂项目"><a class="markdownIt-Anchor" href="#复杂项目"></a> 复杂项目</h3><p>复杂项目通常会添加更丰富的信息，例如一个使用 Github 托管并发布在 PyPI 的项目可以按照如下脚本编写，脚本来自于 <a href="https://github.com/MacHu-GWU/Python-with-GitHub-PyPI-and-Readthedoc-Guide/blob/master/setup.py" target="_blank" rel="noopener">MacHu-GWU/Python-with-GitHub-PyPI-and-Readthedoc-Guide</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">"requirements.txt"</span>, <span class="string">"rb"</span>)</span><br><span class="line">    REQUIRES = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> f.read().decode(<span class="string">"utf-8"</span>).split(<span class="string">"\n"</span>)]</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"'requirements.txt' not found!"</span>)</span><br><span class="line">    REQUIRES = list()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=NAME,</span><br><span class="line">    description=SHORT_DESCRIPTION,</span><br><span class="line">    long_description=LONG_DESCRIPTION,</span><br><span class="line">    version=VERSION,</span><br><span class="line">    author=AUTHOR,</span><br><span class="line">    author_email=AUTHOR_EMAIL,</span><br><span class="line">    maintainer=MAINTAINER,</span><br><span class="line">    maintainer_email=MAINTAINER_EMAIL,</span><br><span class="line">    packages=PACKAGES,</span><br><span class="line">    include_package_data=INCLUDE_PACKAGE_DATA,</span><br><span class="line">    package_data=PACKAGE_DATA,</span><br><span class="line">    url=URL,</span><br><span class="line">    download_url=DOWNLOAD_URL,</span><br><span class="line">    classifiers=CLASSIFIERS,</span><br><span class="line">    platforms=PLATFORMS,</span><br><span class="line">    license=LICENSE,</span><br><span class="line">    install_requires=REQUIRES,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="setuppy-2"><a class="markdownIt-Anchor" href="#setuppy-2"></a> <a href="http://setup.py" target="_blank" rel="noopener">setup.py</a> 命令</h2><p><a href="http://setup.py" target="_blank" rel="noopener">setup.py</a> 文件有很多内置命令可供使用，查看所有支持的命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage: setup.<span class="keyword">py</span> [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]</span><br><span class="line">   <span class="built_in">or</span>: setup.<span class="keyword">py</span> --<span class="keyword">help</span> [cmd1 cmd2 ...]</span><br><span class="line">   <span class="built_in">or</span>: setup.<span class="keyword">py</span> --<span class="keyword">help</span>-commands</span><br><span class="line">   <span class="built_in">or</span>: setup.<span class="keyword">py</span> cmd --<span class="keyword">help</span></span><br></pre></td></tr></table></figure><p>其中比较常用的有：</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>build</td><td>build everything needed to install</td></tr><tr><td>clean</td><td>clean up temporary files from ‘build’ command</td></tr><tr><td>install</td><td>install everything from build directory</td></tr><tr><td>sdist</td><td>create a source distribution (tarball, zip file, etc.)</td></tr><tr><td>register</td><td>register the distribution with the Python package index</td></tr><tr><td>bdist</td><td>create a built (binary) distribution</td></tr><tr><td>bdist_dumb</td><td>create a “dumb” built distribution</td></tr><tr><td>bdist_rpm</td><td>create an RPM distribution</td></tr><tr><td>bdist_wininst</td><td>create an executable installer for MS Windows</td></tr><tr><td>upload</td><td>upload binary package to PyPI</td></tr><tr><td>check</td><td>perform some checks on the package</td></tr></tbody></table><h3 id="安装-install"><a class="markdownIt-Anchor" href="#安装-install"></a> 安装 install</h3><p>软件包的安装也十分简单</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;project-directory&gt;</span><br><span class="line">python setup.py install    <span class="comment"># 手动安装</span></span><br><span class="line">python -m pip install .    <span class="comment"># 使用 pip 进行安装</span></span><br></pre></td></tr></table></figure><p>必须注意的是，手动安装的话会分散到各个目录中，因此在软件包卸载时无法定位，因此需要到各个目录下手动删除安装的文件。因此<strong>推荐使用 pip 进行安装，卸载时比较方便</strong>。强迫症用户可以通过以下脚本重新安装并记录，然后再卸载。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install --record files.txt</span><br><span class="line">cat files.txt | xargs rm -rf</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h2><h2 id="io"><a class="markdownIt-Anchor" href="#io"></a> IO</h2><h1 id="高级特性"><a class="markdownIt-Anchor" href="#高级特性"></a> 高级特性</h1><h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h2><h1 id="面向对象编程"><a class="markdownIt-Anchor" href="#面向对象编程"></a> 面向对象编程</h1><h2 id><a class="markdownIt-Anchor" href="#"></a> </h2><h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><h1 id="python-标准库"><a class="markdownIt-Anchor" href="#python-标准库"></a> Python 标准库</h1><p>Python 之所以自称 “batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://stackoverflow.com/questions/10458437/what-is-the-difference-between-dict-items-and-dict-iteritems" target="_blank" rel="noopener">What is the difference between dict.items() and dict.iteritems()?</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA</title>
      <link href="/notes/tools/idea/index.html"/>
      <url>/notes/tools/idea/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jetbrains.com/help/idea/installation-guide.html" target="_blank" rel="noopener">IntelliJ IDEA</a> 是一个跨 Windows，Linux，macOS 三大平台的集成开发环境，主要用于 Java 开发。其中，Intelli 表示 Intelligent，J 表示 Java，而 IDEA 具有两重含义，表示 IDE Advanced 或者仅仅就是 idea (我有一个好主意)。通常我们可以读作 IntelliJ[ɪn’telɪdʒeɪ]、IDEA[I-D-E-A] 或者 idea[aɪ’diə]。</p><h1 id="安装-installing"><a class="markdownIt-Anchor" href="#安装-installing"></a> 安装 (Installing)</h1><p>IDEA 的安装极其简单以及人性化，按照 <a href="https://www.jetbrains.com/help/idea/installation-guide.html" target="_blank" rel="noopener">Install IntelliJ IDEA</a> 的步骤即可完成，三大平台的安装都比较容易，主要注意选择版本即可，社区版 (Community Edition) 和 旗舰版 (Ultimate Edition) 是有区别的，前者开源免费，后者功能更多但却收费，不过在校师生可以使用教育邮箱注册高校计划，可以免费使用。</p><h1 id="起步-getting-started"><a class="markdownIt-Anchor" href="#起步-getting-started"></a> 起步 (Getting Started)</h1><p>IDEA 功能强大，但却足够易用，基本不需要进行额外的学习便可以简单上手开发，其中官网的以下两部分内容推荐阅读。</p><ul><li><a href="https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html" target="_blank" rel="noopener">Create your first Java application</a> 快速的了解一个完整的开发流程，主要包括创建工程、编写代码、构建及运行程序、程序打包、运行 Jar 包等基本流程。</li><li><a href="https://www.jetbrains.com/help/idea/mastering-keyboard-shortcuts.html" target="_blank" rel="noopener">Mastering IntelliJ IDEA keyboard shortcuts</a> 根据操作系统平台可以查询常用的快捷键。</li></ul><h1 id="ide-配置-configuring-the-ide"><a class="markdownIt-Anchor" href="#ide-配置-configuring-the-ide"></a> IDE 配置 (Configuring the IDE)</h1><p><a href="https://www.jetbrains.com/help/idea/configuring-project-and-ide-settings.html" target="_blank" rel="noopener">IDEA 配置</a>设置项 (Setting) 和 工程结构 (Structure) 具有两种等级：</p><ul><li>Project-level settings and structure 工程/项目级</li><li>IDE-level (global) settings and structure IDE/全局级</li></ul><h2 id="project-level-settings-and-structure"><a class="markdownIt-Anchor" href="#project-level-settings-and-structure"></a> Project-level settings and structure</h2><p>工程级配置仅针对当前工程，其设置和结构同其他工程文件一同存储于 <code>.idea</code> 这个文件夹中。</p><p>工程级配置方式如下：</p><ul><li>Access the <strong>project-level settings</strong>: From the main menu, select <strong>File | Settings</strong> for Windows and Linux, or <strong>IntelliJ IDEA | Preferences</strong> for macOS.</li><li>Access the <strong>project-level structure</strong>: From the main menu, select <strong>File | Project Structure</strong>.</li></ul><h2 id="ide-level-global-settings-and-structure"><a class="markdownIt-Anchor" href="#ide-level-global-settings-and-structure"></a> IDE-level (global) settings and structure</h2><p>针对全局工程 (所有新创建的工程)，也可通过插件将配置同步给已存在的工程项目。</p><p>全局配置方式如下：</p><ul><li>Access the <strong>IDE-level settings</strong>: From the main menu, select <strong>File | Other Settings | Settings</strong> for New Projects for Windows and Linux, or <strong>File | Other Settings | Preferences</strong> for New Projects for macOS.</li><li>Access the <strong>IDE-level structure</strong>: From the main menu, select <strong>File | Other Settings | Structure</strong> for New Projects.</li></ul><h1 id="工程配置-configuring-projects"><a class="markdownIt-Anchor" href="#工程配置-configuring-projects"></a> 工程配置 (Configuring Projects)</h1><p><a href="https://www.jetbrains.com/help/idea/working-with-projects.html" target="_blank" rel="noopener">工程配置</a></p><h2 id="projects"><a class="markdownIt-Anchor" href="#projects"></a> Projects</h2><p>type, SDK, name, location</p><p>Project formats:</p><ul><li>file-based</li><li>directory-based (recommended, default)</li></ul><h2 id="modules"><a class="markdownIt-Anchor" href="#modules"></a> Modules</h2><ul><li>Projects with multiple modules</li></ul><h2 id="sdks"><a class="markdownIt-Anchor" href="#sdks"></a> SDKs</h2><h2 id="libraries"><a class="markdownIt-Anchor" href="#libraries"></a> Libraries</h2><p>A library is a collection of <strong>compiled code</strong> that a module can depend on. In IntelliJ IDEA, libraries can be defined at three levels:</p><ul><li>global (available for many projects)</li><li>project (available for all modules within a project)</li><li>module (available for one module)</li></ul><p>A Java library can include <strong>class files</strong>, <strong>archives</strong> and <strong>directories with class files</strong> as well as <strong>directories with Java native libraries</strong> .dll, .so or .jnilib.</p><p>Define a <strong>global</strong> library:</p><ol><li>From the main menu, select <strong>File | Project Structure</strong></li><li>Under the <strong>Platform Settings</strong>, select <strong>Global Libraries</strong>.</li></ol><p>Define a <strong>project</strong> library:</p><ol><li>From the main menu, select <strong>File | Project Structure</strong></li><li>Under <strong>Project Settings</strong>, select <strong>Libraries</strong>.</li></ol><p>Define a module library:</p><ol><li>From the main menu, select <strong>File | Project Structure</strong></li><li>Under <strong>Project Settings</strong>, select <strong>Modules | Dependencies</strong>.</li><li>Click the Add button and select <strong>Library</strong>.</li></ol><div class="note info">            <p><a href="https://stackoverflow.com/questions/12269733/what-is-the-difference-between-module-dependencies-and-libraries-in-intellij" target="_blank" rel="noopener">https://stackoverflow.com/questions/12269733/what-is-the-difference-between-module-dependencies-and-libraries-in-intellij</a></p>          </div><h1 id="快捷键-shortcut-key"><a class="markdownIt-Anchor" href="#快捷键-shortcut-key"></a> 快捷键 (Shortcut Key)</h1><p>以下记录了笔者常用的快捷键</p><table><thead><tr><th>Shortcut</th><th>Action</th></tr></thead><tbody><tr><td>Ctrl+Alt+L</td><td>格式化代码</td></tr><tr><td>Alt+Insert</td><td>快速生成方法</td></tr><tr><td>Ctrl+O</td><td>快速生成重写方法</td></tr><tr><td>Ctrl+Shift+↑</td><td></td></tr><tr><td>Ctrl+Shift+↓</td><td></td></tr></tbody></table><h1 id="参考-references"><a class="markdownIt-Anchor" href="#参考-references"></a> 参考 (References)</h1><ul><li><a href="https://stackoverflow.com/questions/22026104/what-does-the-a-stand-for-in-intellij-idea" target="_blank" rel="noopener">What does the A stand for in Intellij IDEA?<br></a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/notes/os/linux/index.html"/>
      <url>/notes/os/linux/index.html</url>
      
        <content type="html"><![CDATA[<p>除了了解操作系统，学会各种命令行工具的用法，作为程序员还需要了解操作系统提供的各种 API，同时还将会了解到 Linux 内核等知识。</p><p>由于 Unix 系统对其他操作系统有重大影响，因此本章将会以 Unix 环境下 C 语言编程作为核心要点，广泛的介绍一切和内核、接口编程有关的概念。由于操作系统不可避免的涉及到网络、C 编程相关的知识，因此本章也是网络、编程部分功能实现的底层参考。</p><a id="more"></a><h1 id="unix-简介"><a class="markdownIt-Anchor" href="#unix-简介"></a> Unix 简介</h1><h1 id="系统函数"><a class="markdownIt-Anchor" href="#系统函数"></a> 系统函数</h1><p>系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。进程控制系统调用 (fork, exec 和 wait) 通常由用户应用程序直接调用，然而内存分配系统调用 sbrk 却鲜被直接使用，通常程序员会使用功能更加丰富的 malloc 库函数，而后者的实现中使用了 sbrk 系统调用。</p><p>因此，实际中我们不得不既使用系统调用，又使用某些库函数，然而对于一个函数来说，它究竟是系统调用还是库函数对于使用者来说是无感的，因此除了必须要区分两者时，本文对系统调用和库函数都使用<strong>系统函数 (funcition)</strong> 这一术语来表示。</p><p>如下是一份系统函数的速查表。</p><h2 id="文件-io-file-io"><a class="markdownIt-Anchor" href="#文件-io-file-io"></a> 文件 I/O (File I/O)</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td>open</td><td>打开或创建一个文件</td><td>&lt;fcntl.h&gt;</td></tr><tr><td>creat</td><td>创建一个文件（不推荐使用）</td><td>&lt;fcntl.h&gt;</td></tr><tr><td>read</td><td>从打开文件中读数据</td><td>&lt;unistd.h&gt;</td></tr><tr><td>write</td><td>向打开文件中写数据</td><td>&lt;unistd.h&gt;</td></tr><tr><td>lseek</td><td>显式地为一个打开文件设置偏移量</td><td>&lt;unistd.h&gt;</td></tr><tr><td>close</td><td>关闭一个打开文件</td><td>&lt;unistd.h&gt;</td></tr><tr><td>dup</td><td>复制一个现有的文件描述符</td><td>&lt;unistd.h&gt;</td></tr><tr><td>dup2</td><td>复制一个现有的文件描述符</td><td>&lt;unistd.h&gt;</td></tr><tr><td>sync</td><td>保证磁盘上实际文件系统与缓冲区中内容的一致性</td><td>&lt;unistd.h&gt;</td></tr><tr><td>fsync</td><td>保证磁盘上实际文件系统与缓冲区中内容的一致性</td><td>&lt;unistd.h&gt;</td></tr><tr><td>fdatasync</td><td>保证磁盘上实际文件系统与缓冲区中内容的一致性</td><td>&lt;unistd.h&gt;</td></tr><tr><td>fcntl</td><td>改变己经打开文件的属性</td><td>&lt;fcntl.h&gt;</td></tr><tr><td>ioctl</td><td>I/O操作的杂货箱</td><td>&lt;unistd.h&gt; in System V <br>&lt;sys/ioctl.h&gt; in BSD or Linux</td></tr></tbody></table><h2 id="文件和目录"><a class="markdownIt-Anchor" href="#文件和目录"></a> 文件和目录</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="标准-io"><a class="markdownIt-Anchor" href="#标准-io"></a> 标准 I/O</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="系统数据文件和信息"><a class="markdownIt-Anchor" href="#系统数据文件和信息"></a> 系统数据文件和信息</h2><p>Unix 系统的正常运作需要使用大量与系统有关的数据文件</p><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="进程环境"><a class="markdownIt-Anchor" href="#进程环境"></a> 进程环境</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="进程关系"><a class="markdownIt-Anchor" href="#进程关系"></a> 进程关系</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td>getpgrp</td><td>返回调用进程的进程组 ID</td><td></td></tr></tbody></table><h2 id="信号"><a class="markdownIt-Anchor" href="#信号"></a> 信号</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="线程控制"><a class="markdownIt-Anchor" href="#线程控制"></a> 线程控制</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="守护进程"><a class="markdownIt-Anchor" href="#守护进程"></a> 守护进程</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="高级-io"><a class="markdownIt-Anchor" href="#高级-io"></a> 高级 I/O</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h2 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h2><table><thead><tr><th>系统函数</th><th>描述</th><th>头文件</th></tr></thead><tbody></tbody></table><h1 id="进程控制-2"><a class="markdownIt-Anchor" href="#进程控制-2"></a> 进程控制</h1><h2 id="clone-系统调用"><a class="markdownIt-Anchor" href="#clone-系统调用"></a> clone 系统调用</h2><p>clone() 系统调用的基本用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *child_stack,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">/* pid_t *ptid, void *newtls, pid_t *ctid */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>成功时，调用者的进程中将会返回子进程的 thread ID；失败时返回 -1，子进程将不会被创建，同时将会触发 ERROR。</p><p>clone() 创建新进程，其行为类似于 fork()，通常使用 glibc 库中的包装函数 clone()，该函数基于 clone 系统调用。与 fork 不同，clone 允许子进程与父进程共享部分执行上下文的参数，例如虚拟地址空间、文件描述符表、信号处理程序等。</p><p>fork 是标准的 Unix 系统调用，用来创建进程，而在 Linux 中 clone 可以根据传递的选项创建不同的执行线程，新的执行线程可以遵循 UNIX 进程、POSIX 线程、介于两者之间或完全不同的事物（例如不同的容器）的语义。<code>pthread_create()</code> 和 <code>fork()</code> 底层实现都使用了 <code>clone()</code>。</p><p>通过 clone() 创建的子进程，从调用指向的函数 fn() 开始执行，而 fork() 创建的子进程将会从 fork 的调用点开始执行。当 fn(arg) 函数返回，子进程结束，函数 fn 的返回值就是子进程的退出状态码，子进程同样可以通过调用 exit() 和收到结束信号而显式结束。</p><p>child_stack 参数指定了子进程使用的栈，子进程不可以与父进程共享栈空间，由于绝大部分 Linux 的处理器的栈都是向下生长的，因此该参数需要指向栈顶空间。</p><p>flags 的最低字节指定了当子进程结束时需要发送给父进程的结束信号。如果该信号不是 SIGCHLD，则父进程在调用 wait() 等待子进程时必须指定 <code>__WALL</code> 或 <code>__WCLONE</code> 选项；如果未指定，则子进程退出时父进程将不会收到任何信号。</p><p>flags 还可以与零个或多个常量进行按位或运算，以指定在调用进程和子进程之间共享的内容，具体的常量可以查看 man 文档。</p><h1 id="进程关系-2"><a class="markdownIt-Anchor" href="#进程关系-2"></a> 进程关系</h1><p>当子进程终止时，父进程得到通知并能取得子进程的退出状态。</p><h2 id="终端登录"><a class="markdownIt-Anchor" href="#终端登录"></a> 终端登录</h2><p><img src="index/login.png" alt="login"><br><img src="index/shell.png" alt="shell"></p><h2 id="进程组"><a class="markdownIt-Anchor" href="#进程组"></a> 进程组</h2><p>每个进程除了有一进程 ID 之外，还属于一个进程组。进程组是一个或多个进程的集合。<br>同一进程组中的各进程接收来自同一终端的各种信号。<br>每个进程组有一个唯一的进程组ID</p><h2 id="会话"><a class="markdownIt-Anchor" href="#会话"></a> 会话</h2><p>会话 (session) 是一个或多个进程组的集合。<br>通常是由 shell 的管道将几个进程编成一组的。</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$ </span>proc1 | proc2 &amp;</span><br><span class="line"><span class="string">$ </span>proc3 | proc4 | proc5</span><br></pre></td></tr></table></figure><p><img src="index/session-control.png" alt="session-control"></p><ol><li>该进程变成新会话的会话首进程 (session leader，会话首进程是创建该会话的进程)。此<br>时，该进程是新会话中的唯一进程。</li><li>该进程成为一个新进程组的组长进程。新进程组 ID 是该调用进程的进程 ID。</li><li>该进程没有控制终端(下一节讨论控制终端)。如果在调用setsid之前该进程有一个<br>控制终端，那么这种联系也被切断。</li></ol><p><img src="index/job-control.png" alt="job-control"></p><h1 id="用户空间与内核的接口"><a class="markdownIt-Anchor" href="#用户空间与内核的接口"></a> 用户空间与内核的接口</h1><p>内核通过各种不同的接口把内部信急输出到用户空hl</p><ul><li>系统调用</li><li>procfs 这是个虚拟文件系统，通常是挂载到 /proc:，允许内核以文件的形式向用户空间输出内部信息，这些文件并没有实际存在于磁盘中，但是可以通过 cat 以及 &gt; shell 重定向运算符写入。</li><li>sysctl /proc/sys 此接口允许用户空间读取或修改内核变量的值。</li></ul><p>ioctl 系统调用</p><ul><li>Netlink 套接字 这是网络应用程序与内核通信时最新的首选机制，IPROUTE2 包中大多数命令都使用此接口。对 Linux 而言，Netlink 代表的就是 BSD 世界中的路由套接字 (routing socket)。</li></ul><h1 id="netlink"><a class="markdownIt-Anchor" href="#netlink"></a> Netlink</h1><ul><li><a href="https://stackoverflow.com/questions/862964/who-can-give-me-the-latest-netlink-programming-samples" target="_blank" rel="noopener">https://stackoverflow.com/questions/862964/who-can-give-me-the-latest-netlink-programming-samples</a></li></ul><h1 id="内核模块-kernel-module"><a class="markdownIt-Anchor" href="#内核模块-kernel-module"></a> 内核模块 (Kernel Module)</h1><p>内核模块是可以根据需要加载和卸载到内核中的代码段，它们扩展了内核的功能，但无需重新引导系统。</p><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="获取信息"><a class="markdownIt-Anchor" href="#获取信息"></a> 获取信息</h3><p>通过运行 <code>lsmod</code> 来查看哪些模块已经加载到内核中，该模块通过读取文件 <code>/proc/modules</code> 获取其信息。内核模块存储在 <code>/usr/lib/modules/kernel_release</code> 或者 <code>/lib/modules/kernel_release</code>，可以通过 <code>uname -r</code> 获取内核的版本。</p><p>以下是一些常用的命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>lsmod                                 <span class="comment"># 查看哪些模块已经加载到内核中</span></span><br><span class="line"><span class="variable">$ </span>modinfo module_name                   <span class="comment"># 显示有关模块的信息</span></span><br><span class="line"><span class="variable">$ </span>modprobe -c | less                    <span class="comment"># 显示所有模块的完整配置</span></span><br><span class="line"><span class="variable">$ </span>modprobe -c | grep module_name        <span class="comment"># 显示特定模块的完整配置</span></span><br><span class="line"><span class="variable">$ </span>modprobe --show-depends module_name   <span class="comment"># 列出模块的依赖项（包括模块本身）</span></span><br></pre></td></tr></table></figure><h3 id="自动加载机制"><a class="markdownIt-Anchor" href="#自动加载机制"></a> 自动加载机制</h3><p>今天，udev 会自动处理所有必需的模块加载，因此不需要特别的进行配置。需要加载的内核模块在 <code>/etc/modules-load.d/</code> 下的文件中明确列出，以便 systemd 在引导过程中加载它们。每个配置文件均以 <code>/etc/modules-load.d/&lt;program&gt;.conf</code> 的样式命名。</p><h3 id="手动加载机制"><a class="markdownIt-Anchor" href="#手动加载机制"></a> 手动加载机制</h3><p>模块如何手动载入入内核呢？当内核需要内核中不存在的功能时，内核模块守护程序 <code>kmod</code> 会执行 <code>modprobe</code> 来加载/卸载模块。<code>modprobe</code> 需要以下两种形式之一的字符串作为参数：</p><ul><li>模块名称 (A module name like softdog or ppp.)</li><li>模块标识符 (A more generic identifier like char−major−10−30.)</li></ul><p>除此之外，还可以通过 <code>insmod</code> 来加载模块，通过 <code>rmmod</code> 来卸载模块。模块的加载和卸载均需要管理员权限。</p><figure class="highlight elixir"><figcaption><span>加载模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>modprobe module_name</span><br><span class="line"><span class="variable">$ </span>insmod filename [args]    <span class="comment"># 不在标准目录下的内核文件，可以通过文件名加载。</span></span><br></pre></td></tr></table></figure><figure class="highlight elixir"><figcaption><span>卸载模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>modprobe -r module_name</span><br><span class="line"><span class="variable">$ </span>rmmod module_name</span><br></pre></td></tr></table></figure><h2 id="hello-world-模块"><a class="markdownIt-Anchor" href="#hello-world-模块"></a> Hello world 模块</h2><p><a href="https://stackoverflow.com/questions/3299386/how-to-use-netlink-socket-to-communicate-with-a-kernel-module" target="_blank" rel="noopener">How to use netlink socket to communicate with a kernel module?</a> 有一份示例代码，包括两部分：</p><ul><li>Kernel module</li><li>User program</li></ul><p>其中内核模块程序可以通过以下 Makefile 编译链接，然后通过 <code>insmod hello.ko</code> 来载入。</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj-m = hello.o</span><br><span class="line">KVERSION = <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(KVERSION)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(KVERSION)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure><h1 id="netfilter-网络框架"><a class="markdownIt-Anchor" href="#netfilter-网络框架"></a> Netfilter 网络框架</h1><p>Netfilter 是 Linux 内核中的一个软件框架，用于管理网络数据包。不仅具有网络地址转换的功能，也具备数据包内容修改以及数据包过滤等防火墙功能。Netfilter 在 Linux 网络堆栈中引入了五个挂载/钩子函数 (hook) 以在不同阶段执行数据包处理，内核模块可以向钩子注册回调函数，当数据流量经过这些钩子时候将会调用这些函数，从而完成对流量的控制。</p><p>详细内容可见 <a class="btn" href="/2020/07/19/linux-netfilter/">            <i class="fa fa-book fa-fw fa-lg"></i>Netfilter 网络框架          </a></p><h1 id="负载均衡-lvs"><a class="markdownIt-Anchor" href="#负载均衡-lvs"></a> 负载均衡 (LVS)</h1><p>Linux Virtual Server (lvs) 是 Linux 内核自带的负载均衡器，也是目前性能最好的软件负载均衡器之一。LVS 包括 ipvs 内核模块和 ipvsadm 用户空间命令行工具两部分。</p><p>在 LVS 中，节点分为 Director Server 和 Real Server 两个角色，其中 Director Server 是负载均衡器所在节点，而 Real Server 则是后端服务节点。</p><p>详细内容可见 <a class="btn" href="/2020/07/18/linux-lvs/">            <i class="fa fa-book fa-fw fa-lg"></i>Linux Virtual Server          </a></p><h1 id="流量控制-tc"><a class="markdownIt-Anchor" href="#流量控制-tc"></a> 流量控制 (TC)</h1><p>流量控制 (Traffic Control, TC) 是 Linux 内核提供的流量限速、整形和策略控制机制。它以 qdisc-class-filter 的树形结构来实现对流量的分层控制。</p><p>详细内容可见 <a class="btn" href="/2020/09/10/linux-tc/">            <i class="fa fa-book fa-fw fa-lg"></i>Tranfic Control          </a></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://tonydeng.github.io/sdn-handbook/" target="_blank" rel="noopener">SDN handbook</a></li><li><a href="https://unix.stackexchange.com/questions/104714/what-is-the-difference-between-unix-linux-bsd-and-gnu" target="_blank" rel="noopener">What is the difference between Unix, Linux, BSD and GNU?</a></li><li><a href="https://www.kernel.org/doc/html/latest/" target="_blank" rel="noopener">The Linux Kernel documentation</a></li><li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a></li><li><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture" target="_blank" rel="noopener">a-deep-dive-into-iptables-and-netfilter-architecture</a></li><li><a href="https://computing.llnl.gov/tutorials/pthreads/" target="_blank" rel="noopener">POSIX Threads Programming</a></li><li><a href="https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking/" target="_blank" rel="noopener">Introduction to Linux interfaces for virtual networking</a></li></ul>]]></content>
      
    </entry>
    
    
  
</search>
